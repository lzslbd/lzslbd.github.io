<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LBD&#39;s Blog</title>
  
  <subtitle>大数据与分布式</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linbingdong.com/"/>
  <updated>2018-04-22T14:36:57.000Z</updated>
  <id>http://linbingdong.com/</id>
  
  <author>
    <name>LBD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式系统的问题</title>
    <link href="http://linbingdong.com/2018/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://linbingdong.com/2018/04/18/分布式系统的问题/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-22T14:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容翻译自《Designing Data-Intensive Applications》一书的第8章。</p></blockquote><a id="more"></a><p>近几章主要介绍系统如何处理错误。例如，我们讨论了副本故障转移，复制滞后和事务的并发控制。当我们理解实际系统中可能出现的各种边界情况时，我们就能更好地处理它们。</p><p>前几章虽然谈论了很多关于错误的问题，但是还是太乐观了。在本章中，我们将最悲观地假设“任何可能出故障的，最终都会出故障”。</p><p>分布式系统编程与在单机上编写软件有本质区别——主要区别在于分布式系统中有很多新奇的可能出故障的方式。 本章中，我们将了解在实践中出现的问题，并了解哪些我们可以依赖，哪些不行。</p><p>最后，作为工程师，我们的任务是构建能够完成工作的系统（即满足用户所期望的保证），尽管各个部件都出错了。 在第9章中，我们将看看可以在分布式系统中提供这种保证的算法的一些示例。 但首先，在本章中，我们必须了解我们面临的挑战。</p><p>本章是对分布式系统中可能出现的问题的悲观和沮丧的概述。 我们将研究网络问题（第277页的“不可靠的网络”）; 时钟和时序问题（第287页上的“不可靠的时钟”）; 我们将讨论它们可以避免的程度。 所有这些问题造成的后果都会让人迷惑，因此我们将探讨如何思考分布式系统的状态以及如何推理已发生的事情（第300页的“知识，真相和谎言”）。</p><h2 id="错误和部分故障"><a href="#错误和部分故障" class="headerlink" title="错误和部分故障"></a>错误和部分故障</h2><p>当你在单机上写程序时，它通常会以一种可预测的方式运行：要么正常工作，要么无法工作。有bug的软件可能会让人觉得电脑出问题了（通常重新启动就能解决问题），但大部分还是软件写得不好的后果。</p><p>没有什么根本原因能让单机上的软件表现得奇怪：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统失效（例如“蓝屏死机”，无法启动）。具有良好软件的单机通常功能完好或完全损坏，而不在两者之间。</p><p>这是计算机设计中的一个慎重选择：如果发生内部故障，我们宁愿计算机完全崩溃，而不是返回错误的结果，因为错误的结果很难处理，并且令人困惑。因此，计算机隐藏了它们实现所依赖的模糊物理现实，并提出了一个理想化的系统模型，它可以与数学完美结合起来。CPU指令总是做同样的事情; 如果你将一些数据写入内存或磁盘，则该数据保持完好并且不会随机损坏。 这种始终正确计算的设计目标可以追溯到第一台数字计算机。</p><p>当你编写运行在多台计算机上并通过网络连接的软件时，情况完全不同。 在分布式系统中，我们不再处于理想系统模型中 - 我们别无选择，只能面对物理世界的混乱现实。 而在现实世界中，正如这个轶事所示，各种各样的事情可能会出错：</p><blockquote><p>在我有限的经验中，我处理过单个数据中心（DC）中的长时间网络分区，PDU（配电单元）故障，交换机故障，整个机架的意外电源故障，全DC主干故障，全DC 电力故障和一位低血糖驾驶员将他的福特皮卡撞进空调系统。我甚至不是一个运维人员。——Coda Hale</p></blockquote><p>在分布式系统中，可能出现这样的情况，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式出故障。这就叫做部分故障。该问题的难点在于部分故障是不确定的：如果你试图做任何包含多个节点和网络的事情，它可能有时工作正常，有时出现不可预知的故障。正如我们将要看到的，你可能甚至不知道某件事是否成功，因为消息在网络中传播所花费的时间也是不确定的！</p><p>这种不确定性和部分故障的可能性是分布式系统难以处理的原因。</p><h3 id="云计算和超级计算"><a href="#云计算和超级计算" class="headerlink" title="云计算和超级计算"></a>云计算和超级计算</h3><p>关于如何构建大型计算系统有一系列哲学：</p><ul><li><p>规模的一端是高性能计算（HPC）领域。拥有数千个CPU的超级计算机通常用于计算密集型科学计算任务，如天气预报或分子动力学（模拟原子和分子的运动）。</p></li><li><p>另一端是云计算，云计算没有非常明确的定义，但通常与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及按时计费联系在一起。</p></li></ul><p>有了这些哲学，处理错误的方法就非常不同了。在超级计算机中，作业通常会对其计算状态不时地做检查点到持久存储上。如果一个节点发生故障，通常的解决方案是简单地停止整个集群工作负载。故障节点修复后，从上一个检查点重新开始计算。因此，超级计算机更像是一台单节点计算机而不是分布式系统：它通过升级为完全故障来处理部分故障 - 当系统的任何部分发生故障，简单地让整个系统崩溃（就像单机上的内核恐慌一样）。</p><p>在本书中，我们重点介绍实现互联网服务的系统，这些系统通常看起来与超级计算机有很大不同：</p><ul><li><p>许多与互联网有关的应用程序都是在线的，在某种意义上它们需要能够随时为用户提供低延迟服务。服务不可用（例如，停止群集以进行修复）是不可接受的。相比之下，像天气模拟这样的离线（批处理）作业可以停止并重启，而且影响很小。</p></li><li><p>超级计算机通常由专用硬件构建，其中每个节点都非常可靠，并且节点通过共享内存和远程直接内存访问（RDMA）进行通信。另一方面，云服务中的节点是由普通机器构建的，它们能以较低的成本提供相同的性能，但也具有较高的故障率。</p></li><li><p>大型数据中心网络通常基于IP和以太网，以Clos拓扑排列来提供高对分带宽。超级计算机通常使用专门的网络拓扑结构，例如多维网格和toruses，这为具有已知通信模式的HPC工作负载提供了更好的性能。</p></li><li><p>系统越大，系统中有组件出故障的概率越高。随着时间的推移，故障被修复，新的组件又出故障，但是在一个有数千个节点的系统中，认为系统中总是在发生故障是一个合理的假设。当错误处理策略不够有效时，一个大型系统最终会花费大量的时间从故障中恢复，而不是做有用的工作。</p></li><li><p>如果系统可以容忍失败的节点并且仍然作为一个整体继续工作，这对于操作和维护是一个非常有用的特性：例如，可以执行滚动升级（参阅第4章），一次重启一个节点，系统继续为用户提供服务而不中断。在云环境中，如果一台虚拟机运行不佳，可以将其杀死并请求一台新的虚拟机（希望新的虚拟机速度更快）。</p></li><li><p>在地理分布式部署中（保持数据在地理位置上接近用户以减少访问延迟），通信很可能通过互联网进行，与本地网络相比，速度慢且不可靠。超级计算机通常假设它们的所有节点都靠近在一起。</p></li></ul><p>如果我们想让分布式系统工作，就必须接受部分故障的可能性，并在软件中建立容错机制。换句话说，我们需要从不可靠的组件中构建可靠的系统。（正如在第6页的“可靠性”中所讨论的那样，没有完美的可靠性，所以我们需要了解我们可以实际承诺的极限。）</p><p>即使在只有少数节点的小型系统中，考虑部分故障也很重要。在一个小型系统中，很可能大部分组件在大多数时间都正常工作。但是，迟早会有一部分系统出现故障，软件将不得不以某种方式处理它。故障处理必须是软件设计的一部分，并且软件的操作员需要知道发生故障时软件会出现什么行为。</p><p>假定错误很少发生，并只往好的想是不明智的。考虑各种可能的错误（甚至是不太可能的错误），并在测试环境中人为地创建这些情况以查看会发生什么是非常重要的。在分布式系统中，抱着怀疑，悲观和偏执的态度才能取得成功。</p><h3 id="从不可靠的组件中构建可靠的系统"><a href="#从不可靠的组件中构建可靠的系统" class="headerlink" title="从不可靠的组件中构建可靠的系统"></a>从不可靠的组件中构建可靠的系统</h3><p>你可能会怀疑这是否有道理——直觉上，一个系统只能和其最不可靠的组件（它最薄弱的环节）一样可靠。事实并非如此：事实上，从不太可靠的基础构建更可靠的系统，这在计算中是一个古老的想法。 例如：</p><ul><li><p>纠错码允许数字数据在通信信道上准确传输，偶尔会出现某些位错误，例如由于无线网络上的无线电干扰。</p></li><li><p>IP（互联网协议）是不可靠的：数据包可能丢失，延迟，重复或乱序。TCP（传输控制协议）在IP之上提供了一个更可靠的传输层：它确保丢失的数据包被重传，消除重复，并且数据包被重新组装为它们的发送顺序。</p></li></ul><p>虽然系统可能比其基础部分更可靠，但它的可靠性总是有限的。例如，纠错码可以处理少量的单比特错误，但是如果信号被干扰所淹没，那么通过通信信道可以获得的数据量就有一个基本限制。TCP可以对我们隐藏数据包丢失，重复和乱序，但它不能在网络中奇迹般地消除延迟。</p><p>虽然更可靠的更高级别的系统并不完美，但它仍然很有用，因为它可以处理一些棘手的低级故障，因此通常也可以更轻松地解决和处理其余的故障。</p><h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p>正如在第二部分的介绍中所讨论的，我们在本书中关注的分布式系统是shared-nothing系统：即一堆机器通过网络连接。网络是这些机器可以通信的唯一方式。我们假设每台机器有自己的内存和磁盘，一台机器无法访问另一台机器的内存或磁盘（除了通过网络向服务发出请求外）。</p><p>shared-nothing并不是构建系统的唯一方式，但它已经成为构建互联网服务的主要方式，原因有几个：它相对便宜，因为它不需要特殊的硬件，可以利用商品化的云计算服务， 可以通过跨多个地理分布的数据中心进行冗余来实现高可靠性。</p><p>互联网和数据中心的大部分内部网络（通常是以太网）都是异步分组网络。 在这种网络中，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它何时到达，甚至是否能到达。如果你发送请求并期待响应，很多事情可能会出错（其中一些如图8-1所示）：</p><ol><li>你的请求可能已经丢失（可能是某人拔掉了网线）。</li><li>你的请求可能正在队列中等待，稍后会被发送（也许网络或收件人过载）。</li><li>远程节点可能失败（可能崩溃或掉电）。</li><li>远程节点可能暂时停止了响应（可能正在经历长时间的垃圾回收暂停;请参阅第295页上的“进程暂停”），但稍后它会再次开始响应。</li><li>远程节点可能处理了你的请求，但响应在网络上丢失了（可能是网络交换机配置错误）。</li><li>远程节点可能已经处理了你的请求，但响应已经延迟并且将稍后发送（可能是网络或你自己的机器过载）。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1752522-5d73a60621d1b78f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-1 如果你发送了一个请求没有得到响应，无法区分是发生了以下哪种情况：（a）请求丢失了（b）对方节点宕机（c）响应丢失了"></p><p>发送方甚至无法知道数据包是否已经被发送：唯一的选择是让接收方发送响应消息，这可能会丢失或延迟。这些问题在异步网络中难以区分：你拥有的唯一信息是你尚未收到响应。如果你向另一个节点发送请求并且未收到回复，也无法知道是什么原因。</p><p>处理该问题通常的方法是使用超时：一段时间后就放弃等待并假设响应不会送达。但是，当发生超时时，你仍然不知道远程节点是否收到了你的请求（如果请求仍然在某个地方排队，它仍然可能会被传送给接收方，即使发送方已经放弃了）。</p><h3 id="网络故障实践"><a href="#网络故障实践" class="headerlink" title="网络故障实践"></a>网络故障实践</h3><p>几十年来我们一直在建立计算机网络——人们可能希望现在我们已经知道了如何使它们变得可靠。但是，似乎我们还没有成功。</p><p>有一些系统的研究和大量的轶事证据表明，即使在由公司运营的数据中心那样的受控环境中，网络问题也可能非常普遍。在一家中等规模的数据中心进行的一项研究发现，每个月大约发生12次网络故障，其中一半单台机器断开连接，一半整个机架断开连接。另一项研究测量了架顶式交换机，汇聚交换机和负载平衡器等组件的故障率，发现添加冗余网络设备不会像你所希望的那样减少故障，因为它不能防范人为错误（例如，配置错误的交换机），这是造成网络中断的主要原因。</p><p>公共云服务（如EC2）因频繁出现短暂的网络故障而臭名昭着，管理良好的专用数据中心网络会比较稳定。尽管如此，没有人能够避免网络问题的干扰：例如，交换机软件升级期间的问题可能会触发网络拓扑重新配置，在此期间网络数据包可能会延迟超过一分钟。鲨鱼可能咬住海底电缆并损坏它们。其他令人惊讶的故障包括网络接口有时会丢弃所有入站数据包，但成功发送出站数据包。因此，仅仅因为网络链接在一个方向上正常工作并不能保证它也在相反的方向也正常工作。</p><blockquote><p><strong>网络分区</strong><br>当网络的一部分由于网络故障而与其余部分断开时，有时称为网络分区或网络分割。 在本书中，我们使用更一般的术语网络故障，以避免与如第6章所述的存储系统的分区（碎片）混淆。</p></blockquote><p>即使你的环境中很少发生网络故障，但可能发生故障的事实意味着你的软件需要能够处理它们。网络上的通信总有可能会失败，这是没有办法的。</p><p>如果网络故障的错误处理未经过定义和测试，则可能会发生反复无常的错误：例如，即使网络恢复，群集也可能会死锁并永久无法为请求提供服务，甚至可能会删除你的所有数据。如果软件不在受控的情况下，可能会有意想不到的行为。</p><p>处理网络故障并不一定意味着容忍它们：如果你的网络通常相当可靠，则有效的方法可能是在网络遇到问题时向用户简单显示错误消息。但是，你需要知道你的软件会对网络问题做出什么反应，并确保系统能够从中恢复。刻意地触发网络问题并测试系统响应是有意义的（这是Chaos Monkey背后的想法;请参阅第6页的“可靠性”）。</p><h3 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h3><p>很多系统都需要自动检测故障节点。 例如：</p><ul><li>负载平衡器需要停止向死节点发送请求。</li><li>在single-leader复制的分布式数据库中，如果leader发生故障，需要提升一个follower成为新的leader（参阅第152页的“处理节点故障”）。</li></ul><p>不幸的是，网络的不确定性使得判断一个节点是否正常工作变得很困难。在某些特定情况下，你可能会收到一些反馈信息，以明确告诉你某些组件不正常工作：</p><ul><li><p>如果你可以到达运行节点的机器，但没有进程正在监听目标端口（例如，因为进程崩溃），操作系统将通过发送RST或FIN数据包来帮助关闭或拒绝TCP连接。但是，如果节点在处理请求过程中崩溃，你将无法知道远程节点实际已经处理了多少数据。</p></li><li><p>如果节点进程崩溃（或被管理员杀死）但节点的操作系统仍在运行，脚本可以通知其他节点有关崩溃的信息，以便另一个节点可以快速接管而无需等待超时。</p></li><li><p>如果你有权限访问数据中心网络交换机的管理界面，则可以查询它们以检测硬件级别的链路故障（例如，远程机器是否关闭电源）。如果你通过互联网连接，或者你处于共享数据中心但无权限无法访问交换机，或者由于网络问题而无法访问管理界面，则无法使用该选项。</p></li><li><p>如果路由器确定你尝试连接的IP地址无法访问，它可能会用ICMP目标无法访问的数据包回复你。但是，路由器不具备神奇的故障检测能力——它受到与网络其他组成部分相同的限制。</p></li><li><p>远程节点宕机的快速反馈很有用，但你不能指望它。即使TCP确认数据包已发送，应用程序在处理数据之前可能已崩溃。如果你想确认一个请求是成功的，需要在应用程序本身积极响应。</p></li><li><p>相反，如果出现问题，你可能会在某个层次上得到错误响应，但通常你必须假设根本得不到响应。你可以重试几次（TCP重试是透明的，但您你可以在应用程序级别重试），等待超时过去，并且如果在超时范围内没有收到响应，才最终宣布节点失效。</p></li></ul><h3 id="超时和无限延迟"><a href="#超时和无限延迟" class="headerlink" title="超时和无限延迟"></a>超时和无限延迟</h3><p>如果超时是检测故障的唯一可靠方法，那么超时时间应该多长？不幸的是没有简单的答案。</p><p>超时时间长意味着需要长时间等待才能宣告一个节点死亡（并且在此期间，用户可能不得不等待或看到错误消息）。超时时间短可以更快地检测到故障，但是会带来更高的误判的风险，例如节点可能只是暂时变慢（比如由于工作或网络负载高峰）就被误判为死亡。</p><p>过早地宣告一个节点已经死亡是有问题的：如果节点实际上处于活动状态并且正在执行一些操作（例如，发送电子邮件），然后另一个节点接管，那么该操作最终可能会执行两次。我们将在第300页的“知识，真相和谎言”以及第9章和第11章中更详细地讨论该问题。</p><p>当一个节点被宣告死亡时，其职责需要转移到其他节点，这会给其他节点和网络带来额外的负担。如果系统已经处于高负载状态，过早宣告节点死亡会使问题变得更糟。特别地，可能节点实际上并未死亡，只是由于负载太高而响应缓慢。将其负载转移到其他节点可能会导致瀑布式的失败（在极端情况下，所有节点都宣告对方死亡，然后一切都停止工作）。</p><p>假设一个虚拟系统的网络可以保证数据包的最大延迟——每个数据包要么在一段时间内送达，要么丢失，但时间永远不会超过d。此外，假设可以保证非故障节点在总是在一段时间r内处理请求。在这种情况下，可以保证每个成功的请求都会在2d + r的时间内收到响应，并且如果在此时间内没有收到响应，则知道网络或远程节点不工作。如果情况真如上述那样，2d + r将是一个合理的超时时间。</p><p>不幸的是，我们所使用的大多数系统都没有这些保证：异步网络具有无限的延迟（即它们尽可能快地发送数据包，但数据包到达所需的时间没有上限） ，并且大多数服务器实现不能保证它们可以在特定时间内处理请求（请参阅“响应时间保证”（第298页））。对于故障检测，大部分时间内快是不够的：如果超时时间较短，则往返时间只需要瞬间上升就会导致系统失去平衡。</p><h4 id="网络拥塞和排队"><a href="#网络拥塞和排队" class="headerlink" title="网络拥塞和排队"></a>网络拥塞和排队</h4><p>在开车汽车时，由于交通堵塞，在路上花的时间往往不尽相同。类似的，计算机网络上的数据包延迟的可变性通常也是由于排队：</p><ul><li>如果多个不同的节点同时尝试向相同的目的地发送数据包，则网络交换机必须将它们排队并将它们逐个送入目标网络链路（如图8-2所示）。在繁忙的网络链路上，数据包可能需要等待一段时间才能获得一个槽（这称为网络拥塞）。如果传入的数据太多以至于交换机队列填满，数据包将被丢弃，因此需要重新发送数据包，即使网络运行良好。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1752522-24120c1100abacf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-2"></p><ul><li><p>当数据包到达目标机器时，如果所有CPU内核当前都处于繁忙状态，则来自网络的传入请求将被操作系统排队，直到应用程序准备好处理它为止。根据机器的负载情况，这可能需要一段任意长度的时间。</p></li><li><p>在虚拟化环境中，当另一个虚拟机正在使用CPU核的时候，正在运行的操作系统通常会暂停几十毫秒。在此期间，虚拟机无法使用网络中的任何数据，因此输入数据被虚拟机监视器排队（缓冲），这进一步增加了网络延迟的可变性。</p></li><li><p>TCP执行流量控制（也称为拥塞避免或背压），节点限制自己的发送速率以避免网络链路或接收节点过载。这意味着甚至在数据进入网络之前，发送者也会让数据排队。</p></li></ul><p>此外，如果TCP在某个超时时间内未得到确认（根据观察的往返时间计算），则认为数据包丢失，并且丢失的数据包将自动重新发送。尽管应用程序没有看到数据包丢失和重传，但它确实会看到由此产生的延迟（等待超时过期，然后等待重传的数据包得到确认）。</p><p><strong>TCP与UDP</strong></p><p>一些对延迟敏感的应用程序（如视频会议和IP语音（VoIP））使用UDP而不是TCP。这是延迟的可靠性和可变性之间的折衷：由于UDP不执行流量控制并且不重传丢失的数据包，所以它避免了一些可变网络延迟的原因（尽管它仍然易受交换机队列和调度延迟的影响）。</p><p>在延迟数据毫无价值的情况下，UDP是一个不错的选择。例如，在VoIP电话呼叫中，可能没有足够的时间在其数据将在扬声器上播放之前重新传输丢失的数据包。在这种情况下，重传数据包没有意义——应用程序必须用无声填充丢失数据包的时隙（导致声音短暂中断），然后在数据流中继续。相反，重试发生在人类层面。（“你能再说一遍吗？刚刚没声音了。”）</p><p>所有这些因素都会造成网络延迟的变化。当系统接近其最大容量时，排队延迟的范围很大：拥有大量备用容量的系统可以轻松消化队列，而在高度使用的系统中，很快就会排起长队列。</p><p>在公有云和多租户数据中心中，资源被许多客户共享：网络链路和交换机，甚至每台计算机的网络接口和CPU（在虚拟机上运行时）都是共享的。批处理工作负载（如MapReduce）（请参阅第10章）可以轻松地使网络链接饱和。由于你无法控制或了解其他客户对共享资源的使用情况，如果你身边的某个人正在使用大量资源，网络延迟可能会变化无常。</p><p>在这样的环境中，你只能通过实验来选择超时时间：在一个延长的周期中测试和多台机器的网络往返时间分布，以确定延迟可变性的期望。然后，考虑应用程序的特性，你可以在故障检测延迟与过早超时风险之间确定一个适当的折衷。</p><p>更好的是，系统不是使用配置的常量超时，而是能够连续测量响应时间及其变化（抖动），并根据观察到的响应时间分布自动调整超时。这可以用Phi Accrual故障检测器完成，该检测器在Akka和Cassandra中被使用。TCP重传超时运行原理类似。</p><h4 id="同步与异步网络"><a href="#同步与异步网络" class="headerlink" title="同步与异步网络"></a>同步与异步网络</h4><p>如果我们可以依赖网络来传递具有固定最大延迟的数据包，而不是丢弃数据包，那么分布式系统就会简单得多。为什么我们不能在硬件级别解决这个问题，并使网络可靠，以便软件不必考虑这些问题？</p><p>为了回答这个问题，将数据中心网络与非常可靠的传统固定电话网络（非蜂窝，非VoIP）进行比较是很有趣的：延迟音频帧和掉话是非常罕见的。电话呼叫需要始终较低的端到端延迟和足够的带宽来传输语音的音频样本。在计算机网络中拥有类似的可靠性和可预测性不是很好吗？</p><p>当你通过电话网络拨打电话时，它会建立一条线路：沿着两个呼叫者之间的整个路由为呼叫分配固定的有保证的带宽量。该线路保持占用，直到通话结束。例如，ISDN网络以每秒4000帧的固定速率运行。呼叫建立后，每个帧内（每个方向）分配16位空间。因此，在通话期间，每一方都保证能够每250微秒发送一个精确的16位音频数据。</p><p>这种网络是同步的：即使数据通过多个路由器，也不会受到排队的影响，因为呼叫的16位空间已经在网络的下一跳中保留下来了。而且由于没有排队，网络的最大端到端延迟是固定的。我们称之为有限的延迟。</p><p><strong>我们不能简单地使网络延迟可预测吗？</strong></p><p>请注意，电话网络中的线路与TCP连接非常不同：线路是固定数量的预留带宽，在线路建立时没有人可以使用，而TCP连接的数据包有机会使用任何可用的网络带宽。你可以为TCP提供可变大小的数据块（例如电子邮件或网页），TCP会尽可能在最短的时间内传输它。当TCP连接空闲时，不使用任何带宽。如果数据中心网络和互联网是线路交换网络，那么建立线路后可以确保最大往返时间。然而，它们并不是：以太网和IP是分组交换协议，它们受到排队的影响，从而导致网络无限延迟。这些协议没有线路的概念。</p><p>为什么数据中心网络和互联网使用分组交换？答案是，它们针对突发流量进行了优化。一个电路适用于音频或视频通话，在通话期间需要每秒传送相当恒定的比特数。另一方面，请求网页，发送电子邮件或传输文件没有任何特定的带宽需求，我们只是希望它尽快完成。</p><p>如果你想通过线路传输文件，则必须猜测带宽分配。如果你猜的太低，传输速度会不必要的太慢，导致网络容量没有使用。如果你猜得太高，线路就无法建立（因为如果无法保证其带宽分配，网络不能建立线路）。因此，使用线路进行突发数据传输会浪费网络容量，并导致传输不必要的缓慢。相比之下，TCP会动态调整数据传输速率以适应可用的网络容量。</p><p>已经有一些尝试构建支持线路交换和分组交换的混合网络，例如ATM。例如InfiniBand：它实现了链路层的端到端流量控制，减少了网络排队的概率，尽管它仍然可能因链路拥塞而遭受延迟。通过谨慎使用服务质量（QoS，数据包的优先级和调度）和准入控制（限速发送器），可以仿真分组网络上的线路交换，或提供统计上有界的延迟。</p><p><strong>延迟和资源使用</strong></p><p>更一般地说，你可以将可变延迟视为动态资源分区的结果。</p><p>假设两台电话交换机之间有一条线路，可以同时进行10,000个呼叫。通过此线路切换的每个电路都占用其中一个呼叫插槽。因此，你可以将线路视为可由多达10,000个并发用户共享的资源。资源以静态方式分配：即使你现在是线路上唯一的电话，并且所有其他9,999个插槽都未使用，你的线路仍将分配跟线路被充分利用时相同的固定数量的带宽。</p><p>相比之下，互联网动态分享网络带宽。发送者竞争以尽可能快地通过网络获得它们的分组，并且网络交换机决定发送哪个分组（即，带宽分配）。这种方法有排队的缺点，但优点是它最大限度地利用了线路。线路成本固定，所以如果你更充分地利用它，通过该线路发送的每个字节都更便宜。</p><p>CPU也会出现类似的情况：如果你在多个线程之间动态共享每个CPU核，则有时候一个线程必须在另一个线程运行时等待操作系统的运行队列，因此线程可能被暂停不同的时间长度。但是，与为每个线程分配静态数量的CPU周期相比，这会更充分地利用硬件（请参阅第298页的“响应时间保证”）。更高的硬件利用率也是使用虚拟机的重要动机。</p><p>如果资源是静态分区的（例如，专用硬件和专用带宽分配），则在某些环境中可实现延迟保证。但是，这是以降低利用率为代价的。换句话说，它是更昂贵的。另一方面，动态资源分配下的多租户提供了更好的利用率，所以它更便宜，但它具有可变延迟的缺点。</p><p>网络中的可变延迟不是自然规律，而仅仅是成本/收益折衷的结果。</p><p>但是，此类服务质量目前尚未在多租户数据中心和公有云或通过互联网进行通信时可用。当前部署的技术无法让我们对网络的延迟或可靠性做出任何保证：我们必须假定网络拥塞，排队和无限延迟可能发生。因此，超时时间没有“正确”的值，需要通过实验确定。</p><p><strong>未完待续。。。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文内容翻译自《Designing Data-Intensive Applications》一书的第8章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PhxPaxos源码分析——Paxos算法实现</title>
    <link href="http://linbingdong.com/2017/11/21/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://linbingdong.com/2017/11/21/PhxPaxos源码分析——Paxos算法实现/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-11-22T00:41:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇主要来分析Paxos算法实现的部分，我想这应该也是读者最感兴趣的。在看这篇文章之前，如果之前对Paxos算法没有了解的童鞋可以看下这篇文章：<a href="http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/">Paxos算法原理与推导</a>，相信了解Paxos算法后再来通过源码看算法实现应该会很酸爽。</p><a id="more"></a><p>Paxos算法中最重要的两个角色是<strong>Proposer</strong>和<strong>Acceptor</strong>。当然Leaner也很重要，特别是在PhxPaxos的实现中，Leaner具有重要的功能。但是因为《Paxos Made Simple》论文中主要还是Proposer和Acceptor，因此这篇文章还是以这两个角色为主，通过源码来回顾论文中Paxos算法的过程，同时也看看工程实现和论文的描述有什么区别。</p><p>这里先贴出Paxos算法的过程，方便大家对照接下来的工程实现。</p><ul><li><p><strong>Prepare阶段：</strong></p><p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。</p><p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。</p></li><li><p><strong>Accept阶段：</strong></p><p>(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</p><p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</p></li></ul><h2 id="Proposer"><a href="#Proposer" class="headerlink" title="Proposer"></a>Proposer</h2><p>因为Proposer需要维护或者说记录一些状态信息，包括自己的提案编号ProposalID、提出的Value、其他Proposer提出的最大的提案编号HighestOtherProposalID、Acceptor已经接受过的编号最大的提案的值等，因此这里专门有一个ProposerState类来管理这些信息。同样Acceptor也有一个AcceptorState类来管理Acceptor相关的信息。</p><p>先来看下ProposerState的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ProposerState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProposerState(<span class="keyword">const</span> Config * poConfig);</span><br><span class="line">    ~ProposerState();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetStartProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NewPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddPreAcceptValue</span><span class="params">(<span class="keyword">const</span> BallotNumber &amp; oOtherPreAcceptBallot, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sOtherPreAcceptValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> uint64_t <span class="title">GetProposalID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp; <span class="title">GetValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetOtherProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llOtherProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetHighestOtherPreAcceptBallot</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llProposalID;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llHighestOtherProposalID;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_sValue;</span><br><span class="line"></span><br><span class="line">    BallotNumber m_oHighestOtherPreAcceptBallot;</span><br><span class="line"></span><br><span class="line">    Config * m_poConfig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本都是对这些信息的set跟get，很容易理解。直接来看Proposer类的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Proposer : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Proposer(</span><br><span class="line">            <span class="keyword">const</span> Config * poConfig, </span><br><span class="line">            <span class="keyword">const</span> MsgTransport * poMsgTransport,</span><br><span class="line">            <span class="keyword">const</span> Instance * poInstance,</span><br><span class="line">            <span class="keyword">const</span> Learner * poLearner,</span><br><span class="line">            <span class="keyword">const</span> IOLoop * poIOLoop);</span><br><span class="line">    ~Proposer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置起始的ProposalID</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetStartProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化新的一轮Paxos过程，每一轮叫做一个Paxos Instance，每一轮确定一个值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitForNewPaxosInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Proposer发起提案的入口函数。参数sValue即Proposer自己想提出的value，当然最终提出的value不一定是这个，需要根据Acceptor再Prepare阶段的回复来确定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NewValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断Proposer是否处于Prepare阶段或Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsWorking</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应Paxos算法中的Prepare阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prepare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bNeedNewBallot = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段等待Acceptor的回复，统计投票并确定是否进入Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPrepareReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段被拒绝</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExpiredPrepareReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应Paxos算法中的Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段等待Acceptor的回复，统计投票并确定值(Value)是否被选定(Chosen)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAcceptReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段被拒绝</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExpiredAcceptReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPrepareTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAcceptTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出Prepare阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExitPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExitAccept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消跳过Prepare阶段，也就是必须先Prepare阶段再Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CancelSkipPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddPrepareTimer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddAcceptTimer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProposerState m_oProposerState;</span><br><span class="line">    MsgCounter m_oMsgCounter;</span><br><span class="line">    Learner * m_poLearner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bIsPreparing;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsAccepting;</span><br><span class="line"></span><br><span class="line">    IOLoop * m_poIOLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> m_iPrepareTimerID;</span><br><span class="line">    <span class="keyword">int</span> m_iLastPrepareTimeoutMs;</span><br><span class="line">    <span class="keyword">uint32_t</span> m_iAcceptTimerID;</span><br><span class="line">    <span class="keyword">int</span> m_iLastAcceptTimeoutMs;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llTimeoutInstanceID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bCanSkipPrepare;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bWasRejectBySomeone;</span><br><span class="line"></span><br><span class="line">    TimeStat m_oTimeStat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="NewValue"><a href="#NewValue" class="headerlink" title="NewValue"></a>NewValue</h3><p>下面就从NewValue方法入手：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Proposer :: NewValue(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span><br><span class="line">&#123;</span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;NewProposal(sValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_oProposerState.GetValue().size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_oProposerState.SetValue(sValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_iLastPrepareTimeoutMs = START_PREPARE_TIMEOUTMS;</span><br><span class="line">    m_iLastAcceptTimeoutMs = START_ACCEPT_TIMEOUTMS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果可以跳过Prepare阶段并且没有被Acceptor拒绝过，则直接进入Accept阶段</span></span><br><span class="line">    <span class="keyword">if</span> (m_bCanSkipPrepare &amp;&amp; !m_bWasRejectBySomeone)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;NewProposalSkipPrepare();</span><br><span class="line"></span><br><span class="line">        PLGHead(<span class="string">"skip prepare, directly start accept"</span>);</span><br><span class="line">        Accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则先进入Prepare阶段</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if not reject by someone, no need to increase ballot</span></span><br><span class="line">        Prepare(m_bWasRejectBySomeone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以直接进入Accept阶段的前提是该Proposer已经发起过Prepare请求且得到半数以上的同意（即通过了Prepare阶段），并且没有被任何Acceptor拒绝（说明没有Acceptor响应过比该Proposer的提案编号更高的提案）。那么，什么情况下可以跳过Prepare请求呢，这里应该对应的是选出一个master的情况？相当于raft里的leader？</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>接下来直接看Prepare阶段：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: Prepare(<span class="keyword">const</span> <span class="keyword">bool</span> bNeedNewBallot)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Now.InstanceID %lu MyNodeID %lu State.ProposalID %lu State.ValueLen %zu"</span>,</span><br><span class="line">            GetInstanceID(), m_poConfig-&gt;GetMyNodeID(), m_oProposerState.GetProposalID(),</span><br><span class="line">            m_oProposerState.GetValue().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;Prepare();</span><br><span class="line">    m_oTimeStat.Point();</span><br><span class="line">    </span><br><span class="line">    ExitAccept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表明Proposer正处于Prepare阶段</span></span><br><span class="line">    m_bIsPreparing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能跳过Prepare阶段</span></span><br><span class="line">    m_bCanSkipPrepare = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前还未被任意一个Acceptor拒绝</span></span><br><span class="line">    m_bWasRejectBySomeone = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    m_oProposerState.ResetHighestOtherPreAcceptBallot();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要产生新的投票，就调用NewPrepare产生新的ProposalID，新的ProposalID为当前已知的最大ProposalID+1</span></span><br><span class="line">    <span class="keyword">if</span> (bNeedNewBallot)</span><br><span class="line">    &#123;</span><br><span class="line">        m_oProposerState.NewPrepare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PaxosMsg oPaxosMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Prepare消息的各个字段</span></span><br><span class="line">    oPaxosMsg.set_msgtype(MsgType_PaxosPrepare);</span><br><span class="line">    oPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oPaxosMsg.set_proposalid(m_oProposerState.GetProposalID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MsgCount是专门用来统计票数的，根据计算的结果确定是否通过Prepare阶段或者Accept阶段</span></span><br><span class="line">    m_oMsgCounter.StartNewRound();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare超时定时器</span></span><br><span class="line">    AddPrepareTimer();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END OK"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Prepare消息发送到各个节点</span></span><br><span class="line">    BroadcastMessage(oPaxosMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proposer在Prepare阶段主要做了这么几件事：</p><ol><li>重置各个状态位，表明当前正处于Prepare阶段。</li><li>获取提案编号ProposalID。当bNeedNewBallot为true时需要将ProposalID+1。否则沿用之前的ProposalID。bNeedNewBallot是在NewValue中调用Prepare方法时传入的m_bWasRejectBySomeone参数。也就是如果之前没有被任何Acceptor拒绝（说明还没有明确出现更大的ProposalID），则不需要获取新的ProposalID。对应的场景是Prepare阶段超时了，在超时时间内没有收到过半Acceptor同意的消息，因此需要重新执行Prepare阶段，此时只需要沿用原来的ProposalID即可。</li><li>发送Prepare请求。该请求PaxosMsg是Protocol Buffer定义的一个message，包含MsgType、InstanceID、NodeID、ProposalID等字段。在BroadcastMessage(oPaxosMsg)中还会将oPaxosMsg序列化后才发送出去。</li></ol><p>PaxosMsg的定义如下，Prepare和Accept阶段Proposer和Acceptor的所有消息都用PaxosMsg来表示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">message PaxosMsg</span><br><span class="line">&#123;</span><br><span class="line">required int32 MsgType = <span class="number">1</span>;</span><br><span class="line">optional uint64 InstanceID = <span class="number">2</span>;</span><br><span class="line">optional uint64 NodeID = <span class="number">3</span>;</span><br><span class="line">optional uint64 ProposalID = <span class="number">4</span>;</span><br><span class="line">optional uint64 ProposalNodeID = <span class="number">5</span>;</span><br><span class="line">optional bytes Value = <span class="number">6</span>;</span><br><span class="line">optional uint64 PreAcceptID = <span class="number">7</span>;</span><br><span class="line">optional uint64 PreAcceptNodeID = <span class="number">8</span>;</span><br><span class="line">optional uint64 RejectByPromiseID = <span class="number">9</span>;</span><br><span class="line">optional uint64 NowInstanceID = <span class="number">10</span>;</span><br><span class="line">optional uint64 MinChosenInstanceID = <span class="number">11</span>;</span><br><span class="line">optional uint32 LastChecksum = <span class="number">12</span>;</span><br><span class="line">optional uint32 Flag = <span class="number">13</span>;</span><br><span class="line">optional bytes SystemVariables = <span class="number">14</span>;</span><br><span class="line">optional bytes MasterVariables = <span class="number">15</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="OnPrepareReply"><a href="#OnPrepareReply" class="headerlink" title="OnPrepareReply"></a>OnPrepareReply</h3><p>Proposer发出Prepare请求后就开始等待Acceptor的回复。当Proposer所在节点收到PaxosPrepareReply消息后，就会调用Proposer的OnPrepareReply(oPaxosMsg)，其中oPaxosMsg是Acceptor回复的消息。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: OnPrepareReply(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.ProposalID %lu State.ProposalID %lu Msg.from_nodeid %lu RejectByPromiseID %lu"</span>,</span><br><span class="line">            oPaxosMsg.proposalid(), m_oProposerState.GetProposalID(), </span><br><span class="line">            oPaxosMsg.nodeid(), oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;OnPrepareReply();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果Proposer不是在Prepare阶段，则忽略该消息</span></span><br><span class="line">    <span class="keyword">if</span> (!m_bIsPreparing)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnPrepareReplyButNotPreparing();</span><br><span class="line">        <span class="comment">//PLGErr("Not preparing, skip this msg");</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ProposalID不同，也忽略</span></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.proposalid() != m_oProposerState.GetProposalID())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnPrepareReplyNotSameProposalIDMsg();</span><br><span class="line">        <span class="comment">//PLGErr("ProposalID not same, skip this msg");</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入一个收到的消息，用于MsgCounter统计</span></span><br><span class="line">    m_oMsgCounter.AddReceive(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该消息不是拒绝，即Acceptor同意本次Prepare请求</span></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.rejectbypromiseid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BallotNumber oBallot(oPaxosMsg.preacceptid(), oPaxosMsg.preacceptnodeid());</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] PreAcceptedID %lu PreAcceptedNodeID %lu ValueSize %zu"</span>, </span><br><span class="line">                oPaxosMsg.preacceptid(), oPaxosMsg.preacceptnodeid(), oPaxosMsg.value().size());</span><br><span class="line">        <span class="comment">//加入MsgCounter用于统计投票</span></span><br><span class="line">        m_oMsgCounter.AddPromiseOrAccept(oPaxosMsg.nodeid());</span><br><span class="line">        <span class="comment">//将Acceptor返回的它接受过的编号最大的提案记录下来（如果有的话），用于确定Accept阶段的Value</span></span><br><span class="line">        m_oProposerState.AddPreAcceptValue(oBallot, oPaxosMsg.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Acceptor拒绝了Prepare请求</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Reject] RejectByPromiseID %lu"</span>, oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样也要记录到MsgCounter用于统计投票</span></span><br><span class="line">        m_oMsgCounter.AddReject(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录被Acceptor拒绝过，待会儿如果重新进入Prepare阶段的话就需要获取更大的ProposalID</span></span><br><span class="line">        m_bWasRejectBySomeone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录下别的Proposer提出的更大的ProposalID。这样重新发起Prepare请求时才知道需要用多大的ProposalID</span></span><br><span class="line">        m_oProposerState.SetOtherProposalID(oPaxosMsg.rejectbypromiseid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//本次Prepare请求通过了。也就是得到了半数以上Acceptor的同意</span></span><br><span class="line">    <span class="keyword">if</span> (m_oMsgCounter.IsPassedOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iUseTimeMs = m_oTimeStat.Point();</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;PreparePass(iUseTimeMs);</span><br><span class="line">        PLGImp(<span class="string">"[Pass] start accept, usetime %dms"</span>, iUseTimeMs);</span><br><span class="line">        m_bCanSkipPrepare = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入Accept阶段</span></span><br><span class="line">        Accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本次Prepare请求没有通过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_oMsgCounter.IsRejectedOnThisRound()</span><br><span class="line">            || m_oMsgCounter.IsAllReceiveOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;PrepareNotPass();</span><br><span class="line">        PLGImp(<span class="string">"[Not Pass] wait 30ms and restart prepare"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//随机等待一段时间后重新发起Prepare请求</span></span><br><span class="line">        AddPrepareTimer(OtherUtils::FastRand() % <span class="number">30</span> + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该阶段Proposer主要做了以下事情：</p><ol><li><p>判断消息是否有效。包括ProposalID是否相同，自身是否处于Prepare阶段等。因为网络是不可靠的，有些消息可能延迟很久，等收到的时候已经不需要了，所以需要做这些判断。</p></li><li><p>将收到的消息加入MsgCounter用于统计。</p></li><li><p>根据收到的消息更新自身状态。包括Acceptor承诺过的ProposalID，以及Acceptor接受过的编号最大的提案等。</p></li><li><p>根据MsgCounter统计的Acceptor投票结果决定是进入Acceptor阶段还是重新发起Prepare请求。这里如果判断需要重新发起Prepare请求的话，也不是立即进行，而是等待一段随机的时间，这样做的好处是减少不同Proposer之间的冲突，采取的策略跟raft中leader选举冲突时在一段随机的选举超时时间后重新发起选举的做法类似。</p></li></ol><p>注：这里跟Paxos算法中提案编号对应的并不是ProposalID，而是BallotNumber。BallotNumber由ProposalID和NodeID组成。还实现了运算符重载。如果ProposalID大，则BallotNumber（即提案编号）大。在ProposalID相同的情况下，NodeID大的BallotNumber大。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>接下来Proposer就进入Accept阶段：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: Accept()</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START ProposalID %lu ValueSize %zu ValueLen %zu"</span>, </span><br><span class="line">            m_oProposerState.GetProposalID(), m_oProposerState.GetValue().size(), m_oProposerState.GetValue().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;Accept();</span><br><span class="line">    m_oTimeStat.Point();</span><br><span class="line">    </span><br><span class="line">    ExitPrepare();</span><br><span class="line">    m_bIsAccepting = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Accept请求的消息内容</span></span><br><span class="line">    PaxosMsg oPaxosMsg;</span><br><span class="line">    oPaxosMsg.set_msgtype(MsgType_PaxosAccept);</span><br><span class="line">    oPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oPaxosMsg.set_proposalid(m_oProposerState.GetProposalID());</span><br><span class="line">    oPaxosMsg.set_value(m_oProposerState.GetValue());</span><br><span class="line">    oPaxosMsg.set_lastchecksum(GetLastChecksum());</span><br><span class="line"></span><br><span class="line">    m_oMsgCounter.StartNewRound();</span><br><span class="line"></span><br><span class="line">    AddAcceptTimer();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发给各个节点</span></span><br><span class="line">    BroadcastMessage(oPaxosMsg, BroadcastMessage_Type_RunSelf_Final);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accept请求中PaxosMsg里的Value是这样确定的：如果Prepare阶段有Acceptor的回复中带有提案值，则该Value为所有的Acceptor的回复中，编号最大的提案的值。否则就是Proposer在最初调用NewValue时传入的值。</p><h3 id="OnAcceptReply"><a href="#OnAcceptReply" class="headerlink" title="OnAcceptReply"></a>OnAcceptReply</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: OnAcceptReply(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.ProposalID %lu State.ProposalID %lu Msg.from_nodeid %lu RejectByPromiseID %lu"</span>,</span><br><span class="line">            oPaxosMsg.proposalid(), m_oProposerState.GetProposalID(), </span><br><span class="line">            oPaxosMsg.nodeid(), oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;OnAcceptReply();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_bIsAccepting)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLGErr("Not proposing, skip this msg");</span></span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnAcceptReplyButNotAccepting();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.proposalid() != m_oProposerState.GetProposalID())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLGErr("ProposalID not same, skip this msg");</span></span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnAcceptReplyNotSameProposalIDMsg();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_oMsgCounter.AddReceive(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.rejectbypromiseid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Accept]"</span>);</span><br><span class="line">        m_oMsgCounter.AddPromiseOrAccept(oPaxosMsg.nodeid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Reject]"</span>);</span><br><span class="line">        m_oMsgCounter.AddReject(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">        m_bWasRejectBySomeone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        m_oProposerState.SetOtherProposalID(oPaxosMsg.rejectbypromiseid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_oMsgCounter.IsPassedOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iUseTimeMs = m_oTimeStat.Point();</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;AcceptPass(iUseTimeMs);</span><br><span class="line">        PLGImp(<span class="string">"[Pass] Start send learn, usetime %dms"</span>, iUseTimeMs);</span><br><span class="line">        ExitAccept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让Leaner学习被选定（Chosen）的值</span></span><br><span class="line">        m_poLearner-&gt;ProposerSendSuccess(GetInstanceID(), m_oProposerState.GetProposalID());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_oMsgCounter.IsRejectedOnThisRound()</span><br><span class="line">            || m_oMsgCounter.IsAllReceiveOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;AcceptNotPass();</span><br><span class="line">        PLGImp(<span class="string">"[Not pass] wait 30ms and Restart prepare"</span>);</span><br><span class="line">        AddAcceptTimer(OtherUtils::FastRand() % <span class="number">30</span> + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里跟OnPrepareReply的过程基本一致，因此就不加太多注释了。比较大的区别在于最后如果过半的Acceptor接受了该Accept请求，则说明该Value被选定（Chosen）了，就发送消息，让每个节点上的Learner学习该Value。因为Leaner不是本文的重点，这里就不详细介绍了。</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>Acceptor的逻辑比Proposer更简单。同样先看它的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Acceptor : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Acceptor(</span><br><span class="line">            <span class="keyword">const</span> Config * poConfig, </span><br><span class="line">            <span class="keyword">const</span> MsgTransport * poMsgTransport, </span><br><span class="line">            <span class="keyword">const</span> Instance * poInstance,</span><br><span class="line">            <span class="keyword">const</span> LogStorage * poLogStorage);</span><br><span class="line">    ~Acceptor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitForNewPaxosInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AcceptorState * <span class="title">GetAcceptorState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段回复Prepare请求</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OnPrepare</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段回复Accept请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAccept</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">    AcceptorState m_oAcceptorState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="OnPrepare"><a href="#OnPrepare" class="headerlink" title="OnPrepare"></a>OnPrepare</h3><p>OnPrepare用于处理收到的Prepare请求，逻辑如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Acceptor :: OnPrepare(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.InstanceID %lu Msg.from_nodeid %lu Msg.ProposalID %lu"</span>,</span><br><span class="line">            oPaxosMsg.instanceid(), oPaxosMsg.nodeid(), oPaxosMsg.proposalid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetAcceptorBP()-&gt;OnPrepare();</span><br><span class="line">    </span><br><span class="line">    PaxosMsg oReplyPaxosMsg;</span><br><span class="line">    oReplyPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oReplyPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oReplyPaxosMsg.set_proposalid(oPaxosMsg.proposalid());</span><br><span class="line">    oReplyPaxosMsg.set_msgtype(MsgType_PaxosPrepareReply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造接收到的Prepare请求里的提案编号</span></span><br><span class="line">    BallotNumber oBallot(oPaxosMsg.proposalid(), oPaxosMsg.nodeid());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提案编号大于承诺过的提案编号</span></span><br><span class="line">    <span class="keyword">if</span> (oBallot &gt;= m_oAcceptorState.GetPromiseBallot())</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] State.PromiseID %lu State.PromiseNodeID %lu "</span></span><br><span class="line">                <span class="string">"State.PreAcceptedID %lu State.PreAcceptedNodeID %lu"</span>,</span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llProposalID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//返回之前接受过的提案的编号</span></span><br><span class="line">oReplyPaxosMsg.set_preacceptid(m_oAcceptorState.GetAcceptedBallot().m_llProposalID);</span><br><span class="line">        oReplyPaxosMsg.set_preacceptnodeid(m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line">        <span class="comment">//如果接受过的提案编号大于0（&lt;=0说明没有接受过提案），则设置接受过的提案的Value</span></span><br><span class="line">        <span class="keyword">if</span> (m_oAcceptorState.GetAcceptedBallot().m_llProposalID &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            oReplyPaxosMsg.set_value(m_oAcceptorState.GetAcceptedValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新承诺的提案编号为新的提案编号（因为新的提案编号更大）</span></span><br><span class="line">        m_oAcceptorState.SetPromiseBallot(oBallot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信息持久化</span></span><br><span class="line">        <span class="keyword">int</span> ret = m_oAcceptorState.Persist(GetInstanceID(), GetLastChecksum());</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BP-&gt;GetAcceptorBP()-&gt;OnPreparePersistFail();</span><br><span class="line">            PLGErr(<span class="string">"Persist fail, Now.InstanceID %lu ret %d"</span>,</span><br><span class="line">                    GetInstanceID(), ret);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnPreparePass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提案编号小于承诺过的提案编号，需要拒绝</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnPrepareReject();</span><br><span class="line"></span><br><span class="line">        PLGDebug(<span class="string">"[Reject] State.PromiseID %lu State.PromiseNodeID %lu"</span>, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//拒绝该Prepare请求，并返回承诺过的ProposalID      </span></span><br><span class="line">oReplyPaxosMsg.set_rejectbypromiseid(m_oAcceptorState.GetPromiseBallot().m_llProposalID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nodeid_t</span> iReplyNodeID = oPaxosMsg.nodeid();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END Now.InstanceID %lu ReplyNodeID %lu"</span>,</span><br><span class="line">            GetInstanceID(), oPaxosMsg.nodeid());;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向发出Prepare请求的Proposer回复消息</span></span><br><span class="line">    SendMessage(iReplyNodeID, oReplyPaxosMsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnAccept"><a href="#OnAccept" class="headerlink" title="OnAccept"></a>OnAccept</h3><p>再来看看OnAccept：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Acceptor :: OnAccept(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.InstanceID %lu Msg.from_nodeid %lu Msg.ProposalID %lu Msg.ValueLen %zu"</span>,</span><br><span class="line">            oPaxosMsg.instanceid(), oPaxosMsg.nodeid(), oPaxosMsg.proposalid(), oPaxosMsg.value().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetAcceptorBP()-&gt;OnAccept();</span><br><span class="line"></span><br><span class="line">    PaxosMsg oReplyPaxosMsg;</span><br><span class="line">    oReplyPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oReplyPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oReplyPaxosMsg.set_proposalid(oPaxosMsg.proposalid());</span><br><span class="line">    oReplyPaxosMsg.set_msgtype(MsgType_PaxosAcceptReply);</span><br><span class="line"></span><br><span class="line">    BallotNumber oBallot(oPaxosMsg.proposalid(), oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提案编号不小于承诺过的提案编号（注意：这里是“&gt;=”，而再OnPrepare中是“&gt;”，可以先思考下为什么），需要接受该提案</span></span><br><span class="line">    <span class="keyword">if</span> (oBallot &gt;= m_oAcceptorState.GetPromiseBallot())</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] State.PromiseID %lu State.PromiseNodeID %lu "</span></span><br><span class="line">                <span class="string">"State.PreAcceptedID %lu State.PreAcceptedNodeID %lu"</span>,</span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llProposalID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新承诺的提案编号；接受的提案编号、提案值</span></span><br><span class="line">        m_oAcceptorState.SetPromiseBallot(oBallot);</span><br><span class="line">        m_oAcceptorState.SetAcceptedBallot(oBallot);</span><br><span class="line">        m_oAcceptorState.SetAcceptedValue(oPaxosMsg.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//信息持久化</span></span><br><span class="line">        <span class="keyword">int</span> ret = m_oAcceptorState.Persist(GetInstanceID(), GetLastChecksum());</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BP-&gt;GetAcceptorBP()-&gt;OnAcceptPersistFail();</span><br><span class="line"></span><br><span class="line">            PLGErr(<span class="string">"Persist fail, Now.InstanceID %lu ret %d"</span>,</span><br><span class="line">                    GetInstanceID(), ret);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnAcceptPass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要拒绝该提案</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnAcceptReject();</span><br><span class="line"></span><br><span class="line">        PLGDebug(<span class="string">"[Reject] State.PromiseID %lu State.PromiseNodeID %lu"</span>, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拒绝的消息中附上承诺过的ProposalID</span></span><br><span class="line">        oReplyPaxosMsg.set_rejectbypromiseid(m_oAcceptorState.GetPromiseBallot().m_llProposalID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nodeid_t</span> iReplyNodeID = oPaxosMsg.nodeid();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END Now.InstanceID %lu ReplyNodeID %lu"</span>,</span><br><span class="line">            GetInstanceID(), oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将响应发送给Proposer</span></span><br><span class="line">    SendMessage(iReplyNodeID, oReplyPaxosMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过阅读源码可以发现，整个PhxPaxos完全基于Lamport的《Paxos Made Simple》进行工程化，没有进行任何算法变种。这对于学习Paxos算法的人来说真的是一笔宝贵的财富，所以如果对Paxos算法感兴趣，应该深入地去阅读PhxPaxos的源码，相信看完后大家对Paxos会有更深的理解。同时我们也发现，在工程实现上还是有很多细节需要注意，这比单纯理解算法要难得多。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇主要来分析Paxos算法实现的部分，我想这应该也是读者最感兴趣的。在看这篇文章之前，如果之前对Paxos算法没有了解的童鞋可以看下这篇文章：&lt;a href=&quot;http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/&quot;&gt;Paxos算法原理与推导&lt;/a&gt;，相信了解Paxos算法后再来通过源码看算法实现应该会很酸爽。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://linbingdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="PhxPaxos" scheme="http://linbingdong.com/tags/PhxPaxos/"/>
    
  </entry>
  
  <entry>
    <title>PhxPaxos源码分析——网络</title>
    <link href="http://linbingdong.com/2017/11/20/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <id>http://linbingdong.com/2017/11/20/PhxPaxos源码分析——网络/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2017-11-20T10:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>了解分布式系统的童鞋肯定听过Paxos算法的大名。Paxos算法以晦涩难懂著称，其工程实现更难。目前，号称在工程上实现了Paxos算法的应该只有Google、阿里和腾讯。然而，只有腾讯的微信团队真正将代码开源出来，他们将Paxos算法的实现封装成了一个Paxos库，大家可以基于该库实现自己想要的功能，比如用于master选举，或者甚至利用它来实现一个分布式KV数据库等。</p><a id="more"></a><p>之前就对Paxos很感兴趣，但是一直没看过实现的代码，这次微信开源了PhxPaxos后终于有机会深入地了解Paxos的实现细节。在这里感谢微信团队。感谢PhxPaxos的作者。让我们一起来领略Paxos的魅力吧。</p><p>本次的源码分析先从网络部分开始。因为在分布式系统中不可避免会涉及到不同节点以及相同节点上不同进程之间的通信。因此网络部分也是至关重要，所以就先把网络单独拿出来看，接下来再去看Paxos算法的实现部分。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>源码的include/phxpaxos目录下是公共头文件。include/phpaxos/network.h 是网络模块的抽象函数，如果用户想使用自己的网络协议，可以通过重写这些函数实现网络模块的自定义。</p><p>我们先来看下network.h的内容：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> phxpaxos</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//You can use your own network to make paxos communicate. :)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> NetWork</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetWork();</span><br><span class="line">    <span class="keyword">virtual</span> ~NetWork() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Network must not send/recieve any message before paxoslib called this funtion.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RunNetWork</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If paxoslib call this function, network need to stop receive any message.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StopNetWork</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SendMessageTCP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SendMessageUDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//When receive a message, call this funtion.</span></span><br><span class="line">    <span class="comment">//This funtion is async, just enqueue an return.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OnReceiveMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pcMessage, <span class="keyword">const</span> <span class="keyword">int</span> iMessageLen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Node;</span><br><span class="line">    Node * m_poNode;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数的作用从名字就可以看出来。而且都是虚函数，即需要重写这些函数。在PhxPaxos中，提供了一个默认的网络模块，就是继承了NetWork类。该类的名字叫DFNetWork，DF应该就是default的缩写了。如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> phxpaxos </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DFNetWork : <span class="keyword">public</span> NetWork</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DFNetWork();</span><br><span class="line">    <span class="keyword">virtual</span> ~DFNetWork();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RunNetWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopNetWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendMessageTCP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendMessageUDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UDPRecv m_oUDPRecv;</span><br><span class="line">    UDPSend m_oUDPSend;</span><br><span class="line">    TcpIOThread m_oTcpIOThread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的私有成员里有UDPRecv、UDPSend和TcpIOThread三个类的对象，这三个类分别用于接收UDP消息、发送UDP消息以及收发TCP消息。</p><p>Init方法就是将UDPRecv、UDPSend和TcpIOThread分别初始化:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: Init(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount) </span><br><span class="line">&#123;  <span class="comment">//初始化UDPSend</span></span><br><span class="line">    <span class="keyword">int</span> ret = m_oUDPSend.Init();</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化UDPRecv</span></span><br><span class="line">    ret = m_oUDPRecv.Init(iListenPort);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化TCP</span></span><br><span class="line">    ret = m_oTcpIOThread.Init(sListenIp, iListenPort, iIOThreadCount);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"m_oTcpIOThread Init fail, ret %d"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的初始化过程就是调用socket的api。以UDPRecv为例，就是创建socket、设定端口、设置socket属性（如端口可重用）最后绑定端口。如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> UDPRecv :: Init(<span class="keyword">const</span> <span class="keyword">int</span> iPort)</span><br><span class="line">&#123;  <span class="comment">//创建socket，获得socket fd</span></span><br><span class="line">    <span class="keyword">if</span> ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(iPort);  <span class="comment">//设定端口</span></span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设定socket属性，端口可重用</span></span><br><span class="line">    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//绑定，用于监听</span></span><br><span class="line">    <span class="keyword">if</span> (bind(m_iSockFD, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunNetWork就是将UDPRecv、UDPSend和TcpIOThread分别运行起来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> DFNetWork :: RunNetWork()</span><br><span class="line">&#123;  <span class="comment">//UDPSend和UDPRecv都是调用Thread的start方法</span></span><br><span class="line">    m_oUDPSend.start();</span><br><span class="line">    m_oUDPRecv.start();</span><br><span class="line">    <span class="comment">//TCP的Start是封装过的</span></span><br><span class="line">    m_oTcpIOThread.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TcpIOThread的Start()实际执行的代码如下，分别启动了TcpAcceptor、TcpWrite和TcpRead：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpIOThread :: Start()</span><br><span class="line">&#123;</span><br><span class="line">    m_oTcpAcceptor.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poTcpWrite : m_vecTcpWrite)</span><br><span class="line">    &#123;</span><br><span class="line">        poTcpWrite-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poTcpRead : m_vecTcpRead)</span><br><span class="line">    &#123;</span><br><span class="line">        poTcpRead-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StopNetWork就是将UDPRecv、UDPSend和TcpIOThread停止。</p><p>SendMessageTCP就是将消息用TCP发送：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: SendMessageTCP(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oTcpIOThread.AddMessage(iGroupIdx, sIp, iPort, sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SendMessageUDP就是将消息用UDP发送：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: SendMessageUDP(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oUDPSend.AddMessage(sIp, iPort, sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDPSend"><a href="#UDPSend" class="headerlink" title="UDPSend"></a>UDPSend</h3><p>前面SendMessageUDP调用了m_oUDPSend.AddMessage。这里的UDPSend维护了一个发送队列，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Queue&lt;QueueData *&gt; m_oSendQueue;</span><br></pre></td></tr></table></figure><p>m_oUDPSend.AddMessage就是将消息加入到UDP的m_oSendQueue中。</p><p>然后UDPSend在run方法中一直循环将m_oSendQueue中的消息发送出去：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UDPSend :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QueueData * poData = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//同步，线程安全</span></span><br><span class="line">        m_oSendQueue.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> bSucc = m_oSendQueue.peek(poData, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (bSucc)</span><br><span class="line">        &#123;   <span class="comment">//取出队头消息</span></span><br><span class="line">            m_oSendQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_oSendQueue.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poData != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   <span class="comment">//将消息发送出去</span></span><br><span class="line">            SendMessage(poData-&gt;m_sIP, poData-&gt;m_iPort, poData-&gt;m_sMessage);</span><br><span class="line">            <span class="keyword">delete</span> poData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"UDPSend [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此UDPSend就是把消息加入到消息队列，然后循环将消息队列里的消息发送出去。</p><h3 id="UDPRecv"><a href="#UDPRecv" class="headerlink" title="UDPRecv"></a>UDPRecv</h3><p>接下来看看UDPRecv。UDPRecv的初始化前面已经看过了，就是简单的获得socket fd，设定sockaddr_in，设置socket属性最后将socket fd和sockaddr_in绑定用于监听。</p><p>主要来看看UDPRecv的run方法。这里主要用了I/O多路复用中的poll，注册了一个pollfd，该pollfd的fd即之前创建的绑定了端口的socket fd，events为POLLIN，表示监听数据可读事件，如果有数据可读了，则调用recvfrom读入数据。最后调用OnReceiveMessage将消息添加到当前instance的IoLoop中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UDPRecv :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sBuffer[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"UDPRecv [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> pollfd fd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        fd.fd = m_iSockFD;</span><br><span class="line">        <span class="comment">//注册POLLIN事件</span></span><br><span class="line">        fd.events = POLLIN;</span><br><span class="line">        <span class="comment">//调用poll检查是否有数据可读</span></span><br><span class="line">        ret = poll(&amp;fd, <span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span> || ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将接收到的数据放入sBuffer中</span></span><br><span class="line">        <span class="keyword">int</span> iRecvLen = recvfrom(m_iSockFD, sBuffer, <span class="keyword">sizeof</span>(sBuffer), <span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;UDPReceive(iRecvLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iRecvLen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;   <span class="comment">//这里会依次调用Node和Instance的OnReceiveMessage方法，最后将消息加入到Instance的IoLoop中</span></span><br><span class="line">            m_poDFNetWork-&gt;OnReceiveMessage(sBuffer, iRecvLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TcpIOThread"><a href="#TcpIOThread" class="headerlink" title="TcpIOThread"></a>TcpIOThread</h3><p>接下来看看收发TCP消息的TcpIOThread：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpIOThread </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpIOThread(NetWork * poNetWork);</span><br><span class="line">    ~TcpIOThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于初始化TcpAcceptor以及iIOThreadCount个m_vecTcpRead和m_vecTcpWrite</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动TcpAcceptor用于监听以及所有的m_vecTcpRead和m_vecTcpWrite用于读写消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止TcpAcceptor和所有的m_vecTcpRead及m_vecTcpWrite</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息加入到特定TcpWrite的消息队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AddMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NetWork * m_poNetWork;</span><br><span class="line">    TcpAcceptor m_oTcpAcceptor;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TcpRead *&gt; m_vecTcpRead;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TcpWrite *&gt; m_vecTcpWrite;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsStarted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TcpRead类似于前面讲的UDPRecv，TcpWrite类似于于UDPSend。严格来讲，TcpAcceptor + TcpRead才是UDPRecv。这里把TcpAcceptor单独抽出来，专门用于监听连接请求并建立连接。TcpRead只需要负责读消息就行。</p><h3 id="TcpAcceptor"><a href="#TcpAcceptor" class="headerlink" title="TcpAcceptor"></a>TcpAcceptor</h3><p>我们来看看TcpAcceptor：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpAcceptor : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpAcceptor();</span><br><span class="line">    ~TcpAcceptor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Listen</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIP, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一直while循环，监听连接事件并建立连接获得fd，然后添加事件到EventLoop中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEventLoop</span><span class="params">(EventLoop * poEventLoop)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEvent</span><span class="params">(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//服务端的socket，用于监听</span></span><br><span class="line">    ServerSocket m_oSocket;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop *&gt; m_vecEventLoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_bIsEnd;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsStarted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里主要来看下run方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpAcceptor :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    PLHead(<span class="string">"start accept..."</span>);</span><br><span class="line"></span><br><span class="line">    m_oSocket.setAcceptTimeout(<span class="number">500</span>);</span><br><span class="line">    m_oSocket.setNonBlocking(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> pollfd pfd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        pfd.fd =  m_oSocket.getSocketHandle();</span><br><span class="line">        <span class="comment">//注册事件</span></span><br><span class="line">        pfd.events = POLLIN;</span><br><span class="line">        <span class="comment">//等待事件到来</span></span><br><span class="line">        ret = poll(&amp;pfd, <span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; ret != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SocketAddress oAddr;</span><br><span class="line">            <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//建立连接，获得fd。这里的acceptfd对accept进行了简单的封装</span></span><br><span class="line">                fd = m_oSocket.acceptfd(&amp;oAddr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                fd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                BP-&gt;GetNetworkBP()-&gt;TcpAcceptFd();</span><br><span class="line"></span><br><span class="line">                PLImp(<span class="string">"accepted!, fd %d ip %s port %d"</span>,</span><br><span class="line">                        fd, oAddr.getHost().c_str(), oAddr.getPort());</span><br><span class="line">                <span class="comment">//添加事件</span></span><br><span class="line">                AddEvent(fd, oAddr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"TCP.Acceptor [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看AddEvent方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpAcceptor :: AddEvent(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span><br><span class="line">&#123;</span><br><span class="line">    EventLoop * poMinActiveEventLoop = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> iMinActiveEventCount = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poEventLoop : m_vecEventLoop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iActiveCount = poEventLoop-&gt;GetActiveEventCount();</span><br><span class="line">        <span class="keyword">if</span> (iActiveCount &lt; iMinActiveEventCount)</span><br><span class="line">        &#123;</span><br><span class="line">            iMinActiveEventCount = iActiveCount;</span><br><span class="line">            poMinActiveEventLoop = poEventLoop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">oAddr.getPort());</span><br><span class="line">    poMinActiveEventLoop-&gt;AddEvent(iFD, oAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即找到活跃数最少的EventLoop，将事件添加到该EventLoop中。这里应该是为了负载均衡，防止有些线程工作量很大，有些则很空闲。</p><p>具体EventLoop的AddEvent就是将事件加入到FDQueue中，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: AddEvent(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; oLockGuard(m_oMutex);</span><br><span class="line">    m_oFDQueue.push(make_pair(iFD, oAddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里TcpAcceptor的作用及实现基本就很清晰了。</p><h3 id="TcpRead"><a href="#TcpRead" class="headerlink" title="TcpRead"></a>TcpRead</h3><p>先来看看TcpRead类的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpRead : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpRead(NetWork * poNetWork);</span><br><span class="line">    ~TcpRead();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EventLoop * <span class="title">GetEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop m_oEventLoop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的成员变量是一个EventLoop对象。通过源码发现，Init、run、Stop方法其实都是调用了m_oEventLoop相应的方法，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> TcpRead :: Init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oEventLoop.Init(<span class="number">20480</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpRead :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_oEventLoop.StartLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpRead :: Stop()</span><br><span class="line">&#123;</span><br><span class="line">    m_oEventLoop.Stop();</span><br><span class="line">    join();</span><br><span class="line"></span><br><span class="line">    PLHead(<span class="string">"TcpReadThread [END]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此主要来看下EventLoop。</p><p>首先说下Event。PhxPaxos在TCP这块主要用了I/O多路复用中的epoll。这里主要将数据和通知等都封装成Event，然后由TcpWrite和TcpRead的EventLoop去执行。PhxPaxos中的Event包含两个子类，分别是MessageEvent和Notify。其中MessageEvent主要用于数据的读写；而Notify主要用于通知事件发生。这里的Notify基于管道pipe和EPOLLIN事件来实现，可以通过Notify的Init方法看出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Notify :: Init()</span><br><span class="line">&#123;   <span class="comment">//m_iPipeFD是一个长度为2的int数组，用于存放管道两端的socket fd</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(m_iPipeFD);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"create pipe fail, ret %d"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(m_iPipeFD[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">    fcntl(m_iPipeFD[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    AddEvent(EPOLLIN);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到EventLoop。首先看下EventLoop的Init方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> EventLoop :: Init(<span class="keyword">const</span> <span class="keyword">int</span> iEpollLength)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//创建epoll句柄，iEpollLength为监听的fd数</span></span><br><span class="line">    m_iEpollFd = epoll_create(iEpollLength);</span><br><span class="line">    <span class="keyword">if</span> (m_iEpollFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"epoll_create fail, ret %d"</span>, m_iEpollFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_poNotify = <span class="keyword">new</span> Notify(<span class="keyword">this</span>);</span><br><span class="line">    assert(m_poNotify != <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化Notify：创建pipe，设置m_iPipeFD并添加EPOLLIN事件</span></span><br><span class="line">    <span class="keyword">int</span> ret = m_poNotify-&gt;Init();</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来看下最重要的StartLoop：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: StartLoop()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;TcpEpollLoop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iNextTimeout = <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        DealwithTimeout(iNextTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PLHead("nexttimeout %d", iNextTimeout);</span></span><br><span class="line"></span><br><span class="line">        OneLoop(iNextTimeout);</span><br><span class="line"></span><br><span class="line">        CreateEvent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_poTcpClient != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_poTcpClient-&gt;DealWithWrite();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"TCP.EventLoop [END]"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主循环是OneLoop：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: OneLoop(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs)</span><br><span class="line">&#123;  <span class="comment">//调用epoll_wait等待事件发生</span></span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(m_iEpollFd, m_EpollEvents, MAX_EVENTS, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            PLErr(<span class="string">"epoll_wait fail, errno %d"</span>, errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐一处理发生的epoll事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iFd = m_EpollEvents[i].data.fd;</span><br><span class="line">        <span class="keyword">auto</span> it = m_mapEvent.find(iFd);</span><br><span class="line">        <span class="keyword">if</span> (it == end(m_mapEvent))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iEvents = m_EpollEvents[i].events;</span><br><span class="line">        Event * poEvent = it-&gt;second.m_poEvent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iEvents &amp; EPOLLERR)</span><br><span class="line">        &#123;</span><br><span class="line">            OnError(iEvents, poEvent);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是EPOLLIN事件，表明由数据可读，则调用poEvent的OnRead方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (iEvents &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = poEvent-&gt;OnRead();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是EPOLLOUT事件，表明由数据可写，则调用poEvent的OnWrite方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (iEvents &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = poEvent-&gt;OnWrite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OnError(iEvents, poEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他具体的细节这里就不再赘述了，有兴趣的可以自己去看看源码。</p><h3 id="TcpWrite"><a href="#TcpWrite" class="headerlink" title="TcpWrite"></a>TcpWrite</h3><p>看完了TcpRead，再来看看TcpWrite。首先还是看它的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpWrite : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpWrite(NetWork * poNetWork);</span><br><span class="line">    ~TcpWrite();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AddMessage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TcpClient m_oTcpClient;</span><br><span class="line">    EventLoop m_oEventLoop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Init、run、Stop跟TcpRead中对应方法的作用一致。AddMessage则是调用了m_oTcpClient的AddMessage方法。发现TcpWrite的成员变量比TcpRead多了一个TcpClient对象，因此主要来看看这个TcpClient是干嘛的。</p><p>刚刚说TcpWrite的AddMessage调用了m_oTcpClient的AddMessage方法。在m_oTcpClient的AddMessage方法中，则是先创建了一个指向MessageEvent对象的指针poEvent，然后再调用poEvent的AddMessage方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> TcpClient :: AddMessage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//PLImp("ok");</span></span><br><span class="line">    MessageEvent * poEvent = GetEvent(sIP, iPort);</span><br><span class="line">    <span class="keyword">if</span> (poEvent == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"no event created for this ip %s port %d"</span>, sIP.c_str(), iPort);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> poEvent-&gt;AddMessage(sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此继续看看MessageEvent的AddMessage方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: AddMessage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    m_llLastActiveTime = Time::GetSteadyClockMS();</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; oLock(m_oMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_oInQueue.size() &gt; TCP_QUEUE_MAXLEN)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;TcpQueueFull();</span><br><span class="line">        <span class="comment">//PLErr("queue length %d too long, can't enqueue", m_oInQueue.size());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_iQueueMemSize &gt; MAX_QUEUE_MEM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLErr("queue memsize %d too large, can't enqueue", m_iQueueMemSize);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueueData tData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息封装成QueueData后放入队列</span></span><br><span class="line">    tData.llEnqueueAbsTime = Time::GetSteadyClockMS();</span><br><span class="line">    tData.psValue = <span class="keyword">new</span> <span class="built_in">string</span>(sMessage);</span><br><span class="line">    m_oInQueue.push(tData);</span><br><span class="line"></span><br><span class="line">    m_iQueueMemSize += sMessage.size();</span><br><span class="line"></span><br><span class="line">    oLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出EpollWait，实际是调用SendNotify发送了一个通知</span></span><br><span class="line">    JumpoutEpollWait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里将消息加上入队时间后封装成一个QueueDate，然后放入m_oInQueue队列中。最后调用EventLoop的SendNotify发送了一个通知（利用之前创建的pipe）退出EpollWait。</p><p>说完了消息怎么入队，那消息是怎么发送出去的呢？</p><p>这里主要涉及到MessageEvent的OnWrite函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: OnWrite()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要发送队列不为空或者还有上次未发送完的数据，就调用DoOnWrite执行真正的发送操作</span></span><br><span class="line">    <span class="keyword">while</span> (!m_oInQueue.empty() || m_iLeftWriteLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = DoOnWrite();</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; ret != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//need break, wait next write</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteDone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DoOnWrite:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: DoOnWrite()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//上一次的消息还未发送完毕，将剩下的发送完</span></span><br><span class="line">    <span class="keyword">if</span> (m_iLeftWriteLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> WriteLeft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_oMutex.lock();</span><br><span class="line">    <span class="keyword">if</span> (m_oInQueue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        m_oMutex.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中取出一条新消息，准备发送</span></span><br><span class="line">    QueueData tData = m_oInQueue.front();</span><br><span class="line">    m_oInQueue.pop();</span><br><span class="line">    m_iQueueMemSize -= tData.psValue-&gt;size();</span><br><span class="line">    m_oMutex.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> * poMessage = tData.psValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该消息入队太久没有被处理，则抛弃，不发送</span></span><br><span class="line">    <span class="keyword">uint64_t</span> llNowTime = Time::GetSteadyClockMS();</span><br><span class="line">    <span class="keyword">int</span> iDelayMs = llNowTime &gt; tData.llEnqueueAbsTime ? (<span class="keyword">int</span>)(llNowTime - tData.llEnqueueAbsTime) : <span class="number">0</span>;</span><br><span class="line">    BP-&gt;GetNetworkBP()-&gt;TcpOutQueue(iDelayMs);</span><br><span class="line">    <span class="keyword">if</span> (iDelayMs &gt; TCP_OUTQUEUE_DROP_TIMEMS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLErr("drop request because enqueue timeout, nowtime %lu unqueuetime %lu",</span></span><br><span class="line">                <span class="comment">//llNowTime, tData.llEnqueueAbsTime);</span></span><br><span class="line">        <span class="keyword">delete</span> poMessage;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算发送缓冲区长度，需要加上4字节用于表示消息长度</span></span><br><span class="line">    <span class="keyword">int</span> iBuffLen = poMessage-&gt;size();</span><br><span class="line">    <span class="keyword">int</span> niBuffLen = htonl(iBuffLen + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iLen = iBuffLen + <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//申请缓冲区</span></span><br><span class="line">    m_oWriteCacheBuffer.Ready(iLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息长度及消息内容拷贝到缓冲区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(m_oWriteCacheBuffer.GetPtr(), &amp;niBuffLen, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(m_oWriteCacheBuffer.GetPtr() + <span class="number">4</span>, poMessage-&gt;c_str(), iBuffLen);</span><br><span class="line"></span><br><span class="line">    m_iLeftWriteLen = iLen;</span><br><span class="line">    m_iLastWritePos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> poMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PLImp("write len %d ip %s port %d", iLen, m_oAddr.getHost().c_str(), m_oAddr.getPort());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始发送消息，有可能消息太大一次发送不完</span></span><br><span class="line">    <span class="keyword">int</span> iWriteLen = m_oSocket.send(m_oWriteCacheBuffer.GetPtr(), iLen);</span><br><span class="line">    <span class="keyword">if</span> (iWriteLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"fail, write len %d ip %s port %d"</span>,</span><br><span class="line">                iWriteLen, m_oAddr.getHost().c_str(), m_oAddr.getPort());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要下次再发送</span></span><br><span class="line">    <span class="keyword">if</span> (iWriteLen == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//need wait next write</span></span><br><span class="line">        AddEvent(EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PLImp("real write len %d", iWriteLen);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送成功</span></span><br><span class="line">    <span class="keyword">if</span> (iWriteLen == iLen)</span><br><span class="line">    &#123;</span><br><span class="line">        m_iLeftWriteLen = <span class="number">0</span>;</span><br><span class="line">        m_iLastWritePos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//write done</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有一次性全部发送完，剩下的需要下次发送</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iWriteLen &lt; iLen)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//m_iLastWritePos和m_iLeftWriteLen分别用来表示上次写的位置以及剩下需要发送的长度</span></span><br><span class="line">        m_iLastWritePos = iWriteLen;</span><br><span class="line">        m_iLeftWriteLen = iLen - iWriteLen;</span><br><span class="line"></span><br><span class="line">        PLImp(<span class="string">"write buflen %d smaller than expectlen %d"</span>, iWriteLen, iLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"write buflen %d large than expectlen %d"</span>, iWriteLen, iLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>先介绍这么多吧，接下去会有更多相关的文章，特别是PhxPaxos中实现Paxos算法的那部分，相信看过Paxos相关论文的童鞋会对这块很感兴趣。</p><p>最后，附上PhxPaxos源码的地址：<a href="https://github.com/Tencent/phxpaxos" target="_blank" rel="noopener">https://github.com/Tencent/phxpaxos</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解分布式系统的童鞋肯定听过Paxos算法的大名。Paxos算法以晦涩难懂著称，其工程实现更难。目前，号称在工程上实现了Paxos算法的应该只有Google、阿里和腾讯。然而，只有腾讯的微信团队真正将代码开源出来，他们将Paxos算法的实现封装成了一个Paxos库，大家可以基于该库实现自己想要的功能，比如用于master选举，或者甚至利用它来实现一个分布式KV数据库等。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://linbingdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="PhxPaxos" scheme="http://linbingdong.com/tags/PhxPaxos/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://linbingdong.com/2017/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://linbingdong.com/2017/11/11/设计模式-适配器模式/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2017-11-11T03:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍适配器模式。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>适配器模式</strong>将一个类的接口，转换成客户端期待的另一个接口。</p><p>比如我们想用苹果的充电线给安卓充电。但是安卓的充电接口（type-c）跟苹果（lightning）的不一样，所以就需要一个适配器，将安卓的type-c接口转换成苹果的lightning接口，这样就能用苹果的充电线给安卓充电了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-44cc41182016b5e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Adapter.jpg"></p><p>图中玫瑰金色的就是适配器。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><strong>目标（Target）</strong>：即期望的接口。</li><li><strong>适配器（Adapter）</strong>：用于将源接口转换成目标接口。</li><li><strong>被适配者（Adaptee）</strong>：即源接口。</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1752522-ebc5c6a53ad679d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="适配器模式类图.png"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppleLightning appleLighting = <span class="keyword">new</span> AppleLightning();</span><br><span class="line">        System.out.println(<span class="string">"use lightning to charge"</span>);</span><br><span class="line">        appleLighting.chargeWithLightning();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">'\n'</span> + <span class="string">"use type-c to charge"</span>);</span><br><span class="line">        AndroidTypeC androidTypeC = <span class="keyword">new</span> AndroidTypeC();</span><br><span class="line">        androidTypeC.chargeWithTypeC();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">'\n'</span> + <span class="string">"use lightning to charge"</span>);</span><br><span class="line">        Lightning adapter = <span class="keyword">new</span> Adapter(androidTypeC);</span><br><span class="line">        adapter.chargeWithLightning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleLightning</span> <span class="keyword">implements</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"charging iPhone..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidTypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithTypeC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"charging android..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AndroidTypeC androidTypeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(AndroidTypeC androidTypeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.androidTypeC = androidTypeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        androidTypeC.chargeWithTypeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use lightning to charge</span><br><span class="line">charging iPhone...</span><br><span class="line"></span><br><span class="line">use type-c to charge</span><br><span class="line">charging android...</span><br><span class="line"></span><br><span class="line">use lightning to charge</span><br><span class="line">charging android...</span><br></pre></td></tr></table></figure><p>注：以上的例子是对象适配器模式，还有另一种适配器模式叫类适配器模式，这里不再赘述。</p><h2 id="适配器模式在Hadoop源码中的应用"><a href="#适配器模式在Hadoop源码中的应用" class="headerlink" title="适配器模式在Hadoop源码中的应用"></a>适配器模式在Hadoop源码中的应用</h2><p>Hadoop作为广泛应用的大数据组件，其本质是一个分布式系统，在分布式系统中，各个节点之间的通信和交互是必不可少的，为此，Hadoop实现了一套自己的RPC框架，该RPC框架默认使用Protocol Buffer作为序列化工具。</p><p>ClientProtocol协议定义了HDFS Client和NameNode交互的所有方法，但是ClientProtocol协议中方法的参数是无法在网络中传输的，需要对参数进行序列化操作，所以HDFS又定义了ClientNamenodeProtocolPB协议，该协议包含了ClientProtocol定义的所有方法，但是参数却是使用protobuf序列化后的格式。</p><p>ClientNamenodeProtocolTranslatorPB类作为Client侧的<strong>适配器</strong>类，<strong>实现</strong>了ClientProtocol接口，它<strong>内部拥有</strong>一个实现了ClientNamenodeProtocolPB接口的对象，可以将ClientProtocol调用适配成ClientNamenodeProtocolPB调用。以rename()调用为例，ClientNamenodeProtocolPB将rename(String, String)调用中的两个String参数序列化成一个RenameRequestProto对象，然后调用ClientNamenodeProtocolPB对象的rename(RenameRequestProto)方法，这样就完成了ClientProtocol接口到ClientNamenodeProtocolPB接口的适配。</p><p>在该例子中，ClientNamenodeProtocolTranslatorPB类为<strong>适配器</strong>，ClientProtocol为<strong>目标接口</strong>（这里的目标是对客户端来说的），ClientNamenodeProtocolPB为<strong>源接口</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍适配器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://linbingdong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://linbingdong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系列文章——Paxos算法原理与推导</title>
    <link href="http://linbingdong.com/2017/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/"/>
    <id>http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/</id>
    <published>2017-04-16T16:00:00.000Z</published>
    <updated>2017-09-03T02:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。</p><p>网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文《Paxos Made Simple》，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。</p><a id="more"></a><h2 id="Paxos是什么"><a href="#Paxos是什么" class="headerlink" title="Paxos是什么"></a>Paxos是什么</h2><blockquote><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p></blockquote><p>Google Chubby的作者Mike Burrows说过这个世界上<strong>只有一种</strong>一致性算法，那就是Paxos，其它的算法都是<strong>残次品</strong>。</p><p>虽然Mike Burrows说得有点夸张，但是至少说明了Paxos算法的地位。然而，Paxos算法也因为晦涩难懂而臭名昭著。本文的目的就是带领大家深入浅出理解Paxos算法，不仅理解它的执行流程，还要理解算法的推导过程，作者是怎么一步步想到最终的方案的。只有理解了推导过程，才能深刻掌握该算法的精髓。而且理解推导过程对于我们的思维也是非常有帮助的，可能会给我们带来一些解决问题的思路，对我们有所启发。</p><h2 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h2><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><p>注：这里<strong>某个数据的值</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，<strong>某个数据的值</strong>有不同的含义。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-d2136179b456e13e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题产生的背景"></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在Paxos算法中，有三种角色：</p><ul><li><strong>Proposer</strong></li><li><strong>Acceptor</strong></li><li><strong>Learners</strong></li></ul><p>在具体的实现中，一个进程可能<strong>同时充当多种角色</strong>。比如一个进程可能<strong>既是Proposer又是Acceptor又是Learner</strong>。</p><p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>。最终要达成一致的value就在提案里。</p><p><strong>注：</strong></p><ul><li><strong>暂且</strong>认为『<strong>提案=value</strong>』，即提案只包含value。在我们接下来的推导过程中会发现如果提案只包含value，会有问题，于是我们再对提案<strong>重新设计</strong>。</li><li><strong>暂且</strong>认为『<strong>Proposer可以直接提出提案</strong>』。在我们接下来的推导过程中会发现如果Proposer直接提出提案会有问题，需要增加一个学习提案的过程。</li></ul><p>Proposer可以提出（propose）提案；Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p><p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li><li>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6980ffa6b43c16d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关概念"></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有一组可以<strong>提出（propose）value</strong>（value在提案Proposal里）的<strong>进程集合</strong>。一个一致性算法需要保证提出的这么多value中，<strong>只有一个</strong>value被选定（chosen）。如果没有value被提出，就不应该有value被选定。如果一个value被选定，那么所有进程都应该能<strong>学习（learn）</strong>到这个被选定的value。对于一致性算法，<strong>安全性（safaty）</strong>要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定，并且</li><li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><p>我们不去精确地定义其<strong>活性（liveness）</strong>要求。我们的目标是保证<strong>最终有一个提出的value被选定</strong>。当一个value被选定后，进程最终也能学习到这个value。</p><blockquote><p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h3 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h3><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。</p><p>但是，如果这个唯一的Acceptor宕机了，那么整个系统就<strong>无法工作</strong>了！</p><p>因此，必须要有<strong>多个Acceptor</strong>！</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a902b09159405eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只有一个Acceptor"></p><h3 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h3><p>多个Acceptor的情况如下图。那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a85c9965be9d1671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多个Acceptor"></p><p>下面开始寻找解决方案。</p><p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。</p><p>那么，就得到下面的约束：</p><blockquote><p>P1：一个Acceptor必须接受它收到的第一个提案。</p></blockquote><p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a2449c74a784bd87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片08.png"></p><p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p><blockquote><p>规定：一个提案被选定需要被<strong>半数以上</strong>的Acceptor接受</p></blockquote><p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。</p><p>最开始讲的『<strong>提案=value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案=提案编号+value</strong>』。</p><p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。</p><p>于是有了下面的约束：</p><blockquote><p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p></blockquote><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><blockquote><p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p></blockquote><p>只要满足了P2a，就能满足P2。</p><p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2<del>5（半数以上）均接受了该提案，于是对于Acceptor2</del>5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p><ol><li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。 </li><li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-e517a6fd3d55e2c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片10.png"></p><p>所以我们要对P2a约束进行强化！</p><p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p><blockquote><p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p></blockquote><p>由P2b可以推出P2a进而推出P2。</p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p><p>只要满足P2c即可：</p><blockquote><p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p><ul><li>S中每个Acceptor都没有接受过编号小于N的提案。</li><li>S中Acceptor接受过的最大编号的提案的value为V。</li></ul></blockquote><h3 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h3><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p><p>于是我们得到了如下的<strong>提案生成算法</strong>：</p><ol><li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</p><p>我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。</p></li><li><p>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]</strong>。这里的V是所有的响应中<strong>编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>。生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</p></li></ol><h3 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h3><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><blockquote><p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p></blockquote><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-09a81e90de7f722b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小优化"></p><h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。</p><p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><ul><li><p><strong>阶段一：</strong></p><p>(a) Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</p><p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong>作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</p></li><li><p><strong>阶段二：</strong></p><p>(a) 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对<strong>[N,V]提案</strong>的<strong>Accept请求</strong>给<strong>半数以上</strong>的Acceptor。注意：V就是收到的<strong>响应</strong>中<strong>编号最大的提案的value</strong>，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</p><p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-44c5a422f917bfc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paxos算法流程"></p><h2 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-0fab48ed2bdf358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片17.png"></p><h2 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h2><p><img src="http://upload-images.jianshu.io/upload_images/1752522-28b18dd606777074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片18.png"></p><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的<strong>分布式一致性算法</strong>——<strong>Paxos算法</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>论文《Paxos Made Simple》</li><li>论文《The Part-Time Parliament》</li><li>英文版维基百科的Paxos</li><li>中文版维基百科的Paxos</li><li>书籍《从Paxos到ZooKeeper》</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。&lt;/p&gt;
&lt;p&gt;网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文《Paxos Made Simple》，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Paxos" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/Paxos/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HashMap</title>
    <link href="http://linbingdong.com/2017/04/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
    <id>http://linbingdong.com/2017/04/16/深入理解HashMap/</id>
    <published>2017-04-16T12:47:53.000Z</published>
    <updated>2017-04-16T12:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.7和JDK1.8中HashMap的实现不尽相同，JDK1.8中做了一些优化，比如当链表多长时转化成红黑树，提高插入和查找的效率；扩容时不再重新哈希。</p><a id="more"></a><p>HashMap的源码比较长，加上注释有2000行左右，会在文末贴出。这里主要以提问题的形式来加深对HashMap的理解，读者可以先独立思考这些问题，再参照我的回答和文末的源码进行学习。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>数组+链表+红黑树  </p><p>数组是一个Node数组，Node是一个Key-Value对，Node实现了Map.Entry&lt;K,V&gt;。链表/红黑树是用来解决hash冲突的。当链表的长度大于8时会转化成红黑树（Node-&gt;TreeNode），提高插入和查询的效率。</p><h3 id="HashMap继承了哪些类，实现了哪些接口"><a href="#HashMap继承了哪些类，实现了哪些接口" class="headerlink" title="HashMap继承了哪些类，实现了哪些接口"></a>HashMap继承了哪些类，实现了哪些接口</h3><p>继承了AbstractMap类，实现了Serializable/Cloneable/Map接口</p><h3 id="如何put和get"><a href="#如何put和get" class="headerlink" title="如何put和get"></a>如何put和get</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ol><li>确定key对应的Node的索引： h = key.hashCode(); hash = h ^ (h &gt;&gt;&gt; 16); index = hash &amp; (length - 1)</li><li>如果第一个Node的key跟该key相等（hash值相同且equals），则返回第一个Node的value。</li><li>如果第一个是TreeNode，则用红黑树的方法进行搜索，找到key相同的返回该Node的value；如果第一个是Node，则按链表逐个搜索，找到key相同的返回该Node的value。</li><li>返回null</li></ol><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ol><li>如果数组长度为0，先扩容。如果已经是最大容量，则不再扩。</li><li>计算放置的位置（数组下标）。h = key.hashCode(); hash = h ^ h &gt;&gt;&gt; 16; index = hash &amp; (length - 1)</li><li>若该位置为null，则直接将新节点放入该位置</li><li>若该位置不为null，如果第一个节点的key跟要put的key相同（hashCode和equals），直接覆盖value</li><li>否则，判断是否为TreeNode，若是，则直接在红黑树中插入键值对。</li><li>若是链表，判断链表的长度是否大于8，如果大于8则转为红黑树，并在红黑树中插入。否则执行链表中的插入操作。遍历链表时若发现key已经存在则直接覆盖value。</li><li>如果超过阈值，就扩容。</li></ol><h3 id="初始容量和最大容量分别是多少"><a href="#初始容量和最大容量分别是多少" class="headerlink" title="初始容量和最大容量分别是多少"></a>初始容量和最大容量分别是多少</h3><p>默认初始容量为16（1&lt;&lt;4），可以在初始化时自己指定。最大容量为2的30次方（1&lt;&lt;30）,容量一定是2的整数幂</p><h3 id="加载因子（loadFactor）是多少，为什么"><a href="#加载因子（loadFactor）是多少，为什么" class="headerlink" title="加载因子（loadFactor）是多少，为什么"></a>加载因子（loadFactor）是多少，为什么</h3><p>0.75 </p><p>加载因子默认为0.75是对时间和空间的折中。加载因子越大，空间利用率越高，但是产生冲突的概率就越大，会导致put和get效率降低。</p><h3 id="如何确定Node在数组中的位置（如何构造哈希函数）"><a href="#如何确定Node在数组中的位置（如何构造哈希函数）" class="headerlink" title="如何确定Node在数组中的位置（如何构造哈希函数）"></a>如何确定Node在数组中的位置（如何构造哈希函数）</h3><ol><li>通过key.hashCode()获得 h = key.hashCode()，</li><li>将h的高16位和低16位异或。 hash = h ^ (h &gt;&gt;&gt; 16)</li><li>index = hash &amp; (length - 1)  等价于hash % length。前提是length必须为2的整数幂</li></ol><h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><ol><li>合理的加载因子，如果加载因子设置得过大会增加冲突的概率</li><li>合理的hash函数。比如将hashCode的高16位和低16位异或。</li></ol><h3 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h3><p>采用拉链法解决冲突（链表的插入采用头插法）。</p><h3 id="什么时候扩容，如何扩容"><a href="#什么时候扩容，如何扩容" class="headerlink" title="什么时候扩容，如何扩容"></a>什么时候扩容，如何扩容</h3><p>当Node数（size）超过阈值（threshold = 容量*加载因子）时会扩容。扩容为原来的两倍。</p><ol><li>新建一个两倍大的数组</li><li>把旧数组中的Node全部放入新数组。JDK1.7中所有的Node都会重新hash来确定在新数组中的位置，效率很低；但其实扩容为两倍后，新的Node下标要么跟原来相等，要么比原来大length。JDK1.8中就采取后面的方法，效率更高.</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>包含 初始容量和加载因子 两个参数的构造函数<br>如果指定的初始容量大于最大容量，会以最大容量作为初始容量；<br>如果指定的初始容量不是2的整数幂，会找到大于该值的最小的2的整数幂作为初始容量。</p></li><li><p>默认构造函数<br>初始容量为16；加载因子为0.75</p></li><li><p>包含子map的构造函数</p></li></ul><h3 id="为什么数组容量要是2的整数幂"><a href="#为什么数组容量要是2的整数幂" class="headerlink" title="为什么数组容量要是2的整数幂"></a>为什么数组容量要是2的整数幂</h3><ol><li>这样hash % length 可以转化为 hash &amp; (length -1) 位运算效率更高</li><li>保证length - 1二进制表示的最低位为1。 如果最低位为 0 ，则按位与之后一定得到偶数（下标都是偶数），这样浪费了一大半的空间。</li></ol><h3 id="什么情况下HashMap会线程不安全"><a href="#什么情况下HashMap会线程不安全" class="headerlink" title="什么情况下HashMap会线程不安全"></a>什么情况下HashMap会线程不安全</h3><ol><li><p>如线程A和线程B同时put并写入相同的位置。两个线程都会得到该位置当前的头节点。如果A先写入新的头节点，然后B也写入新的头节点，那么B的操作就会覆盖A的操作造成A的写入操作丢失。</p></li><li><p>如多个线程同时put并刚好都达到门限值，然后都进行了resize（扩容）。此时每个线程都会生成一个新的数组并将table指针指向新的数组，结果最终只有最后一个线程的生成的新数组被赋给table变量，其他线程的均会丢失。</p></li></ol><p>HashMap源码（JDK1.8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns x's Class if it is of the form "class C implements</span></span><br><span class="line"><span class="comment">     * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns k.compareTo(x) if x matches kc (k's screened comparable</span></span><br><span class="line"><span class="comment">     * class), else 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment">     * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     * The map will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks;</span><br><span class="line">        <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs;</span><br><span class="line">        <span class="keyword">return</span> (vs = values) == <span class="keyword">null</span> ? (values = <span class="keyword">new</span> Values()) : vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">                   BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// spliterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">        <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">        <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                           <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                           <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.map = m;</span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.est = est;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            getFence(); <span class="comment">// force init</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        K k = current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        V v = current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following package-protected methods are designed to be</span></span><br><span class="line"><span class="comment">     * overridden by LinkedHashMap, but not by any other subclass.</span></span><br><span class="line"><span class="comment">     * Nearly all other internal methods are also package-protected</span></span><br><span class="line"><span class="comment">     * but are declared final, so can be used by LinkedHashMap, view</span></span><br><span class="line"><span class="comment">     * classes, and HashSet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">         * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">         * comparing keys.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls find for root node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">         * hashCodes and non-comparable. We don't require a total</span></span><br><span class="line"><span class="comment">         * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">         * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">         * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> d;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">         * this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tree version of putVal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">         * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">         * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">         * successor that is pinned by "next" pointers that are accessible</span></span><br><span class="line"><span class="comment">         * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">         * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">         * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">         * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Recursive invariant check</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK1.7和JDK1.8中HashMap的实现不尽相同，JDK1.8中做了一些优化，比如当链表多长时转化成红黑树，提高插入和查找的效率；扩容时不再重新哈希。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模式</title>
    <link href="http://linbingdong.com/2017/04/14/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://linbingdong.com/2017/04/14/生产者消费者模式/</id>
    <published>2017-04-14T08:16:06.000Z</published>
    <updated>2017-04-14T08:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p><a id="more"></a><h2 id="什么是生产者消费者模式"><a href="#什么是生产者消费者模式" class="headerlink" title="什么是生产者消费者模式"></a>什么是生产者消费者模式</h2><p>生产者消费者模式通过一个容器（比如阻塞队列 BlockingQueue ）来解决生产者和消费者的紧耦合问题。生产者和消费者之间不直接通信，而是通过阻塞队列来通信。生产者生产完数据后不用等待消费者处理，而是直接将生产的数据放入阻塞队列；消费者不从生产者那里要数据，而是直接从阻塞队列里取。阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>阻塞队列提供了可阻塞的 put 和 take 方法，以及支持定时的 offer 和 poll 方法。如果队列已经满了，那么 put 方法将阻塞直到有空间可用；如果队列为空，那么 take 方法将会阻塞直到阻塞队列里有元素可用。</p><h2 id="为什么要用生产者消费者模式"><a href="#为什么要用生产者消费者模式" class="headerlink" title="为什么要用生产者消费者模式"></a>为什么要用生产者消费者模式</h2><ol><li>生产者消费者模式可以使生产者类和消费者类解耦，这样能大大简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性。</li><li>生产者消费者模式可以解决生产消费能力不均衡的问题，从而提高整体处理数据的速度。假设不使用生产者消费者模式，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据；有了生产者消费者模式，生产者就可以不用等待消费者了，这样提高了生产者生产数据的效率。</li></ol><h2 id="使用阻塞队列实现生产者消费者模式"><a href="#使用阻塞队列实现生产者消费者模式" class="headerlink" title="使用阻塞队列实现生产者消费者模式"></a>使用阻塞队列实现生产者消费者模式</h2><p>代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(blockingQueue), <span class="string">"Producer"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(blockingQueue), <span class="string">"Consumer"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String product = <span class="string">"Produced by "</span> + Thread.currentThread().getName();</span><br><span class="line">            blockingQueue.put(product);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produced a product"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = blockingQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" cunsumed product "</span>+ product);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Producer0 produced a product</span><br><span class="line">Producer2 produced a product</span><br><span class="line">Producer3 produced a product</span><br><span class="line">Producer1 produced a product</span><br><span class="line">Producer4 produced a product</span><br><span class="line">Producer5 produced a product</span><br><span class="line">Producer6 produced a product</span><br><span class="line">Producer7 produced a product</span><br><span class="line">Producer8 produced a product</span><br><span class="line">Producer9 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer0</span><br><span class="line">Producer11 produced a product</span><br><span class="line">Producer12 produced a product</span><br><span class="line">Producer10 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer1</span><br><span class="line">Consumer0 cunsumed product Produced by Producer2</span><br><span class="line">Producer13 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer3</span><br><span class="line">Consumer1 cunsumed product Produced by Producer5</span><br><span class="line">Producer15 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer4</span><br><span class="line">Producer16 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer6</span><br><span class="line">Producer14 produced a product</span><br><span class="line">Producer18 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer8</span><br><span class="line">Producer17 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer7</span><br><span class="line">Producer19 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer9</span><br><span class="line">Consumer0 cunsumed product Produced by Producer10</span><br><span class="line">Consumer1 cunsumed product Produced by Producer11</span><br><span class="line">Consumer0 cunsumed product Produced by Producer12</span><br><span class="line">Consumer1 cunsumed product Produced by Producer13</span><br><span class="line">Consumer0 cunsumed product Produced by Producer14</span><br><span class="line">Consumer1 cunsumed product Produced by Producer15</span><br><span class="line">Consumer0 cunsumed product Produced by Producer16</span><br><span class="line">Consumer1 cunsumed product Produced by Producer17</span><br><span class="line">Consumer0 cunsumed product Produced by Producer18</span><br><span class="line">Consumer1 cunsumed product Produced by Producer19</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>程序员必读书单</title>
    <link href="http://linbingdong.com/2017/04/14/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    <id>http://linbingdong.com/2017/04/14/程序员必读书单/</id>
    <published>2017-04-14T08:15:36.000Z</published>
    <updated>2018-04-27T02:46:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://zh.lucida.me/" target="_blank" rel="noopener">Lucida</a>大神这篇文章写得非常详细，<a href="http://zh.lucida.me/blog/developer-reading-list/#cracking_the_coding_interview" target="_blank" rel="noopener">点此查看</a>。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://zh.lucida.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lucida&lt;/a&gt;大神这篇文章写得非常详细，&lt;a href=&quot;http://zh.lucida.me/blog/developer-reading-list/#cracking_the_coding_interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此查看&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资料" scheme="http://linbingdong.com/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="好文转载" scheme="http://linbingdong.com/tags/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="必读书单" scheme="http://linbingdong.com/tags/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    
      <category term="学习资料" scheme="http://linbingdong.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>tmpfs</title>
    <link href="http://linbingdong.com/2017/04/11/tmpfs/"/>
    <id>http://linbingdong.com/2017/04/11/tmpfs/</id>
    <published>2017-04-11T06:03:33.000Z</published>
    <updated>2017-04-11T06:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同。和ramdisk一样，tmpfs可以使用内存，但它也可以使用swap分区来存储。而且传统的ramdisk是个块设备，要用mkfs格式化才能使用；而tmpfs是一个文件系统，并不是块设备，不需要格式化。tmpfs是最好的基于内存的文件系统。</p><a id="more"></a><p>用一个简单的mount命令就可以创建tmpfs文件系统：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount tmpfs -t tmpfs /data/test -o size=10g</span><br></pre></td></tr></table></figure><p>将tmpfs挂载到/data/mfs目录后，往/data/mfs写入的内容都会写到内存里。如果需要重新设置分配的内存大小，可以先umount，再重新挂载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /data/mfs</span><br><span class="line">mount tmpfs -t tmpfs /data/test -o size=20g</span><br></pre></td></tr></table></figure><p>也可以在/etc/fstab里设置。</p><p>MooseFS是分布式文件系统，正常情况下文件是写到chunkserver节点的磁盘里。如果想让文件写入内存，可以将tmpfs挂到MooseFS的chunkserver节点的数据目录下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount tmpfs -t tmpfs /data/mfs -o size=50g</span><br></pre></td></tr></table></figure><p>这样以后往MooseFS里写数据就都写到内存里了。</p><p>注意：</p><ol><li>挂载前应该先关闭MooseFS，挂载后再启动MooseFS。没有启动MooseFS的话执行<code>df -h</code>命令会无响应。</li><li>该方法只是用来尝鲜，如果想使用基于内存的分布式文件系统，应该使用类似Alluxio这样的组件。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同。和ramdisk一样，tmpfs可以使用内存，但它也可以使用swap分区来存储。而且传统的ramdisk是个块设备，要用mkfs格式化才能使用；而tmpfs是一个文件系统，并不是块设备，不需要格式化。tmpfs是最好的基于内存的文件系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://linbingdong.com/categories/Linux/"/>
    
    
      <category term="tmpfs" scheme="http://linbingdong.com/tags/tmpfs/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统(Distributed System)资料大全</title>
    <link href="http://linbingdong.com/2017/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(Distributed%20System)%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8/"/>
    <id>http://linbingdong.com/2017/04/09/分布式系统(Distributed System)资料大全/</id>
    <published>2017-04-09T15:17:43.000Z</published>
    <updated>2017-04-09T15:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统资料大全，enjoy！</p><a id="more"></a><ul><li><a href="http://sydney.edu.au/engineering/it/~gramoli/doc/pubs/OPODIS05.pdf" target="_blank" rel="noopener">《Reconfigurable Distributed Storage for Dynamic Networks》</a></li></ul><p>介绍:这是一篇介绍在动态网络里面实现分布式系统重构的paper.论文的作者(导师)是MIT读博的时候是做分布式系统的研究的,现在在NUS带学生,不仅仅是<a href="http://www.comp.nus.edu.sg/~gilbert/biblio-projects.html#rambo" target="_blank" rel="noopener">分布式系统</a>,还有无线网络.如果感兴趣可以去他的主页了解.</p><ul><li><a href="http://lpd.epfl.ch/site" target="_blank" rel="noopener">《Distributed porgramming liboratory》</a></li></ul><p>介绍:分布式编程实验室,他们发表的很多的<a href="http://lpd.epfl.ch/site/Publications" target="_blank" rel="noopener">paper</a>,其中不仅仅是学术研究,还有一些工业界应用的论文.</p><ul><li><a href="http://groups.csail.mit.edu/tds/" target="_blank" rel="noopener">《MIT Theory of Distributed Systems》</a></li></ul><p>介绍:麻省理工的分布式系统理论主页,作者南希·林奇在2002年证明了<a href="http://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">CAP理论</a>,并且著《分布式算法》一书.</p><ul><li><a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/" target="_blank" rel="noopener">《Notes on Distributed Systems for Young Bloods》</a></li></ul><p>介绍:分布式系统搭建初期的一些建议</p><ul><li><a href="http://dcg.ethz.ch/lectures/podc_allstars/" target="_blank" rel="noopener">《Principles of Distributed Computing》</a></li></ul><p>介绍:分布式计算原理课程</p><ul><li><a href="http://research.google.com/archive/spanner.html" target="_blank" rel="noopener">《Google’s Globally-Distributed Database》</a></li></ul><p>介绍:Google全球分布式数据介绍,<a href="http://dblab.xmu.edu.cn/wp-content/uploads/2012/09/20120925_094508_876.pdf" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://highscalability.com/blog/2015/3/9/the-architecture-of-algolias-distributed-search-network.html" target="_blank" rel="noopener">《The Architecture Of Algolia’s Distributed Search Network》</a></li></ul><p>介绍:Algolia的分布式搜索网络的体系架构介绍</p><ul><li><a href="https://medium.com/@siddontang/build-up-a-high-availability-distributed-key-value-store-b4e02bc46e9e" target="_blank" rel="noopener">《Build up a High Availability Distributed Key-Value Store》</a></li></ul><p>介绍:构建高可用分布式Key-Value存储系统</p><ul><li><a href="https://daniel-j-h.github.io/post/distributed-search-nanomsg-bond/" target="_blank" rel="noopener">《Distributed Search Engine with Nanomsg and Bond》</a></li></ul><p>介绍:Nanomsg和Bond的分布式搜索引擎</p><ul><li><a href="http://tech.gc.com/distributed-processing-with-mongodb-and-mongothon/" target="_blank" rel="noopener">《Distributed Processing With MongoDB And Mongothon》</a></li></ul><p>介绍:使用MongoDB和Mongothon进行分布式处理</p><ul><li><a href="http://muratbuffalo.blogspot.jp/2015/02/salt-combining-acid-and-base-in.html" target="_blank" rel="noopener">《Salt: Combining ACID and BASE in a Distributed Database》</a></li></ul><p>介绍:分布式数据库中把<a href="http://www.sigma.me/2011/06/17/database-ACID-and-BASE.html" target="_blank" rel="noopener">ACID与BASE</a>结合使用.</p><ul><li><a href="http://paxos.systems/" target="_blank" rel="noopener">《Makes it easy to understand Paxos for Distributed Systems》</a></li></ul><p>介绍:理解的Paxos的分布式系统,<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://queue.acm.org/detail.cfm?id=2745385" target="_blank" rel="noopener">《There is No Now Problems with simultaneity in distributed systems》</a></li></ul><p>介绍:There is No Now Problems with simultaneity in distributed systems</p><ul><li><a href="http://www0.cs.ucl.ac.uk/staff/ucacwxe/lectures/ds98-99/" target="_blank" rel="noopener">《Distributed Systems》</a></li></ul><p>介绍:伦敦大学学院分布式系统课程课件.</p><ul><li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="noopener">《Distributed systems for fun and profit》</a></li></ul><p>介绍:分布式系统电子书籍.</p><ul><li><a href="http://www.andrew.cmu.edu/course/95-702/" target="_blank" rel="noopener">《Distributed Systems Spring 2015》</a></li></ul><p>介绍:卡内基梅隆大学春季分布式课程主页</p><ul><li><a href="https://azmuri.files.wordpress.com/2013/09/george-coulouris-distributed-systems-concepts-and-design-5th-edition.pdf" target="_blank" rel="noopener">《Distributed Systems: Concepts and Design (5th Edition)》</a></li></ul><p>介绍: 电子书,分布式系统概念与设计(第五版)</p><ul><li><a href="http://ithelp.ithome.com.tw/profile/share?id=20060041" target="_blank" rel="noopener">《走向分布式》</a></li></ul><p>介绍:这是一位台湾网友 ccshih 的文字，短短的篇幅介绍了分布式系统的若干要点。<a href="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf" target="_blank" rel="noopener">pdf</a></p><ul><li><a href="http://thu-cmu.cs.tsinghua.edu.cn/curriculum/dscourse/index.htm" target="_blank" rel="noopener">《Introduction to Distributed Systems Spring 2013》</a></li></ul><p>介绍:清华大学分布式系统课程主页,里面的schedule栏目有很多宝贵的资源</p><ul><li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="noopener">《Distributed systems》</a></li></ul><p>介绍:免费的在线分布式系统书籍</p><ul><li><a href="http://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《Some good resources for learning about distributed computing》</a></li></ul><p>介绍:Quora上面的一篇关于学习分布式计算的资源.</p><ul><li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/es//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">《Spanner: Google’s Globally-Distributed Database》</a></li></ul><p>介绍:这个是第一个全球意义上的分布式数据库，也是Google的作品。其中介绍了很多一致性方面的设计考虑，为了简单的逻辑设计，还采用了原子钟，同样在分布式系统方面具有很强的借鉴意义.</p><ul><li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN//archive/chubby-osdi06.pdf" target="_blank" rel="noopener">《The Chubby lock service for loosely-coupled distributed systems》</a></li></ul><p>介绍:Google的统面向松散耦合的分布式系统的锁服务,这篇论文详细介绍了Google的分布式锁实现机制Chubby。Chubby是一个基于文件实现的分布式锁，Google的Bigtable、Mapreduce和Spanner服务都是在这个基础上构建的，所以Chubby实际上是Google分布式事务的基础，具有非常高的参考价值。另外，著名的zookeeper就是基于Chubby的开源实现.推荐<a href="http://malteschwarzkopf.de/research/assets/google-stack.pdf" target="_blank" rel="noopener">The google stack</a>,<a href="https://www.youtube.com/watch?v=PqItueBaiRg" target="_blank" rel="noopener">Youtube:The Chubby lock service for loosely-coupled distributed systems</a></p><ul><li><a href="http://www.sosp2007.org/papers/sosp064-aguilera.pdf" target="_blank" rel="noopener">《Sinfonia: a new paradigm for building scalable distributed systems》</a></li></ul><p>介绍:这篇论文是SOSP2007的Best Paper，阐述了一种构建分布式文件系统的范式方法，个人感觉非常有用。淘宝在构建TFS、OceanBase和Tair这些系统时都充分参考了这篇论文.</p><ul><li><a href="http://lintool.github.io/MapReduceAlgorithms/MapReduce-book-final.pdf" target="_blank" rel="noopener">《Data-Intensive Text Processing with MapReduce》</a></li></ul><p>介绍:Ebook:Data-Intensive Text Processing with MapReduce.</p><ul><li><a href="http://www.utdallas.edu/~bxt043000/Publications/Journal-Papers/DAS/J16_Design_and_Implementation_of_a_Distributed_Query_Processor.pdf" target="_blank" rel="noopener">《Design and Implementation of a Query Processor for a Trusted Distributed Data Base Management System》</a></li></ul><p>介绍:Design and Implementation of a Query Processor for a Trusted Distributed Data Base Management System.</p><ul><li><a href="http://ogsa-dai.sourceforge.net/documentation/ogsadai4.0/ogsadai4.0-gt/DQPPart.html" target="_blank" rel="noopener">《Distributed Query Processing》</a></li></ul><p>介绍:分布式查询入门.</p><ul><li><a href="http://writings.quilt.org/2014/05/12/distributed-systems-and-the-end-of-the-api/" target="_blank" rel="noopener">《Distributed Systems and the End of the API》</a></li></ul><p>介绍:分布式系统和api总结.</p><ul><li><a href="http://www.andrew.cmu.edu/course/15-749/READINGS/required/" target="_blank" rel="noopener">《Distributed Query Reading》</a></li></ul><p>介绍:分布式系统阅读论文，此外还推荐github上面的一个论文列表<a href="http://reiddraper.github.io/distreader/" target="_blank" rel="noopener">The Distributed Reader</a>。</p><ul><li><a href="http://afeinberg.github.io/2011/06/17/replication-atomicity-and-order-in-distributed-systems.html" target="_blank" rel="noopener">《Replication, atomicity and order in distributed systems》</a></li></ul><p>介绍:Replication, atomicity and order in distributed systems</p><ul><li><a href="http://nil.csail.mit.edu/6.824/2015/" target="_blank" rel="noopener">《MIT course:Distributed Systems》</a></li></ul><p>介绍:2015年MIT分布式系统课程主页，这次用Golang作为授课语言。<a href="https://pdos.csail.mit.edu/6.824/" target="_blank" rel="noopener">6.824 Distributed Systems</a>课程主页</p><ul><li><a href="http://book.mixu.net/distsys/" target="_blank" rel="noopener">《Distributed systems for fun and profit》</a></li></ul><p>介绍:免费分布式系统电子书。</p><ul><li><a href="http://ori.scs.stanford.edu/" target="_blank" rel="noopener">《Ori：A Secure Distributed File System》</a></li></ul><p>介绍:斯坦福开源的分布式文件系统。</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36737.pdf" target="_blank" rel="noopener">《Availability in Globally Distributed Storage Systems》</a></li></ul><p>介绍:Google论文：设计一个高可用的全球分布式存储系统。</p><ul><li><a href="http://highscalability.com/blog/2013/5/23/paper-calvin-fast-distributed-transactions-for-partitioned-d.html" target="_blank" rel="noopener">《Calvin: Fast Distributed Transactions For Partitioned Database Systems》</a></li></ul><p>介绍:对于分区数据库的分布式事务处理。</p><ul><li><a href="http://yellerapp.com/posts/2015-02-09-flake-ids.html" target="_blank" rel="noopener">《Distributed Systems Building Block: Flake Ids》</a></li></ul><p>介绍:Distributed Systems Building Block: Flake Ids.</p><ul><li><a href="http://www.hpcs.cs.tsukuba.ac.jp/~tatebe/lecture/h23/dsys/dsd-tutorial.html" target="_blank" rel="noopener">《Introduction to Distributed System Design》</a></li></ul><p>介绍:Google Code University课程，如何设计一个分布式系统。</p><ul><li><a href="http://sheepdog.github.io/sheepdog/" target="_blank" rel="noopener">《Sheepdog: Distributed Storage System for KVM》</a></li></ul><p>介绍:KVM的分布式存储系统.</p><ul><li><a href="http://henryr.github.io/distributed-systems-readings/" target="_blank" rel="noopener">《Readings in Distributed Systems Systems》</a></li></ul><p>介绍:分布式系统课程列表,包括数据库、算法等.</p><ul><li><a href="https://github.com/BaiduPS/tera" target="_blank" rel="noopener">《Tera》</a></li></ul><p>介绍:来自百度的分布式表格系统.</p><ul><li><a href="https://github.com/mixu/distsysbook" target="_blank" rel="noopener">《Distributed systems: for fun and profit》</a></li></ul><p>介绍:分布式系统的在线电子书.</p><ul><li><a href="https://github.com/notgary/distributed-systems-reading-list" target="_blank" rel="noopener">《Distributed Systems Reading List》</a></li></ul><p>介绍:分布式系统资料,此外还推荐<a href="https://github.com/hiremaga/readings" target="_blank" rel="noopener">Various articles about distributed systems</a>.</p><ul><li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener">《Designs, Lessons and Advice from Building Large Distributed Systems》</a></li></ul><p>介绍:Designs, Lessons and Advice from Building Large Distributed Systems.</p><ul><li><a href="http://queue.acm.org/detail.cfm?ref=rss&id=2800697" target="_blank" rel="noopener">《Testing a Distributed System》</a></li></ul><p>介绍:Testing a distributed system can be trying even under the best of circumstances.</p><ul><li><a href="https://research.google.com/archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">《The Google File System》</a></li></ul><p>介绍: 基于普通服务器构建超大规模文件系统的典型案例，主要面向大文件和批处理系统， 设计简单而实用。 GFS是google的重要基础设施， 大数据的基石， 也是Hadoop HDFS的参考对象。 主要技术特点包括： 假设硬件故障是常态（容错能力强）， 64MB大块， 单Master设计，Lease/链式复制， 支持追加写不支持随机写.</p><ul><li><a href="https://research.google.com/archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">《Bigtable: A Distributed Storage System for Structured Data》</a></li></ul><p>介绍:支持PB数据量级的多维非关系型大表， 在google内部应用广泛，大数据的奠基作品之一 ， Hbase就是参考BigTable设计。 Bigtable的主要技术特点包括： 基于GFS实现数据高可靠， 使用非原地更新技术（LSM树）实现数据修改， 通过range分区并实现自动伸缩等.<a href="http://dblab.xmu.edu.cn/wp-content/uploads/2012/05/20120508_172346_207.pdf" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://research.microsoft.com:8082/pubs/66814/tr-2008-25.pdf" target="_blank" rel="noopener">《PacificA: Replication in Log-Based Distributed Storage Systems》</a></li></ul><p>介绍:面向log-based存储的强一致的主从复制协议， 具有较强实用性。 这篇文章系统地讲述了主从复制系统应该考虑的问题， 能加深对主从强一致复制的理解程度。 技术特点： 支持强一致主从复制协议， 允许多种存储实现， 分布式的故障检测/Lease/集群成员管理方法.</p><ul><li><a href="http://sns.cs.princeton.edu/docs/craq-usenix09.pdf" target="_blank" rel="noopener">《Object Storage on CRAQ, High-throughput chain replication for read-mostly workloads》</a></li></ul><p>介绍:分布式存储论文:支持强一直的链式复制方法， 支持从多个副本读取数据,实现<a href="https://github.com/jterrace/craq" target="_blank" rel="noopener">code</a>.</p><ul><li><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener">《Finding a needle in Haystack: Facebook’s photo storage》</a></li></ul><p>介绍:Facebook分布式Blob存储,主要用于存储图片. 主要技术特色:小文件合并成大文件,小文件元数据放在内存因此读写只需一次IO.</p><ul><li><a href="http://www-bcf.usc.edu/~minlanyu/teach/csci599-fall12/papers/11-calder.pdf" target="_blank" rel="noopener">《Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency》</a></li></ul><p>介绍: 微软的分布式存储平台, 除了支持类S3对象存储，还支持表格、队列等数据模型. 主要技术特点：采用Stream/Partition两层设计（类似BigTable）;写错（写满）就封存Extent,使得副本字节一致, 简化了选主和恢复操作; 将S3对象存储、表格、队列、块设备等融入到统一的底层存储架构中.</p><ul><li><a href="http://www.eecs.harvard.edu/cs262/Readings/paxosmadelive.pdf" target="_blank" rel="noopener">《Paxos Made Live – An Engineering Perspective》</a></li></ul><p>介绍:从工程实现角度说明了Paxo在chubby系统的应用， 是理解Paxo协议及其应用场景的必备论文。 主要技术特点： paxo协议， replicated log， multi-paxo.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">《Dynamo: Amazon’s Highly Available Key-Value Store》</a></li></ul><p>介绍:Amazon设计的高可用的kv系统,主要技术特点：综和运用一致性哈希,vector clock,最终一致性构建一个高可用的kv系统， 可应用于amazon购物车场景.新内容来自<a href="http://50vip.com/423.html" target="_blank" rel="noopener">分布式存储必读论文</a></p><ul><li><a href="http://oceanstore.cs.berkeley.edu/publications/papers/pdf/carbonite06.pdf" target="_blank" rel="noopener">《Efficient Replica Maintenance for Distributed Storage Systems》</a></li></ul><p>介绍:分布式存储系统中的副本存储问题.</p><ul><li><a href="https://www.cs.nyu.edu/rgrimm/papers/nsdi09.pdf" target="_blank" rel="noopener">《PADS: A Policy Architecture for Distributed Storage Systems》</a></li></ul><p>介绍:分布式存储系统架构.</p><ul><li><a href="http://ccl.cse.nd.edu/software/chirp/" target="_blank" rel="noopener">《The Chirp Distributed Filesystem》</a></li></ul><p>介绍:开源分布式文件系统Chirp,对于想深入研究的开发者可以阅读文章的相关Papers.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf" target="_blank" rel="noopener">《Time, Clocks, and the Ordering of Events in a Distributed System》</a></li></ul><p>介绍:经典论文分布式时钟顺序的实现原理.</p><ul><li><a href="http://www.erlang.org/download/armstrong_thesis_2003.pdf" target="_blank" rel="noopener">《Making reliable distributed systems in the presence of sodware errors》</a></li></ul><p>介绍:面向软件错误构建可靠的分布式系统,<a href="http://www.cnblogs.com/me-sa/archive/2012/05/20/2510564.html" target="_blank" rel="noopener">中文笔记</a>.</p><ul><li><a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">《MapReduce: Simplified Data Processing on Large Clusters》</a></li></ul><p>介绍:MapReduce:超大集群的简单数据处理.</p><ul><li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-824-distributed-computer-systems-engineering-spring-2006/index.htm" target="_blank" rel="noopener">《Distributed Computer Systems Engineering》</a></li></ul><p>介绍:麻省理工的分布式计算课程主页,里面的ppt和阅读列表很多干货.</p><ul><li><a href="http://www.vitanuova.com/inferno/papers/styx.html" target="_blank" rel="noopener">《The Styx Architecture for Distributed Systems》</a></li></ul><p>介绍:分布式系统Styx的架构剖析.</p><ul><li><a href="https://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《What are some good resources for learning about distributed computing? Why?》</a></li></ul><p>介绍:Quora上面的一个问答:有哪些关于分布式计算学习的好资源.</p><ul><li><a href="http://highscalability.com/blog/2015/7/8/reborndb-the-next-generation-distributed-key-value-store.html" target="_blank" rel="noopener">《RebornDB: The Next Generation Distributed Key-Value Store》</a></li></ul><p>介绍:下一代分布式k-v存储数据库.</p><ul><li><a href="http://codex.cs.yale.edu/avi/os-book/OS9/" target="_blank" rel="noopener">《Operating System Concepts Ninth Edition》</a></li></ul><p>介绍:分布式系统归根结底还是需要操作系统的知识,这是耶鲁大学的操作系统概念书籍首页,里面有提供了第8版的在线电子版和最新的学习操作系统指南,学习分布式最好先学习操作系统.</p><ul><li><a href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="noopener">《The Log: What every software engineer should know about real-time data’s unifying abstraction》</a></li></ul><p>介绍:分布式系统Log剖析,非常的详细与精彩. <a href="https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md" target="_blank" rel="noopener">中文翻译</a> |  <a href="http://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html" target="_blank" rel="noopener">中文版笔记</a>.</p><ul><li><a href="http://faculty.salina.k-state.edu/tim/ossg/index.html" target="_blank" rel="noopener">《Operating Systems Study Guide》</a></li></ul><p>介绍:分布式系统基础之操作系统学习指南.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/709717672011330101333271/" target="_blank" rel="noopener">《分布式系统领域经典论文翻译集》</a></li></ul><p>介绍:分布式系统领域经典论文翻译集.</p><ul><li><a href="https://speakerdeck.com/elasticsearch/maintaining-performance-in-distributed-systems" target="_blank" rel="noopener">《Maintaining performance in distributed systems》</a></li></ul><p>介绍:分布式系统性能维护.</p><ul><li><a href="http://www.bottomupcs.com/" target="_blank" rel="noopener">《Computer Science from the Bottom Up》</a></li></ul><p>介绍:计算机科学，自底向上,小到机器码,大到操作系统内部体系架构,学习操作系统的另一个在线好材料.</p><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">《Operating Systems: Three Easy Pieces》</a></li></ul><p>介绍:&lt;操作系统:三部曲&gt;在线电子书,虚拟、并发、持续.</p><ul><li><a href="http://www.cs286.net/home/reading-list" target="_blank" rel="noopener">《Database Systems: reading list》</a></li></ul><p>介绍:数据库系统经典论文阅读列,此外推送github上面的<a href="https://github.com/rxin/db-readings" target="_blank" rel="noopener">db reading</a>.</p><ul><li><a href="http://www.washington.edu/R870/" target="_blank" rel="noopener">《Unix System Administration》</a></li></ul><p>介绍:Unix System Administration ebook.</p><ul><li><a href="https://www.cs.vu.nl/~ast/publications/compcom-1991.pdf" target="_blank" rel="noopener">《The Amoeba Distributed Operating System》</a></li></ul><p>介绍:分布式系统经典论文.</p><ul><li><a href="http://web.mit.edu/6.826/archive/S04/" target="_blank" rel="noopener">《Principles of Computer Systems》</a></li></ul><p>介绍:计算机系统概念，以分布式为主.此外推荐<a href="http://www2.cs.uregina.ca/~hamilton/courses/330/notes/index.html" target="_blank" rel="noopener">Introduction to Operating Systems</a>笔记</p><ul><li><a href="http://www.cs.cornell.edu/People/egs/" target="_blank" rel="noopener">《Person page of EMİN GÜN SİRER》</a></li></ul><p>介绍:推荐康奈尔大学的教授EMİN GÜN SİRER的主页,他的研究项目有分布式,数据存储。例如<a href="http://hyperdex.org/papers/" target="_blank" rel="noopener">HyperDex</a>数据库就是他的其中一个项目之一.</p><ul><li><a href="http://www.cs.cmu.edu/afs/cs/project/coda-www/ResearchWebPages/docdir/scalable90.pdf" target="_blank" rel="noopener">《Scalable, Secure, and Highly Available Distributed File Access》</a></li></ul><p>介绍:来自卡内基梅隆如何构建可扩展的、安全、高可用性的分布式文件系统,<a href="http://www.cs.cmu.edu/afs/cs/project/coda-www/ResearchWebPages/docdir/" target="_blank" rel="noopener">其他papers</a>.</p><ul><li><a href="http://dmlc.github.io/" target="_blank" rel="noopener">《Distributed (Deep) Machine Learning Common》</a></li></ul><p>介绍:分布式机器学习常用库.</p><ul><li><a href="http://www.cs.berkeley.edu/~rxin/db-papers/WarehouseScaleComputing.pdf" target="_blank" rel="noopener">《The Datacenter as a Computer》</a></li></ul><p>介绍:介绍了如何构建仓储式数据中心,尤其是对于现在的云计算,分布式学习来说很有帮助.本书是<a href="http://www.morganclaypool.com/toc/cac/1/1" target="_blank" rel="noopener">Synthesis Lectures on Computer Architecture</a>系列的书籍之一,这套丛书还有 《The Memory System》,《Automatic Parallelization》,《Computer Architecture Techniques for Power Efficiency》,《Performance Analysis and Tuning for General Purpose Graphics Processing Units》,《Introduction to Reconfigurable Supercomputing》,<a href="http://www.e-reading.club/bookreader.php/138837/Jacob,_Ng,_Wang_-_Memory_systems._Cache,_DRAM,_Disk.pdf" target="_blank" rel="noopener">Memory Systems Cache, DRAM, Disk</a> 等</p><ul><li><a href="http://www.cs.helsinki.fi/u/jakangas/Teaching/" target="_blank" rel="noopener">《helsinki:Distributed Systems Course slider》</a></li></ul><p>介绍:来自芬兰赫尔辛基的分布式系统课程课件:什么是分布式,复制,一致性,容错,同步,通信.</p><ul><li><a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">《TiDB is a distributed SQL database》</a></li></ul><p>介绍:分布式数据库TiDB,Golang开发.</p><ul><li><a href="http://people.csail.mit.edu/matei/courses/2015/6.S897/" target="_blank" rel="noopener">《S897: Large-Scale Systems》</a></li></ul><p>介绍:课程资料:大规模系统.</p><ul><li><a href="http://papers.nips.cc/paper/5333-consistency-of-weighted-majority-votes" target="_blank" rel="noopener">《Large-scale L-BFGS using MapReduce》</a></li></ul><p>介绍:使用MapReduce进行大规模分布式集群环境下并行L-BFGS.</p><ul><li><a href="http://www.infoq.com/cn/news/2015/09/BookKeeper-Twitter" target="_blank" rel="noopener">《Twitter是如何构建高性能分布式日志的》</a></li></ul><p>介绍:Twitter是如何构建高性能分布式日志的.</p><ul><li><a href="http://danluu.com/limplock/" target="_blank" rel="noopener">《Distributed Systems: When Limping Hardware Is Worse Than Dead Hardware》</a></li></ul><p>介绍:在分布式系统中某个组件彻底死了影响很小，但半死不活（网络/磁盘），对整个系统却是毁灭性的.</p><ul><li><a href="https://github.com/baidu/tera" target="_blank" rel="noopener">《Tera - 高性能、可伸缩的结构化数据库》</a></li></ul><p>介绍:来自百度的分布式数据库.</p><ul><li><a href="https://github.com/SequoiaDB/SequoiaDB" target="_blank" rel="noopener">《SequoiaDB is a distributed document-oriented NoSQL Database》</a></li></ul><p>介绍:SequoiaDB分布式文档数据库开源.</p><ul><li><a href="http://henryr.github.io/distributed-systems-readings/" target="_blank" rel="noopener">《Readings in distributed systems》</a></li></ul><p>介绍:这个网址里收集了一堆各TOP大学分布式相关的课程.</p><ul><li><a href="https://ramcloud.stanford.edu/~ongaro/userstudy/" target="_blank" rel="noopener">《Paxos vs Raft》</a></li></ul><p>介绍:这个网站是<a href="https://raft.github.io/" target="_blank" rel="noopener">Raft算法</a>的作者为教授Paxos和<a href="https://raft.github.io/" target="_blank" rel="noopener">Raft算法</a>做的，其中有两个视频链接，分别讲上述两个算法.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://www.eecs.harvard.edu/~mema/courses/cs264/papers/p13-ratnasamy.pdf" target="_blank" rel="noopener">《A Scalable Content-Addressable Network》</a></li></ul><p>介绍:A Scalable Content-Addressable Network.</p><ul><li><a href="https://github.com/aosabook/500lines" target="_blank" rel="noopener">《500 Lines or Less》</a></li></ul><p>介绍:这个项目其实是一本书（ <a href="http://aosabook.org/en/index.html" target="_blank" rel="noopener">The Architecture of Open Source Applications</a>）的源代码附录，是一堆大牛合写的.</p><ul><li><a href="http://nil.csail.mit.edu/6.824/2015/schedule.html" target="_blank" rel="noopener">《MIT 6.824 Distributed System》</a></li></ul><p>介绍:这只是一个课程主页，没有上课的视频，但是并不影响你跟着它上课：每一周读两篇课程指定的论文，读完之后看lecture-notes里对该论文内容的讨论，回答里面的问题来加深理解，最后在课程lab里把所看的论文实现。当你把这门课的作业刷完后，你会发现自己实现了一个分布式数据库.</p><ul><li><a href="https://github.com/michaelmaltese/golang-distributed-filesystem" target="_blank" rel="noopener">《HDFS-alike in Go》</a></li></ul><p>介绍:使用go开发的分布式文件系统.</p><ul><li><a href="https://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《What are some good resources for learning about distributed computing? Why?》</a></li></ul><p>介绍:Quora上关于学习分布式的资源问答.</p><ul><li><a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">《SeaweedFS is a simple and highly scalable distributed file system》</a></li></ul><p>介绍:SeaweedFS是使用go开发的分布式文件系统项目,代码简单，逻辑清晰.</p><ul><li><a href="https://github.com/wandoulabs/codis" target="_blank" rel="noopener">《Codis - yet another fast distributed solution for Redis》</a></li></ul><p>介绍:Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 </p><ul><li><a href="http://www.bailis.org/papers/bailis-thesis.pdf" target="_blank" rel="noopener">《Paper: Coordination Avoidance In Distributed Databases By Peter Bailis》</a></li></ul><p>介绍:Coordination Avoidance In Distributed Databases.</p><ul><li><a href="https://github.com/ngaut/builddatabase" target="_blank" rel="noopener">《从零开始写分布式数据库》</a></li></ul><p>介绍:本文以<a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">TiDB</a> 源码为例.</p><ul><li><a href="http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html" target="_blank" rel="noopener">《what we talk about when we talk about distributed systems》</a></li></ul><p>介绍:分布式系统概念梳理,为分布式系统涉及的主要概念进行了梳理.</p><ul><li><a href="http://redis.io/topics/distlock" target="_blank" rel="noopener">《Distributed locks with Redis》</a></li></ul><p>介绍:使用Redis实现分布式锁.</p><ul><li><a href="http://www.scs.stanford.edu/14au-cs244b/" target="_blank" rel="noopener">《CS244b: Distributed Systems》</a></li></ul><p>介绍: 斯坦福2014年秋季分布式课程.</p><ul><li><a href="http://rustyrazorblade.com/2015/11/ramp-made-easy/" target="_blank" rel="noopener">《RAMP Made Easy》</a></li></ul><p>介绍: 分布式的“读原子性”.</p><ul><li><a href="http://arxiv.org/abs/1512.09295" target="_blank" rel="noopener">《Strategies and Principles of Distributed Machine Learning on Big Data》</a></li></ul><p>介绍: 大数据分布式机器学习的策略与原理.</p><ul><li><a href="https://www.quora.com/Distributed-Systems/What-is-the-CAP-theorem" target="_blank" rel="noopener">《Distributed Systems: What is the CAP theorem?》</a></li></ul><p>介绍: 分布式CAP法则.</p><ul><li><a href="https://www.quora.com/How-should-I-start-to-learn-distributed-storage-system-as-a-beginner" target="_blank" rel="noopener">《How should I start to learn distributed storage system as a beginner?》</a></li></ul><p>介绍: 新手如何步入分布式存储系统.</p><ul><li><a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf" target="_blank" rel="noopener">《Cassandra - A Decentralized Structured Storage System》</a></li></ul><p>介绍: 分布式存储系统Cassandra剖析,推荐白皮书<a href="http://www.datastax.com/wp-content/uploads/2012/08/WP-IntrotoCassandra.pdf" target="_blank" rel="noopener">Introduction to Apache Cassandra</a>.</p><ul><li><a href="https://www.quora.com/What-is-the-best-resource-to-learn-about-distributed-systems" target="_blank" rel="noopener">《What is the best resource to learn about distributed systems?》</a></li></ul><p>介绍: 分布式系统学习资源.</p><ul><li><a href="https://www.quora.com/What-are-some-high-performance-TCP-hacks" target="_blank" rel="noopener">《What are some high performance TCP hacks?》</a></li></ul><p>介绍: 一些高性能TCP黑客技巧.</p><ul><li><a href="https://speakerdeck.com/elasticsearch/maintaining-performance-in-distributed-systems" target="_blank" rel="noopener">《Maintaining performance in distributed systems》</a></li></ul><p>介绍:分布式系统性能提升.</p><ul><li><a href="http://diyhpl.us/~bryan/papers2/distributed/distributed-systems/zab.totally-ordered-broadcast-protocol.2008.pdf" target="_blank" rel="noopener">《A simple totally ordered broadcast protocol》</a></li></ul><p>介绍:Benjamin Reed 和 Flavio P.Junqueira 所著论文,对Zab算法进行了介绍,zab算法是Zookeeper保持数据一致性的核心,在国内有很多公司都使用zookeeper做为分布式的解决方案.推荐与此相关的一篇文章<a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf" target="_blank" rel="noopener">ZooKeeper’s atomic broadcast protocol: Theory and practice</a>.</p><ul><li><a href="http://storageconference.us/2003/papers/29-Rodeh-zFS.pdf" target="_blank" rel="noopener">《zFS - A Scalable Distributed File System Using Object Disk》</a></li></ul><p>介绍:可扩展的分布式文件系统ZFS,<a href="https://users.soe.ucsc.edu/~scott/courses/Fall04/221/zfs_overview.pdf" target="_blank" rel="noopener">The Zettabyte File System</a>,<a href="http://research.cs.wisc.edu/adsl/Publications/zfs-corruption-fast10.pdf" target="_blank" rel="noopener">End-to-end Data Integrity for File Systems: A ZFS Case Study</a>.</p><ul><li><a href="http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html" target="_blank" rel="noopener">《A Distributed Haskell for the Modern Web》</a></li></ul><p>介绍:分布式Haskell在当前web中的应用.</p><ul><li><a href="https://pages.lip6.fr/Marc.Shapiro/papers/CISE-POPL-2016.pdf" target="_blank" rel="noopener">《Reasoning about Consistency Choices in Distributed Systems》</a></li></ul><p>介绍:POPL2016的论文,关于分布式系统一致性选择的论述,<a href="http://conf.researchr.org/track/POPL-2016/POPL-2016-papers#event-overview" target="_blank" rel="noopener">POPL所接受的论文</a>,github上已经有人<a href="https://github.com/gasche/popl2016-papers" target="_blank" rel="noopener">整理</a>.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a></li></ul><p>介绍:Paxos让分布式更简单.<a href="http://dsdoc.net/paxosmadesimple/index.html" target="_blank" rel="noopener">译文</a>.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a>,<a href="https://distributedthoughts.wordpress.com/2013/09/22/understanding-paxos-part-1/" target="_blank" rel="noopener">understanding Paxos part1</a>,<a href="https://distributedthoughts.wordpress.com/2013/09/30/understanding-paxos-part-2/" target="_blank" rel="noopener">Understanding Paxos – Part 2</a>.<a href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm" target="_blank" rel="noopener">Quora: What is a simple explanation of the Paxos algorithm?</a>,<a href="http://www.ux.uis.no/~meling/papers/2013-paxostutorial-opodis.pdf" target="_blank" rel="noopener">Tutorial Summary: Paxos Explained from Scratch</a>,<a href="http://bogdan.pistol.gg/2014/04/30/paxos-algorithm-explained-part-1-the-essentials/" target="_blank" rel="noopener">Paxos algorithm explained, part 1: The essentials</a>,<a href="http://bogdan.pistol.gg/2014/10/20/paxos-algorithm-explained-part-2-insights/" target="_blank" rel="noopener">Paxos algorithm explained, part 2: Insights</a></p><ul><li><a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="noopener">《Consensus Protocols: Paxos》</a></li></ul><p>介绍:分布式系统一致性协议:Paxos.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://research.microsoft.com/pubs/64636/tr-2003-96.pdf" target="_blank" rel="noopener">《Consensus on Transaction Commit》</a></li></ul><p>介绍：事务提交的一致性探讨.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">《The Part-Time Parliaments》</a></li></ul><p>介绍:在《The Part-Time Parliament》中描述了基本协议的交互过程。在基本协议的基础上完善各种问题得到了最终的议会协议。 为了让人更容易理解《The Part-Time Parliament》中描述的Paxos算法，Lamport在2001发表了<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a>，以更平直的口头语言描述了Paxos，而没有包含正式的证明和数学术语。<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a>中，将算法的参与者更细致的划分成了几个角色：Proposer、Acceptor、Learner。另外还有Leader和Client.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="https://pdos.csail.mit.edu/archive/6.824-2007/papers/mazieres-paxos.pdf" target="_blank" rel="noopener">《Paxos Made Practical》</a></li></ul><p>介绍:看这篇论文时可以先看看<a href="http://blog.csdn.net/bluecloudmatrix/article/details/41138363" target="_blank" rel="noopener">理解Paxos Made Practical</a>.</p><ul><li><a href="http://arxiv.org/pdf/1209.4187.pdf" target="_blank" rel="noopener">《PaxosLease: Diskless Paxos for Leases》</a></li></ul><p>介绍：PaxosLease：实现租约的无盘Paxos算法,<a href="http://dsdoc.net/paxoslease/index.html" target="_blank" rel="noopener">译文</a>.</p><ul><li><a href="https://people.csail.mit.edu/matei/courses/2015/6.S897/readings/paxos-moderately-complex.pdf" target="_blank" rel="noopener">《Paxos Made Moderately Complex》</a></li></ul><p>介绍：<a href="http://paxos.systems/" target="_blank" rel="noopener">Paxos算法</a>实现,<a href="http://dsdoc.net/paxosmademoderatelycomplex/index.html" target="_blank" rel="noopener">译文</a>,同时推荐<a href="http://www.cs.cornell.edu/courses/cs7412/2011sp/paxos.pdf" target="_blank" rel="noopener">42 Paxos Made Moderately Complex</a>.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/7097176720119791920962/" target="_blank" rel="noopener">《Hadoop Reading List》</a></li></ul><p>介绍：Hadoop学习清单.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/7097176720119791920962/" target="_blank" rel="noopener">《Hadoop Reading List》</a></li></ul><p>介绍：Hadoop学习清单.</p><ul><li><a href="http://www.empiricalreality.com/2010/09/22/2010-nosql-summer-reading-list/" target="_blank" rel="noopener">《2010 NoSQL Summer Reading List》</a></li></ul><p>介绍：NoSQL知识清单,里面不仅仅包含了数据库阅读清单还包含了分布式系统资料.</p><ul><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">《Raft: Understandable Distributed Consensus》</a></li></ul><p>介绍：Raft可视化图帮助理解分布式一致性</p><ul><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">《Etcd:Distributed reliable key-value store for the most critical data of a distributed system》</a></li></ul><p>介绍：Etcd分布式Key-Value存储引擎</p><ul><li><a href="http://sysnet.ucsd.edu/recall/papers/iptps.pdf" target="_blank" rel="noopener">《Understanding Availability》</a></li></ul><p>介绍：理解peer-to-peer系统中的可用性究竟是指什么.同时推荐<a href="http://www.jos.org.cn/1000-9825/15/268.pdf" target="_blank" rel="noopener">基于 Peer-to-Peer 的分布式存储系统的设计</a></p><ul><li><a href="http://courses.cs.vt.edu/~cs5204/fall07-kafura/Papers/TransactionalMemory/Lomet.pdf" target="_blank" rel="noopener">《Process structuring, synchronization, and recovery using atomic actions》</a></li></ul><p>介绍：经典论文</p><ul><li><a href="http://www.eng.auburn.edu/files/file1358.pdf" target="_blank" rel="noopener">《Programming Languages for Parallel Processing》</a></li></ul><p>介绍：并行处理的编程语音</p><ul><li><a href="https://hal.inria.fr/hal-00789086/file/a_survey_of_dfs.pdf" target="_blank" rel="noopener">《Analysis of Six Distributed File Systems》</a></li></ul><p>介绍：此篇论文对HDFS,MooseFS,iRODS,Ceph,GlusterFS,Lustre六个存储系统做了详细分析.如果是自己研发对应的存储系统推荐先阅读此篇论文</p><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=A106388C6F04609BCA27DE6DF9C917A6?doi=10.1.1.35.4793&rep=rep1&type=pdf" target="_blank" rel="noopener">《A Survey of Distributed File Systems》</a></li></ul><p>介绍：分布式文件系统综述</p><ul><li><a href="ftp://ftp.sei.cmu.edu/pub/education/cm24.pdf" target="_blank" rel="noopener">《Concepts of Concurrent Programming》</a></li></ul><p>介绍：并行编程的概念,同时推荐<a href="ftp://ftp.sei.cmu.edu/pub/education/" target="_blank" rel="noopener">卡内基梅隆FTP</a></p><ul><li><a href="https://www.cs.berkeley.edu/~brewer/cs262/ConcControl.pdf" target="_blank" rel="noopener">《Concurrency Control Performance Modeling:Alternatives and Implications》</a></li></ul><p>介绍：并发控制性能建模：选择与意义</p><ul><li><a href="https://azmuri.files.wordpress.com/2013/09/george-coulouris-distributed-systems-concepts-and-design-5th-edition.pdf" target="_blank" rel="noopener">《Distributed Systems - Concepts and Design 5th Edition》</a></li></ul><p>介绍：ebook分布式系统概念与设计</p><ul><li><a href="http://read.pudn.com/downloads51/ebook/174460/03.pdf" target="_blank" rel="noopener">《分布式系统设计的形式方法》</a></li></ul><p>介绍：分布式系统设计的形式方法</p><ul><li><a href="http://read.pudn.com/downloads51/ebook/174460/04.pdf" target="_blank" rel="noopener">《互斥和选举算法》</a></li></ul><p>介绍：互斥和选举算法</p><ul><li><a href="https://www.cypherpunks.to/erights/history/actors/AITR-844.pdf" target="_blank" rel="noopener">《Actors：A model Of Concurrent Cornputation In Distributed Systems》</a></li></ul><p>介绍：经典论文</p><ul><li><a href="https://www.cl.cam.ac.uk/~rja14/Papers/" target="_blank" rel="noopener">《Security Engineering: A Guide to Building Dependable Distributed Systems》</a></li></ul><p>介绍：如何构建一个安全可靠的分布式系统,<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-acks.pdf" target="_blank" rel="noopener">About the Author</a>,<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-biblio.pdf" target="_blank" rel="noopener">Bibliography:文献资料</a>,章节访问把<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-c01.pdf" target="_blank" rel="noopener">链接</a>最后的01换成01-27即可</p><ul><li><a href="https://www.cs.cmu.edu/~15712/index.html" target="_blank" rel="noopener">《15-712 Advanced and Distributed Operating Systems》</a></li></ul><p>介绍：卡内基梅隆大学的分布式系统博士生课程主页,有很丰富的<a href="https://www.cs.cmu.edu/~15712/syllabus.html" target="_blank" rel="noopener">资料</a></p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf" target="_blank" rel="noopener">《Dapper, Google’s Large-Scale Distributed Systems Tracing Infrastructure》</a></li></ul><p>介绍：Dapper，大规模分布式系统的跟踪系统,<a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">译文</a>,<a href="http://dirlt.com/dapper.html" target="_blank" rel="noopener">译文对照</a></p><ul><li><a href="http://www.cs.berkeley.edu/~brewer/cs262/" target="_blank" rel="noopener">《CS262a: Advanced Topics in Computer Systems》</a></li></ul><p>介绍：伯克利大学计算机系统进阶课程,内容有深度,涵盖分布式,数据库等内容</p><ul><li><a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="noopener">《Egnyte Architecture: Lessons Learned In Building And Scaling A Multi Petabyte Distributed System》</a></li></ul><p>介绍：PB级分布式系统构建/扩展经验</p><ul><li><a href="https://cs162.eecs.berkeley.edu/" target="_blank" rel="noopener">《CS162: Operating Systems and Systems Programming》</a></li></ul><p>介绍：伯克利大学计算机系统课程:操作系统与系统编程</p><ul><li><a href="http://mdcc.cs.berkeley.edu/" target="_blank" rel="noopener">《MDCC: Multi-Data Center Consistency》</a></li></ul><p>介绍：MDCC主要解决跨数据中心的一致性问题中间件,一种新的协议</p><ul><li><a href="http://research.google.com/pubs/DistributedSystemsandParallelComputing.html" target="_blank" rel="noopener">《Research at Google:Distributed Systems and Parallel Computing》</a></li></ul><p>介绍：google公开对外发表的分布式系统与并行计算论文</p><ul><li><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html" target="_blank" rel="noopener">《HDFS Architecture Guide》</a></li></ul><p>介绍：分布式文件系统HDFS架构</p><ul><li><a href="http://www.actordb.com/index.html" target="_blank" rel="noopener">《ActorDB distributed SQL database》</a></li></ul><p>介绍：分布式 Key/Value数据库</p><ul><li><a href="http://csc.lsu.edu/~gb/csc7700/Reading/SC03_tang.pdf" target="_blank" rel="noopener">《An efficient data location protocol for self-organizing storage clusters》</a></li></ul><p>介绍：是著名的<a href="https://github.com/ceph/ceph" target="_blank" rel="noopener">Ceph</a>的负载平衡策略，文中提出的几种策略都值得尝试，比较赞的一点是可以对照代码体会和实践,如果你还需要了解可以看看<a href="https://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="noopener">Ceph:一个 Linux PB 级分布式文件系统</a>,除此以外,论文的引用部分也挺值得阅读的,同时推荐<a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="noopener">Ceph: A Scalable, High-Performance Distributed File System</a></p><ul><li><a href="http://www.supercomputing.org/sc2004/schedule/pdfs/pap283.pdf" target="_blank" rel="noopener">《A Self-Organizing Storage Cluster for Parallel Data-Intensive Applications》</a></li></ul><p>介绍：Surrento的冷热平衡策略就采用了延迟写技术</p><ul><li><a href="http://www.sersc.org/journals/IJAST/vol36/4.pdf" target="_blank" rel="noopener">《HBA: Distributed Metadata Management for Large Cluster-Based Storage Systems》</a></li></ul><p>介绍：对于分布式存储系统的元数据管理.</p><ul><li><a href="http://www.mcs.anl.gov/~thakur/papers/sc11-io.pdf" target="_blank" rel="noopener">《Server-Side I/O Coordination for Parallel File Systems》</a></li></ul><p>介绍：服务器端的I/O协调并行文件系统处理,网络,文件存储等都会涉及到IO操作.不过里面涉及到很多技巧性的思路在实践时需要斟酌</p><ul><li><a href="http://www.cs.virginia.edu/~zaher/classes/CS656/levy.pdf" target="_blank" rel="noopener">《Distributed File Systems: Concepts and Examples》</a></li></ul><p>介绍：分布式文件系统概念与应用</p><ul><li><a href="http://cseweb.ucsd.edu/classes/wi08/cse221/" target="_blank" rel="noopener">《CSE 221: Graduate Operating Systems》</a></li></ul><p>介绍：加利福尼亚大学的研究生操作系统课程主页，论文很值得阅读</p><ul><li><a href="http://cs.brown.edu/~debrabant/cis570-website/papers/s4.pdf" target="_blank" rel="noopener">《S4: Distributed Stream Computing Platform》</a></li></ul><p>介绍：Yahoo出品的流式计算系统，目前最流行的两大流式计算系统之一（另一个是storm），Yahoo的主要广告计算平台</p><ul><li><a href="https://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank" rel="noopener">《Pregel: a system for large-scale graph processing》</a></li></ul><p>介绍：Google的大规模图计算系统，相当长一段时间是Google PageRank的主要计算系统，对开源的影响也很大（包括GraphLab和GraphChi）</p><ul><li><a href="http://www.select.cs.cmu.edu/publications/paperdir/uai2010-low-gonzalez-kyrola-bickson-guestrin-hellerstein.pdf" target="_blank" rel="noopener">《GraphLab: A New Framework for Parallel Machine Learning》</a></li></ul><p>介绍：CMU基于图计算的分布式机器学习框架，目前已经成立了专门的商业公司，在分布式机器学习上很有两把刷子，其单机版的GraphChi在百万维度的矩阵分解都只需要2~3分钟；</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41344.pdf" target="_blank" rel="noopener">《F1: A Distributed SQL Database That Scales》</a></li></ul><p>介绍：这篇论文是Google 2013年发表的，介绍了F1的架构思路，13年时就开始支撑Google的AdWords业务，另外两篇介绍文章<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/38125.pdf" target="_blank" rel="noopener">F1 - The Fault-Tolerant Distributed RDBMS Supporting Google’s Ad Business </a>.<a href="http://www.leafonsword.org/google-f1/" target="_blank" rel="noopener">Google NewSQL之F1</a></p><ul><li><a href="https://github.com/cockroachdb/cockroach" target="_blank" rel="noopener">《Cockroach DB:A Scalable, Survivable, Strongly-Consistent SQL Database》</a></li></ul><p>介绍：CockroachDB ：一个可伸缩的、跨地域复制的，且支持事务的数据存储,<a href="http://www.infoq.com/cn/news/2014/08/CockroachDB" target="_blank" rel="noopener">InfoQ介绍</a>,<a href="https://www.gitbook.com/book/smazumder05/design-and-architecture-of-cockroachdb/details" target="_blank" rel="noopener">Design and Architecture of CockroachDb</a></p><ul><li><a href="ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF" target="_blank" rel="noopener">《Multi-Paxos: An Implementation and Evaluation》</a></li></ul><p>介绍：Multi-Paxos实现与总结，此外推荐<a href="https://github.com/cocagne/multi-paxos-example" target="_blank" rel="noopener">Paxos/Multi-paxos Algorithm</a>,<a href="https://github.com/cocagne/multi-paxos-example" target="_blank" rel="noopener">Multi-Paxos Example</a>，地址:<a href="ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF" target="_blank" rel="noopener">ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF</a></p><ul><li><a href="http://web.stanford.edu/class/cs347/reading/zab.pdf" target="_blank" rel="noopener">《Zab: High-performance broadcast for primary-backup systems》</a></li></ul><p>介绍：一致性协议zab分析</p><ul><li><a href="https://pdos.csail.mit.edu/papers/fdabek-phd-thesis.pdf" target="_blank" rel="noopener">《A Distributed Hash Table》</a></li></ul><p>介绍：分布式哈希算法论文,扩展阅读<a href="https://www.ietf.org/proceedings/65/slides/plenaryt-2.pdf" target="_blank" rel="noopener">Introduction to Distributed Hash Tables</a>,<a href="https://www.cs.cmu.edu/~dga/15-744/S07/lectures/16-dht.pdf" target="_blank" rel="noopener">Distributed Hash Tables</a></p><ul><li><a href="http://www.news.cs.nyu.edu/~jinyang/pub/iptps04.pdf" target="_blank" rel="noopener">《Comparing the performance of distributed hash tables under churn》</a></li></ul><p>介绍：分布式hash表性能的Churn问题</p><ul><li><a href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf" target="_blank" rel="noopener">《Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web》</a></li></ul><p>介绍：分布式系统的CAP问题,推荐<a href="https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf" target="_blank" rel="noopener">Perspectives on the CAP Theorem</a>.对CAP理论的解析文章,<a href="http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf" target="_blank" rel="noopener">PODC ppt</a>,<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">A plain english introduction to CAP Theorem</a>,<a href="http://dbmsmusings.blogspot.kr/2012/10/ieee-computer-issue-on-cap-theorem.html" target="_blank" rel="noopener">IEEE Computer issue on the CAP Theorem</a></p><ul><li><a href="https://www.usenix.org/system/files/conference/fast15/fast15-paper-lee.pdf" target="_blank" rel="noopener">《F2FS: A New File System for Flash Storage》</a></li></ul><p>介绍：闪存存储文件系统F2FS</p><ul><li><a href="http://research.microsoft.com/pubs/81175/BPFS.pdf" target="_blank" rel="noopener">《Better I/O Through Byte-Addressable, Persistent Memory》</a></li></ul><p>介绍：微软发表的关于i/o访问优化论文</p><ul><li><a href="http://www.solarisinternals.com/si/reading/tmpfs.pdf" target="_blank" rel="noopener">《tmpfs: A Virtual Memory File System》</a></li></ul><p>介绍：虚拟内存文件系统tmpfs</p><ul><li><a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/6E1C5B6A1B6EDD9885257A38006B6130/$File/rj10501.pdf" target="_blank" rel="noopener">《BTRFS: The Linux B-tree Filesystem》</a></li></ul><p>介绍：Linux B-tree文件系统.</p><ul><li><a href="https://www.akamai.com/us/en/our-thinking/technical-publications.jsp" target="_blank" rel="noopener">《Akamai technical publication》</a></li></ul><p>介绍：Akamai是全球最大的云计算机平台之一，承载了全球15-30%网络流量,如果你是做CDN或者是云服务,这个里面的论文会给你很有帮助.例如这几天看facebook开源的<a href="https://osquery.io/" target="_blank" rel="noopener">osquery</a>。找到通过db的方式运维,找到<a href="https://www.akamai.com/es/es/multimedia/documents/technical-publication/keeping-track-of-70000-servers-the-akamai-query-system-technical-publication.pdf" target="_blank" rel="noopener">Keeping Track of 70,000+ Servers: The Akamai Query System</a>这篇论文，先看论文领会思想，然后再使用工具osquery实践</p><ul><li><a href="http://dl.acm.org/citation.cfm?id=1394128" target="_blank" rel="noopener">《BASE: An Acid Alternative》</a></li></ul><p>介绍：来自eBay 的解决方案,译文<a href="http://article.yeeyan.org/view/167444/125572" target="_blank" rel="noopener">Base: 一种Acid的替代方案</a>,应用案例参考<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653546976&idx=1&sn=c3fb2338389a41e7ab998c0c21bd3e5d" target="_blank" rel="noopener">保证分布式系统数据一致性的6种方案</a></p><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=CF3CA7E7B62091EB266A1543A6F2D26A?doi=10.1.1.41.7628&rep=rep1&type=pdf" target="_blank" rel="noopener">《A Note on Distributed Computing》</a></li></ul><p>介绍：Jim Waldo和Sam Kendall等人共同撰写了一篇非常有名的论文“分布式计算备忘录”，这篇论文在Reddit上被人推荐为“每个程序员都应当至少读上两篇”的论文。在这篇论文中，作者表示“忽略本地计算与分布式计算之间的区别是一种危险的思想”，特别指出了Emerald、Argus、DCOM以及CORBA的设计问题。作者将这些设计问题归纳为“三个错误的原则”： “对于某个应用来说，无论它的部署环境如何，总有一种单一的、自然的面向对象设计可以符合其需求。” “故障与性能问题与某个应用的组件实现直接相关，在最初的设计中无需考虑这些问题。” “对象的接口与使用对象的上下文无关”.</p><ul><li><a href="https://github.com/papers-we-love/papers-we-love/tree/master/distributed_systems" target="_blank" rel="noopener">《Distributed Systems Papers》</a></li></ul><p>介绍：分布式系统领域经典论文列表.</p><ul><li><a href="https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf" target="_blank" rel="noopener">《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》</a></li></ul><p>介绍：Consistent Hashing算法描述.</p><ul><li><a href="http://sigmod2016.org/pods_list.shtml" target="_blank" rel="noopener">《SIGMOD 2016: Accepted Research Papers》</a></li></ul><p>介绍：SIGMOD是世界上最有名的数据库会议之一,最具有权威性,收录论文审核非常严格.2016年的SIGMOD 会议照常进行,上面收录了今年SIGMOD收录的论文,把题目输入google中加上pdf就能找到,很多论文值得阅读,<a href="http://sigmod2015.org/pods_list.shtml" target="_blank" rel="noopener">SIGMOD 2015</a></p><ul><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf" target="_blank" rel="noopener">《Notes on CPSC 465/565: Theory of Distributed Systems》</a></li></ul><p>介绍:耶鲁大学的分布式系统理论课程笔记</p><ul><li><a href="http://listpdf.com/di/distributed-operating-system-doc-pdf.html" target="_blank" rel="noopener">《Distributed Operating System Doc PDF》</a></li></ul><p>介绍:分布式系统文档资源（可下载）</p><ul><li><a href="https://mitpress.mit.edu/sites/default/files/titles/content/9780262693141_sch_0002.pdf" target="_blank" rel="noopener">《Anatomy of a database system》</a></li></ul><p>介绍:数据库系统剖析，这本书是由伯克利大学的<a href="http://db.cs.berkeley.edu/jmh/" target="_blank" rel="noopener">Joseph M. Hellerstein</a>和M. Stonebraker合著的一篇论文.对数据库剖析很有深度.除此以外还有一篇文章<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="noopener">Architecture of a Database System</a>。数据库系统架构,厦门大学的数据库实验室教授林子雨组织过<a href="http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System(Chinese%20Version)-ALL.pdf" target="_blank" rel="noopener">翻译</a></p><ul><li><a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_blank" rel="noopener">《A Relational Model of Data for Large Shared Data Banks》</a></li></ul><p>介绍:数据库关系模型论文</p><ul><li><a href="http://idke.ruc.edu.cn/reading/index.htm" target="_blank" rel="noopener">《RUC Innovative data systems reaserch lab recommand papers》</a></li></ul><p>介绍:中国人民大学数据研究实验室推荐的数据库领域论文</p><ul><li><a href="http://www.cs.utexas.edu/~dahlin/projects/sdims/papers/sdims-sigcomm.pdf" target="_blank" rel="noopener">《A Scalable Distributed Information Management System》</a></li></ul><p>介绍:构建可扩展的分布式信息管理系统</p><ul><li><a href="http://yager.io/Distributed/Distributed.html" target="_blank" rel="noopener">《Distributed Systems in Haskell》</a></li></ul><p>介绍:Haskell中的分布式系统开发</p><ul><li><a href="research.google.com/pubs/archive/43438.pdf">《Large-scale cluster management at Google with Borg》</a></li></ul><p>介绍:Google使用Borg进行大规模集群的管理,<a href="http://people.eecs.berkeley.edu/~istoica/classes/cs294/15/notes/09-borg.pdf" target="_blank" rel="noopener">伯克利大学ppt介绍</a>,<a href="http://my.oschina.net/HardySimpson/blog?search=Borg" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://www.yebangyu.org/LockFreeProgrammingPractice.pdf" target="_blank" rel="noopener">《Lock Free Programming Practice》</a></li></ul><p>介绍:并发编程（Concurrency Programming）资料,主要涵盖lock free数据结构实现、内存回收方法、memory model等<a href="http://pan.baidu.com/s/1sleTpgT" target="_blank" rel="noopener">备份链接</a> 密码: xc5j</p><ul><li><a href="http://read.pudn.com/downloads95/ebook/386159/Distributed.Algorithms.pdf" target="_blank" rel="noopener">《Distributed Algorithms Lecture Notes for 6.852》</a></li></ul><p>介绍:Nancy Lynch’s的分布式算法研究生课程讲义</p><ul><li><a href="http://www.jmlr.org/papers/volume10/newman09a/newman09a.pdf" target="_blank" rel="noopener">《Distributed Algorithms for Topic Models》</a></li></ul><p>介绍:分布式算法主题模型.</p><ul><li><a href="https://recsys.acm.org/" target="_blank" rel="noopener">《RecSys - ACM Recommender Systems》</a></li></ul><p>介绍:世界上非常有名的推荐系统会议，我比较推荐接收的<a href="https://recsys.acm.org/recsys16/accepted-contributions" target="_blank" rel="noopener">PAPER</a></p><ul><li><a href="http://www.allthingsdistributed.com/" target="_blank" rel="noopener">《All Things Distributed》</a></li></ul><p>介绍:推荐一个博客,博主是Amazon CTO Werner Vogels,这是一个关注分布式领域的博客.大部分博文是关于在工业界应用.</p><ul><li><a href="https://github.com/hedengcheng/tech" target="_blank" rel="noopener">《programming, database, distributed system resource list》</a></li></ul><p>介绍:这个Git是由阿里(alibaba)的技术专家何登成维护,主要是分布式数据库.</p><ul><li><a href="http://erlang.org/download/armstrong_thesis_2003.pdf" target="_blank" rel="noopener">《Making reliable distributed systems in the presence of sodware errors》</a></li></ul><p>介绍:Erlang的作者<a href="http://joearms.github.io/" target="_blank" rel="noopener">Joe Armstrong</a>撰写的论文，面对软件错误构建可靠的分布式系统.<a href="http://open.qiniudn.com/[Joe-Armstrong][CN]Making-reliable-distributed-systems-in-the-presence-of-software-errors.pdf" target="_blank" rel="noopener">中文译版</a></p><ul><li><a href="https://courses.engr.illinois.edu/cs525/sched.htm" target="_blank" rel="noopener">《CS 525: Advanced Distributed Systems[Spring 2016]》</a></li></ul><p>介绍:伊利诺伊大学的Advanced Distributed Systems 里把各个方向重要papers（updated Spring 2015）列举出来，可以参考一下</p><ul><li><a href="https://users.ics.aalto.fi/suomela/da/da-screen.pdf" target="_blank" rel="noopener">《Distributed Algorithms》</a></li></ul><p>介绍:这是一本分布式算法电子书,作者是<a href="https://users.ics.aalto.fi/suomela/da/" target="_blank" rel="noopener">Jukka Suomela</a>.讲述了多个计算模型,一致性,唯一标示,并发等.</p><ul><li><a href="https://arxiv.org/pdf/1512.00727v2.pdf" target="_blank" rel="noopener">《TinyLFU: A Highly Efficient Cache Admission Policy》</a></li></ul><p>介绍:当时是在阅读<a href="http://blog.gainlo.co/index.php/2016/05/17/design-a-cache-system/" target="_blank" rel="noopener">如何设计一个缓存系统</a>时看到的，然后通过Google找到了这一篇关于缓存策略的论文，它是LFU的改良版,中文<a href="http://chuansong.me/n/2254051" target="_blank" rel="noopener">介绍</a>.如果有兴趣可以看看<a href="https://github.com/dgryski/go-tinylfu" target="_blank" rel="noopener">Golang实现版</a>。结合起来可能会帮助你理解</p><ul><li><a href="https://cs.stanford.edu/~matei/courses/2015/6.S897/" target="_blank" rel="noopener">《6.S897: Large-Scale Systems》</a></li></ul><p>介绍:斯坦福大学给研究生开的分布式系统课程。教师是 spark 作者 matei. 能把这些内容真正理解透，分布式系统的功力就很强了。</p><ul><li><a href="https://www.zhihu.com/question/23645117/answer/124708083" target="_blank" rel="noopener">《学习分布式系统需要怎样的知识？》</a></li></ul><p>介绍:[怎么学系列]学习分布式系统需要怎样的知识？</p><ul><li><a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="noopener">《Distributed systems theory for the distributed systems engineer》</a></li></ul><p>介绍:分布式系统工程师的分布式系统理论</p><ul><li><a href="https://dancres.github.io/Pages/" target="_blank" rel="noopener">《A Distributed Systems Reading List》</a></li></ul><p>介绍:分布式系统论文阅读列表,此外推荐威斯康星大学麦迪逊分校计算机系分布式系统学习推荐<a href="http://pages.cs.wisc.edu/~swift/classes/cs739-fa14/wiki/pmwiki.php/Main/ReadingList" target="_blank" rel="noopener">阅读列表</a></p><ul><li><a href="http://dsrg.pdos.csail.mit.edu/papers/" target="_blank" rel="noopener">《Distributed Systems Reading Group》</a></li></ul><p>介绍:麻省理工大学分布式系统小组，他们会把平时阅读到的优秀论文分享出来。虽然有些论文本页已经收录，但是里面的安排表<a href="http://dsrg.pdos.csail.mit.edu/schedule/" target="_blank" rel="noopener">schedule</a>还是挺赞的</p><ul><li><a href="https://github.com/Developer-Y/Scalable-Software-Architecture" target="_blank" rel="noopener">《Scalable Software Architecture》</a></li></ul><p>介绍:分布式系统、可扩展性与系统设计相关报告、论文与网络资源汇总.</p><ul><li><a href="http://barbie.uta.edu/~jli/Resources/MapReduce&Hadoop/" target="_blank" rel="noopener">《MapReduce&amp;Hadoop resource》</a></li></ul><p>介绍:MapReduce&amp;Hadoop相关论文，涉及分布式系统设计，性能分析，实践，优化等多个方面</p><ul><li><a href="https://vowi.fsinf.at/images/b/bc/TU_Wien-Verteilte_Systeme_VO_(G%C3%B6schka)_-_Tannenbaum-distributed_systems_principles_and_paradigms_2nd_edition.pdf" target="_blank" rel="noopener">《Distributed Systems: Principles and Paradigms(second edtion)》</a></li></ul><p>介绍:分布式系统原理与范型第二版,<a href="http://barbie.uta.edu/~jli/Resources/MapReduce&Hadoop/distributed%20systems%20principles%20and%20paradigms%20solution.pdf" target="_blank" rel="noopener">课后解答</a></p><ul><li><a href="http://muratbuffalo.blogspot.jp/2016/11/my-distributed-systems-seminars-reading.html" target="_blank" rel="noopener">《Distributed Systems Seminar’s reading list for Spring 2017》</a></li></ul><p>介绍:分布式系统研讨会论文阅读列表</p><ul><li><a href="https://arxiv.org/abs/1509.05393" target="_blank" rel="noopener">《A Critique of the CAP Theorem》</a></li></ul><p>介绍:这是一篇评论CAP定理的论文，学习CAP很有帮助,推荐阅读评论文章<a href="https://jvns.ca/blog/2016/11/19/a-critique-of-the-cap-theorem/" target="_blank" rel="noopener">“A Critique of the CAP Theorem”</a></p><ul><li><a href="http://olivergierke.de/2016/10/evolving-distributed-systems/" target="_blank" rel="noopener">《Evolving Distributed Systems》</a></li></ul><p>介绍:推荐文章《不断演进的分布式系统》.</p><ul><li><a href="https://news.ycombinator.com/item?id=13311124" target="_blank" rel="noopener">《Ask HN: Recommendations for a book on Distributed Systems?》</a></li></ul><p>介绍:HN上面关于分布式系统相关领域学习的书籍推荐.</p><ul><li><a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">《SeaweedFS:A simple and highly scalable distributed file system》</a></li></ul><p>介绍:Golang开源项目,分布式文件存储系统SeaweedFS</p><ul><li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf" target="_blank" rel="noopener">《The Design and Implementation of a Log-Structured File System》</a></li></ul><p>介绍:论文推荐:设计并实现一个日志结构的文件系统.</p><p><strong>原文链接：<a href="https://raw.githubusercontent.com/ty4z2008/Qix/master/ds.md" target="_blank" rel="noopener">https://raw.githubusercontent.com/ty4z2008/Qix/master/ds.md</a></strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式系统资料大全，enjoy！&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="资料大全" scheme="http://linbingdong.com/tags/%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch &amp;&amp; CyclicBarrier example</title>
    <link href="http://linbingdong.com/2017/04/05/CountDownLatch%20&amp;&amp;%20CyclicBarrier%20example/"/>
    <id>http://linbingdong.com/2017/04/05/CountDownLatch &amp;&amp; CyclicBarrier example/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2017-09-03T02:16:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch &amp;&amp; CyclicBarrier example</p><a id="more"></a><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lbd.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker(<span class="string">"worker1"</span>, latch);</span><br><span class="line">        Worker w2 = <span class="keyword">new</span> Worker(<span class="string">"worker2"</span>, latch);</span><br><span class="line">        Worker w3 = <span class="keyword">new</span> Worker(<span class="string">"worker3"</span>, latch);</span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(latch);</span><br><span class="line"></span><br><span class="line">        executor.execute(w1);</span><br><span class="line">        executor.execute(w2);</span><br><span class="line">        executor.execute(w3);</span><br><span class="line">        executor.execute(boss);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch downLatch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, CountDownLatch downLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" is working..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" is done!"</span>);</span><br><span class="line">        downLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch downLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(CountDownLatch downLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boss is waiting for all workers..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            downLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"all work is done! Boss gonna check"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">worker1 is working...</span><br><span class="line">worker2 is working...</span><br><span class="line">worker3 is working...</span><br><span class="line">boss is waiting <span class="keyword">for</span> all workers...</span><br><span class="line">worker2 is done!</span><br><span class="line">worker3 is done!</span><br><span class="line">worker1 is done!</span><br><span class="line">all work is done! Boss gonna check</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lbd.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">        Worker1 w1 = <span class="keyword">new</span> Worker1(<span class="string">"worker1"</span>, barrier);</span><br><span class="line">        Worker1 w2 = <span class="keyword">new</span> Worker1(<span class="string">"worker2"</span>, barrier);</span><br><span class="line">        Worker1 w3 = <span class="keyword">new</span> Worker1(<span class="string">"worker3"</span>, barrier);</span><br><span class="line">        executor.execute(w1);</span><br><span class="line">        executor.execute(w2);</span><br><span class="line">        executor.execute(w3);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker1</span><span class="params">(String name, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(barrier.getNumberWaiting() + <span class="string">" worker arrived"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" arrived"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"all arrived,star working!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> worker arrived</span><br><span class="line">worker2 arrived</span><br><span class="line"><span class="number">1</span> worker arrived</span><br><span class="line">worker1 arrived</span><br><span class="line"><span class="number">2</span> worker arrived</span><br><span class="line">worker3 arrived</span><br><span class="line">all arrived,star working!</span><br><span class="line">all arrived,star working!</span><br><span class="line">all arrived,star working!</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CountDownLatch &amp;amp;&amp;amp; CyclicBarrier example&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MooseFS安装配置</title>
    <link href="http://linbingdong.com/2017/03/30/MooseFS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://linbingdong.com/2017/03/30/MooseFS安装配置/</id>
    <published>2017-03-30T09:32:18.000Z</published>
    <updated>2017-03-30T09:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录 MooseFS 的部署过程。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MooseFS 是一个分布式文件系统，支持挂载的形式。</p><p><strong>主要角色</strong></p><ul><li>master 节点：元数据节点，复制调度和管理元数据。</li><li>metalogger 节点：用于备份 master 的元数据和日志。</li><li>chunkserver 节点：数据节点，数据实际存放的节点。</li><li>client ：客户端。通过 FUSE 将 mfs 文件系统挂载到客户端后，客户端可以像使用一个普通的磁盘分区一样来使用 mfs 。</li></ul><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><table><thead><tr><th align="center">mfsmaster</th><th align="center">mfsmetalogger</th><th align="center">mfschunkserver</th><th align="center">mfsclient</th></tr></thead><tbody><tr><td align="center">192.168.20.96</td><td align="center">192.168.20.97</td><td align="center">192.168.20.98 192.168.20.99</td><td align="center">192.168.20.96 192.168.20.97 192.168.20.98 192.168.20.99</td></tr></tbody></table><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装fuse模块"><a href="#安装fuse模块" class="headerlink" title="安装fuse模块"></a>安装fuse模块</h3><p>确保需要安装 mfsclient 的节点上已经安装了 Linux 内核模块 FUSE 。</p><p>若未安装，可通过 yum 或者编译安装的方式进行安装。</p><h3 id="创建用户和用户组"><a href="#创建用户和用户组" class="headerlink" title="创建用户和用户组"></a>创建用户和用户组</h3><p>每个节点都要创建 mfs 用户和用户组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd  mfs</span><br><span class="line">useradd -g mfs mfs</span><br></pre></td></tr></table></figure><h3 id="修改-etc-hosts"><a href="#修改-etc-hosts" class="headerlink" title="修改/etc/hosts"></a>修改/etc/hosts</h3><p>在每个节点上为 mfsmaster 所在节点（192.168.20.96）增加一个别名 mfsmaster 。</p><p>修改 /etc/hosts ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.20.96 mfsmaster</span><br></pre></td></tr></table></figure><h3 id="解压rpm包"><a href="#解压rpm包" class="headerlink" title="解压rpm包"></a>解压rpm包</h3><p>将 mfs.tar.gz 解压到每个节点的 /opt 目录下，解压后会生成 /opt/mfs 目录。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="mfsmaster-cgi"><a href="#mfsmaster-cgi" class="headerlink" title="mfsmaster+cgi"></a>mfsmaster+cgi</h3><p>节点 192.168.20.96</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-master-2.0.77-1.x86_64.rpm moosefs-cgi-2.0.77-1.x86_64.rpm moosefs-cgiserv-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfsmetalogger"><a href="#mfsmetalogger" class="headerlink" title="mfsmetalogger"></a>mfsmetalogger</h3><p>节点 192.168.20.97 </p><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-metalogger-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfschunkserver"><a href="#mfschunkserver" class="headerlink" title="mfschunkserver"></a>mfschunkserver</h3><p>节点 192.168.20.98 、 192.168.20.99 </p><p>创建 /mnt/mfs 目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/mfs</span><br><span class="line">chown -R mfs:mfs /mnt/mfs</span><br></pre></td></tr></table></figure><p>修改 /etc/mfs/mfshdd.cfg ，在任意位置增加一行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/mnt/mfs</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-chunkserver-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfsclient"><a href="#mfsclient" class="headerlink" title="mfsclient"></a>mfsclient</h3><p>节点 192.168.20.96 、192.168.20.97 、192.168.20.98 、192.168.20.99</p><p>创建 /mnt/mfs-cli 目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/mfs-cli</span><br><span class="line">chown -R mfs:mfs /mnt/mfs-cli/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh moosefs-client-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>挂载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mfsmount /mnt/mfs-cli/ -H mfsmaster</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li>mfsmaster</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-master</span><br></pre></td></tr></table></figure><ul><li>mfscgiserv</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-cgiserv</span><br></pre></td></tr></table></figure><p>启动 mfsmaster 和 mfscgiserv 后，在浏览器中输入 <code>http://192.168.20.96:9425</code> 查看Web 页面 ：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-84150574f17280c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MooseFS WebUI"></p><ul><li>mfsmetalogger</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-metalogger</span><br></pre></td></tr></table></figure><ul><li>mfschunkserver</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-chunkserver</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>所有客户端节点 /mnt/mfs-cli 目录下的内容都是相同的。<br>只需把文件放入任意客户端节点的 /mnt/mfs-cli 目录下即可，该目录对所有客户端节点可见。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 MooseFS 的部署过程。&lt;/p&gt;
    
    </summary>
    
      <category term="MooseFS" scheme="http://linbingdong.com/categories/MooseFS/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式文件系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MooseFS" scheme="http://linbingdong.com/tags/MooseFS/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL安装PostGIS插件并使用</title>
    <link href="http://linbingdong.com/2017/03/25/PostgreSQL%E5%AE%89%E8%A3%85PostGISC%E6%8F%92%E4%BB%B6%E5%B9%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://linbingdong.com/2017/03/25/PostgreSQL安装PostGISC插件并使用/</id>
    <published>2017-03-25T12:15:11.000Z</published>
    <updated>2017-03-25T12:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。</p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。</p><p>PostGIS支持所有的空间数据类型，这些类型包括：点（POINT）、线（LINESTRING）、多边形（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多多边形（MULTIPOLYGON）和集合对象集 （GEOMETRYCOLLECTION）等。PostGIS支持所有的对象表达方法，比如WKT和WKB。</p><p>PostGIS支持所有的数据存取和构造方法，如GeomFromText()、AsBinary()，以及GeometryN()等。</p><p>PostGIS提供简单的空间分析函数（如Area和Length）同时也提供其他一些具有复杂分析功能的函数，比如Distance。</p><p>PostGIS提供了对于元数据的支持，如GEOMETRY_COLUMNS和SPATIAL_REF_SYS，同时，PostGIS也提供了相应的支持函数，如AddGeometryColumn和DropGeometryColumn。</p><p>PostGIS提供了一系列的二元谓词（如Contains、Within、Overlaps和Touches）用于检测空间对象之间的空间关系，同时返回布尔值来表征对象之间符合这个关系。</p><p>PostGIS提供了空间操作符（如Union和Difference）用于空间数据操作。比如，Union操作符融合多边形之间的边界。两个交迭的多边形通过Union运算就会形成一个新的多边形，这个新的多边形的边界为两个多边形中最大边界。</p><p>PostGIS还提供以下功能：</p><p><strong>数据库坐标变换</strong></p><p>数据库中的几何类型可以通过Transform函数从一种投影系变换到另一种投影系中。在OpenGIS中的几何类型都将SRID作为自身结构的一部分，但不知什么原因，在OpenGIS的SFSQL规范中，并没有引入Transform。</p><p><strong>球体长度运算</strong></p><p>存储在普通地理坐标系中的集合类型如果不进行坐标变换是无法进行程度运算的，OpenGIS所提供的坐标变换使得积累类型的程度计算变成可能。</p><p><strong>三维的几何类型</strong></p><p>SFSQL规范只是针对二维集合类型。OpenGIS提供了对三维集合类型的支持，具体是利用输入的集合类型维数来决定输出的表现方式。例如，即便 所有几何对象内部都以三维形式存储，纯粹的二维交叉点通常还是以二维的形式返回。此外，还提供几何对象在不同维度间转换的功能。</p><p><strong>空间聚集函数</strong></p><p>在数据库中，聚集函数是一个执行某一属性列所有数据操作的函数。比如Sum和Average，Sum是求某一关系属性列的数据总和，Average 则是求取某一关系属性列的数据平均值。与此对应，空间聚集函数也是执行相同的操作，不过操作的对象是空间数据。例如聚集函数Extent返回一系列要素中 的最大的包裹矩形框，如“SELECT EXTENT(GEOM) FROM ROADS”这条SQL语句的执行结果是返回ROADS这个数据表中所有的包裹矩形框。</p><p><strong>栅格数据类型</strong></p><p>PostGIS通过一种新的数据类型片，提供对于大的栅格数据对象的存储。片由以下几个部分组成：包裹矩形框、SRID、类型和一个字节序列。通过 将片的大小控制在数据库页值（32×32）以下，使得快速的随即访问变成可能。一般大的图片也是通过将其切成32×32像素的片然后再存储在数据库中的。</p><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2. 部署"></a>2. 部署</h2><h3 id="2-1-安装PostGIS"><a href="#2-1-安装PostGIS" class="headerlink" title="2.1 安装PostGIS"></a>2.1 安装PostGIS</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install postgis2_94   # 因为安装的PostgreSQL版本为9.4，所以是postgis2_94</span><br></pre></td></tr></table></figure><p>  <strong>注：</strong><br>  需要PostgreSQL9.1以上版本才支持PostGIS.</p><h3 id="2-2-使PostGIS可用"><a href="#2-2-使PostGIS可用" class="headerlink" title="2.2 使PostGIS可用"></a>2.2 使PostGIS可用</h3><p>想要在PostgreSQL中使用PostGIS插件，安装只是第一步。每个数据库想要使用PostGIS必须先在该数据库中使PostGIS可用。假设我们想在gisdb这个数据库中使用PostGIS,先进入gisdb数据库，执行以下步骤：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# CREATE EXTENSION postgis;</span><br><span class="line">gisdb=# CREATE EXTENSION postgis_topology;</span><br></pre></td></tr></table></figure><h3 id="2-3-查看是否安装成功"><a href="#2-3-查看是否安装成功" class="headerlink" title="2.3 查看是否安装成功"></a>2.3 查看是否安装成功</h3><p>  在gisdb数据库中输入\du，查看已安装的插件</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# \dx</span><br><span class="line">                                               已安装扩展列表</span><br><span class="line">       名称       | 版本  |  架构模式  |                                描述</span><br><span class="line">------------------+-------+------------+---------------------------------------------------------------------</span><br><span class="line"> plpgsql          | 1.0   | pg_catalog | PL/pgSQL procedural language</span><br><span class="line"> postgis          | 2.1.8 | public     | PostGIS geometry, geography, and raster spatial types and functions</span><br><span class="line"> postgis_topology | 2.1.8 | topology   | PostGIS topology spatial types and functions</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>可以看到已经安装了postgis和postgis_topology。</p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><h3 id="3-1-创建空间数据表"><a href="#3-1-创建空间数据表" class="headerlink" title="3.1 创建空间数据表"></a>3.1 创建空间数据表</h3><p>首先建立一个常规的表格存储有关城市（cities）的信息。这个表格有两栏，一个是 ID 编号，一个是城市名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# CREATE TABLE cities (id int4, name varchar(50));</span><br></pre></td></tr></table></figure><p>现在添加一个空间列用于存储城市的位置。习惯上这个列叫做 the_geom。它记录了数据为什么类型（点、线、面）、有几维（这里是二维）以及空间坐标系统。此处使用 EPSG:4326 坐标系统：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT AddGeometryColumn (&apos;cities&apos;, &apos;the_geom&apos;, 4326, &apos;POINT&apos;, 2);</span><br></pre></td></tr></table></figure><p>完成后，查询 cities 表单应当显示这个新栏目。同时页面将显示当前表达没有记录（0 rows）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# select * from cities;</span><br><span class="line"> id |      name       |                      the_geom</span><br><span class="line">----+-----------------+----------------------------------------------------</span><br><span class="line">（0行记录）</span><br></pre></td></tr></table></figure><p>为添加记录，需要使用 SQL 命令。对于空间列，使用 PostGIS 的 ST_GeomFromText可以将文本转化为坐标与参考系号的记录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (1,ST_GeomFromText(&apos;POINT(-0.1257 51.508)&apos;,4326),&apos;London, England&apos;);</span><br><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (2,ST_GeomFromText(&apos;POINT(-81.233 42.983)&apos;,4326),&apos;London, Ontario&apos;);</span><br><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (3,ST_GeomFromText(&apos;POINT(27.91162491 -33.01529)&apos;,4326),&apos;East London,SA&apos;);</span><br></pre></td></tr></table></figure><p>当然，这样的输入方式难以操作。其它方式可以更快的输入数据。就目前来说，表格内已经有了一些城市数据，可以先进行查询等操作。</p><h3 id="3-2-简单查询"><a href="#3-2-简单查询" class="headerlink" title="3.2 简单查询"></a>3.2 简单查询</h3><p>标准的 SQL 操作都可以用于 PostGIS 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT * FROM cities;</span><br><span class="line"> id |      name       |                      the_geom</span><br><span class="line">----+-----------------+----------------------------------------------------</span><br><span class="line">  1 | London, England | 0101000020E6100000BBB88D06F016C0BF1B2FDD2406C14940</span><br><span class="line">  2 | London, Ontario | 0101000020E6100000F4FDD478E94E54C0E7FBA9F1D27D4540</span><br><span class="line">  3 | East London,SA  | 0101000020E610000040AB064060E93B4059FAD005F58140C0</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>这里的坐标是无法阅读的 16 进制格式。要以 WKT 文本显示，使用 ST_AsText(the_geom) 或ST_AsEwkt(the_geom) 函数。也可以使用 ST_X(the_geom) 和 ST_Y(the_geom) 显示一个维度的坐标：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=#  SELECT id, ST_AsText(the_geom), ST_AsEwkt(the_geom), ST_X(the_geom), ST_Y(the_geom) FROM cities;</span><br><span class="line"> id |          st_astext           |               st_asewkt                |    st_x     |   st_y</span><br><span class="line">----+------------------------------+----------------------------------------+-------------+-----------</span><br><span class="line">  1 | POINT(-0.1257 51.508)        | SRID=4326;POINT(-0.1257 51.508)        |     -0.1257 |    51.508</span><br><span class="line">  2 | POINT(-81.233 42.983)        | SRID=4326;POINT(-81.233 42.983)        |     -81.233 |    42.983</span><br><span class="line">  3 | POINT(27.91162491 -33.01529) | SRID=4326;POINT(27.91162491 -33.01529) | 27.91162491 | -33.01529</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><h3 id="3-3-空间查询"><a href="#3-3-空间查询" class="headerlink" title="3.3 空间查询"></a>3.3 空间查询</h3><p>PostGIS 为 PostgreSQL 扩展了许多空间操作功能。以上已经涉及了转换空间坐标格式的 ST_GeomFromText 。多数空间操作以 ST（spatial type）开头，在 PostGIS 文档相应章节有罗列。这里回答一个具体的问题：上面三个城市相互的距离是多少？查询语句怎么写？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT p1.name,p2.name,ST_Distance_Sphere(p1.the_geom,p2.the_geom) FROM cities AS p1, cities AS p2 WHERE p1.id &gt; p2.id;</span><br><span class="line">      name       |      name       | st_distance_sphere</span><br><span class="line">-----------------+-----------------+--------------------</span><br><span class="line"> London, Ontario | London, England |   5875787.03777356</span><br><span class="line"> East London,SA  | London, England |   9789680.59961472</span><br><span class="line"> East London,SA  | London, Ontario |   13892208.6782928</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>输出显示了距离数据。注意 ‘WHERE’ 部分防止了输出城市到自身的距离（0）或者两个城市不同排列的距离数据（London, England 到 London, Ontario 和 London, Ontario 到 London, England 的距离是一样的）。<br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。&lt;/p&gt;
    
    </summary>
    
      <category term="PostgreSQL" scheme="http://linbingdong.com/categories/PostgreSQL/"/>
    
    
      <category term="关系数据库" scheme="http://linbingdong.com/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="http://linbingdong.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper原理及其在Hadoop和HBase中的应用</title>
    <link href="http://linbingdong.com/2017/03/23/ZooKeeper%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%9C%A8Hadoop%E5%92%8CHBase%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://linbingdong.com/2017/03/23/ZooKeeper原理及其在Hadoop和HBase中的应用/</id>
    <published>2017-03-23T00:47:28.000Z</published>
    <updated>2017-03-23T00:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，由雅虎创建，是Google <strong>Chubby的开源实现</strong>。分布式应用程序可以基于ZooKeeper实现诸如<strong>数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，由雅虎创建，是Google <strong>Chubby的开源实现</strong>。分布式应用程序可以基于ZooKeeper实现诸如<strong>数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>本节将介绍ZooKeeper的几个核心概念。这些概念贯穿于之后对ZooKeeper更深入的讲解，因此有必要预先了解这些概念。</p><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>在ZooKeeper中，有三种角色：</p><ul><li>Leader</li><li>Follower</li><li>Observer</li></ul><p>一个ZooKeeper集群同一时刻只会有一个Leader，其他都是Follower或Observer。</p><p>ZooKeeper配置很简单，每个节点的配置文件(zoo.cfg)都是一样的，只有myid文件不一样。myid的值必须是zoo.cfg中server.{数值}的{数值}部分。</p><p>zoo.cfg文件内容示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxClientCnxns=0</span><br><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/var/lib/zookeeper/data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the directory where the transaction logs are stored.</span><br><span class="line">dataLogDir=/var/lib/zookeeper/logs</span><br><span class="line">server.1=192.168.20.101:2888:3888</span><br><span class="line">server.2=192.168.20.102:2888:3888</span><br><span class="line">server.3=192.168.20.103:2888:3888</span><br><span class="line">server.4=192.168.20.104:2888:3888</span><br><span class="line">server.5=192.168.20.105:2888:3888</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=100000</span><br></pre></td></tr></table></figure><p>在装有ZooKeeper的机器的终端执行 <code>zookeeper-server status</code> 可以看当前节点的ZooKeeper是什么角色（Leader or Follower）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node-20-103 ~]# zookeeper-server status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /etc/zookeeper/conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node-20-104 ~]# zookeeper-server status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /etc/zookeeper/conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure><p>如上，node-20-104是Leader，node-20-103是follower。</p><p>ZooKeeper默认只有Leader和Follower两种角色，没有Observer角色。</p><p>为了使用Observer模式，在任何想变成Observer的节点的配置文件中加入：<code>peerType=observer</code><br>并在所有server的配置文件中，配置成observer模式的server的那行配置追加:observer，例如：<br><code>server.1:localhost:2888:3888:observer</code></p><p>ZooKeeper集群的所有机器通过一个<strong>Leader选举过程</strong>来选定一台被称为<strong>『Leader』</strong>的机器，<strong>Leader服务器</strong>为客户端提供<strong>读</strong>和<strong>写</strong>服务。</p><p>Follower和Observer都<strong>能</strong>提供<strong>读</strong>服务，<strong>不能</strong>提供<strong>写</strong>服务。两者唯一的区别在于，<strong>Observer</strong>机器<strong>不参与Leader选举</strong>过程，也<strong>不参与写操作</strong>的『过半写成功』策略，因此Observer可以在<strong>不影响写性能</strong>的情况下<strong>提升</strong>集群的<strong>读性能</strong>。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>Session是指<strong>客户端会话</strong>，在讲解客户端会话之前，我们先来了解下<strong>客户端连接</strong>。在ZooKeeper中，一个客户端连接是指客户端和ZooKeeper服务器之间的<strong>TCP长连接</strong>。ZooKeeper对外的服务端口默认是<strong>2181</strong>，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过<strong>心跳检测</strong>和服务器保持有效的会话，也能够向ZooKeeper服务器<strong>发送请求</strong>并<strong>接受响应</strong>，同时还能通过该连接接收来自服务器的<strong>Watch事件通知</strong>。Session的<strong>SessionTimeout</strong>值用来设置一个客户端会话的<strong>超时时间</strong>。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的时间内能够<strong>重新连接上</strong>集群中<strong>任意一台</strong>服务器，那么之前创建的会话<strong>仍然有效</strong>。</p><h3 id="数据节点（ZNode）"><a href="#数据节点（ZNode）" class="headerlink" title="数据节点（ZNode）"></a>数据节点（ZNode）</h3><p>在谈到分布式的时候，<strong>一般</strong>『节点』指的是组成集群的每一台<strong>机器</strong>。而ZooKeeper中的数据节点是指<strong>数据模型</strong>中的<strong>数据单元</strong>，称为<strong>ZNode</strong>。ZooKeeper将所有数据存储在<strong>内存中</strong>，数据模型是一棵<strong>树（ZNode Tree）</strong>，由斜杠（/）进行分割的路径，就是一个ZNode，如/hbase/master,其中hbase和master<strong>都是</strong>ZNode。每个ZNode上都会保存<strong>自己的数据内容</strong>，同时会保存一系列<strong>属性信息</strong>。</p><p>注：<br>这里的ZNode可以理解成<strong>既是</strong>Unix里的<strong>文件</strong>，<strong>又是</strong>Unix里的<strong>目录</strong>。因为每个ZNode不仅本身可以<strong>写数据</strong>（相当于Unix里的文件），还可以有<strong>下一级文件或目录</strong>（相当于Unix里的目录）。</p><p>在ZooKeeper中，ZNode可以分为<strong>持久节点</strong>和<strong>临时节点</strong>两类。</p><p><strong>持久节点</strong></p><p> 所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</p><p><strong>临时节点</strong></p><p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p><p>另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper就会自动在其节点后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>ZooKeeper的每个ZNode上都会存储数据，对应于每个ZNode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和aversion（当前ZNode的ACL版本）。</p><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>每个ZNode除了存储数据内容之外，还存储了ZNode本身的一些状态信息。用 get 命令可以同时获得某个ZNode的内容和状态信息。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 23] get /yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</span><br><span class="line"></span><br><span class="line">appcluster-yarnrm1</span><br><span class="line">cZxid = 0x1b00133dc0    //Created ZXID,表示该ZNode被创建时的事务ID</span><br><span class="line">ctime = Tue Jan 03 15:44:42 CST 2017    //Created Time,表示该ZNode被创建的时间</span><br><span class="line">mZxid = 0x1d00000063    //Modified ZXID，表示该ZNode最后一次被更新时的事务ID</span><br><span class="line">mtime = Fri Jan 06 08:44:25 CST 2017    //Modified Time，表示该节点最后一次被更新的时间</span><br><span class="line">pZxid = 0x1b00133dc0    //表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更pZxid，子节点内容变更不会影响pZxid。</span><br><span class="line">cversion = 0    //子节点的版本号</span><br><span class="line">dataVersion = 11    //数据节点的版本号</span><br><span class="line">aclVersion = 0    //ACL版本号</span><br><span class="line">ephemeralOwner = 0x0    //创建该节点的会话的seddionID。如果该节点是持久节点，那么这个属性值为0。</span><br><span class="line">dataLength = 22    //数据内容的长度</span><br><span class="line">numChildren = 0    //子节点的个数</span><br></pre></td></tr></table></figure><p>在ZooKeeper中，version属性是用来实现乐观锁机制中的『写入校验』的（保证分布式数据原子性操作）。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher（事件监听器），是ZooKeeper中一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。该机制是ZooKeeper实现分布式协调服务的重要特性。</p><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>ZooKeeper采用ACL（Access Control Lists）策略来进行权限控制。ZooKeeper定义了如下5种权限。</p><ul><li>CREATE: 创建子节点的权限。</li><li>READ: 获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE: 删除子节点的权限。</li><li>ADMIN: 设置节点ACL的权限。</li></ul><p>注意：CREATE 和 DELETE 都是针对子节点的权限控制。</p><h2 id="ZooKeeper典型应用场景"><a href="#ZooKeeper典型应用场景" class="headerlink" title="ZooKeeper典型应用场景"></a>ZooKeeper典型应用场景</h2><p>ZooKeeper是一个<strong>高可用</strong>的分布式<strong>数据管理与协调框架</strong>。基于对ZAB算法的实现，该框架能够很好地保证分布式环境中数据的<strong>一致性</strong>。也是基于这样的特性，使得ZooKeeper成为了解决分布式一致性问题的利器。</p><h3 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h3><p>数据发布与订阅，即所谓的<strong>配置中心</strong>，顾名思义就是发布者将数据发布到ZooKeeper节点上，供订阅者进行数据订阅，进而达到<strong>动态获取数据</strong>的目的，实现配置信息的<strong>集中式管理</strong>和<strong>动态更新</strong>。</p><p>在我们平常的应用系统开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如<strong>机器列表信息</strong>、<strong>数据库配置信息</strong>等。这些全局配置信息通常具备以下3个特性。</p><ul><li>数据量通常比较<strong>小。</strong></li><li>数据内容在运行时<strong>动态变化</strong>。</li><li>集群中各机器共享，<strong>配置一致</strong>。</li></ul><p>对于这样的全局配置信息就可以发布到ZooKeeper上，让客户端（集群的机器）去订阅该消息。</p><p>发布/订阅系统一般有两种设计模式，分别是<strong>推（Push）</strong>和<strong>拉（Pull）</strong>模式。</p><ul><li>推：<strong>服务端主动</strong>将数据更新发送给所有订阅的客户端。</li><li>拉：<strong>客户端主动</strong>发起请求来获取最新数据，通常客户端都采用<strong>定时轮询</strong>拉取的方式。</li></ul><p>ZooKeeper采用的是<strong>推拉相结合</strong>的方式。如下：</p><p>客户端想服务端<strong>注册</strong>自己需要关注的节点，一旦该节点的数据发生<strong>变更</strong>，那么服务端就会向相应的客户端发送Watcher事件<strong>通知</strong>，客户端接收到这个消息通知后，需要<strong>主动</strong>到服务端<strong>获取</strong>最新的数据（<strong>推拉结合</strong>）。</p><h3 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h3><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定<strong>名字</strong>来获取<strong>资源或服务的地址，提供者等信息</strong>。被命名的实体通常可以是<strong>集群中的机器，提供的服务，远程对象等等</strong>——这些我们都可以统称他们为<strong>名字（Name）</strong>。其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在ZooKeepr里创建顺序节点，能够很容易创建一个<strong>全局唯一的路径</strong>，这个路径就可以作为一个<strong>名字</strong>。</p><p>ZooKeeper的命名服务即生成<strong>全局唯一的ID</strong>。</p><h3 id="分布式协调-通知"><a href="#分布式协调-通知" class="headerlink" title="分布式协调/通知"></a>分布式协调/通知</h3><p>ZooKeeper中特有<strong>Watcher注册</strong>与<strong>异步通知机制</strong>，能够很好的实现分布式环境下不同机器，甚至不同系统之间的<strong>通知与协调</strong>，从而实现<strong>对数据变更的实时处理</strong>。使用方法通常是不同的客户端都对ZK上同一个ZNode进行注册，监听ZNode的变化（包括ZNode本身内容及子节点的），如果ZNode发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。</p><p><strong>ZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式</strong>。</p><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以<strong>相互PING通</strong>来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过<strong>TCP连接</strong>固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。</p><p>下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。</p><p>基于ZK的<strong>临时节点</strong>的特性，可以让不同的进程都在ZK的一个<strong>指定节点</strong>下创建<strong>临时子节点</strong>，不同的进程直接可以根据这个临时子节点来判断对应的进程<strong>是否存活</strong>。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大<strong>减少了系统耦合</strong>。</p><h4 id="工作进度汇报"><a href="#工作进度汇报" class="headerlink" title="工作进度汇报"></a>工作进度汇报</h4><p>在一个常见的<strong>任务分发系统</strong>中，通常任务被分发到不同的机器上执行后，需要实时地将自己的任务执行进度<strong>汇报</strong>给分发系统。这个时候就可以通过ZK来实现。在ZK上选择一个节点，每个任务客户端都在这个节点下面创建<strong>临时子节点</strong>，这样便可以实现两个功能：</p><ul><li>通过判断临时节点是否存在来确定任务机器<strong>是否存活</strong>。</li><li>各个任务机器会实时地将自己的<strong>任务执行进度写到这个临时节点上去</strong>，以便中心系统能够实时地获取到任务的<strong>执行进度</strong>。</li></ul><h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p><strong>Master选举</strong>可以说是ZooKeeper<strong>最典型的应用场景</strong>了。比如HDFS中Active NameNode的选举、YARN中Active ResourceManager的选举和HBase中Active HMaster的选举等。</p><p>针对Master选举的需求，通常情况下，我们可以选择常见的<strong>关系型数据库</strong>中的<strong>主键特性</strong>来实现：希望成为Master的机器都向数据库中插入一条<strong>相同主键ID</strong>的记录，数据库会帮我们进行<strong>主键冲突检查</strong>，也就是说，<strong>只有一台</strong>机器能插入成功——那么，我们就认为向数据库中<strong>成功插入</strong>数据的客户端机器<strong>成为Master</strong>。</p><p>依靠关系型数据库的主键特性确实能够很好地保证在集群中选举出唯一的一个Master。但是，如果当前选举出的Master挂了，那么该如何处理？谁来告诉我Master挂了呢？显然，关系型数据库无法通知我们这个事件。但是，ZooKeeper可以做到！</p><p>利用ZooKeepr的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端<strong>无法创建一个已经存在的ZNode</strong>。也就是说，如果同时有多个客户端请求创建<strong>同一个</strong>临时节点，那么最终一定<strong>只有一个</strong>客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行Master选举了。</p><p>成功创建该节点的客户端所在的机器就成为了Master。同时，其他没有成功创建该节点的客户端，都会在该节点上<strong>注册</strong>一个子节点变更的<strong>Watcher</strong>，用于监控当前Master机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会<strong>重新进行Master选举</strong>。</p><p>这样就实现了Master的<strong>动态选举</strong>。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁是控制<strong>分布式系统</strong>之间<strong>同步访问共享资源</strong>的一种方式。</p><p>分布式锁又分为<strong>排他锁</strong>和<strong>共享锁</strong>两种。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p>排他锁（Exclusive Locks，简称X锁），又称为<strong>写锁</strong>或<strong>独占锁</strong>。</p><blockquote><p>如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许事务T1对O1进行<strong>读取和更新</strong>操作，其他任何事务都不能在对这个数据对象进行任何类型的操作（不能再对该对象加锁），直到T1释放了排他锁。</p></blockquote><p>可以看出，排他锁的核心是如何保证当前<strong>只有一个事务获得锁</strong>，并且锁<strong>被释放</strong>后，所有正在等待获取锁的事务都能够<strong>被通知到</strong>。</p><p>如何利用ZooKeeper实现排他锁？</p><p><strong>定义锁</strong></p><p>ZooKeeper上的<strong>一个ZNode可以表示一个锁</strong>。例如/exclusive_lock/lock节点就可以被定义为一个锁。</p><p><strong>获得锁</strong></p><p>如上所说，把ZooKeeper上的一个ZNode看作是一个锁，<strong>获得锁</strong>就通过<strong>创建ZNode</strong>的方式来实现。所有客户端都去/exclusive_lock节点下创建临时子节点/exclusive_lock/lock。ZooKeeper会保证在所有客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获得了锁。同时，所有没有获取到锁的客户端就需要到/exclusive_lock节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。</p><p><strong>释放锁</strong></p><p>因为/exclusive_lock/lock是一个<strong>临时节点</strong>，因此在以下两种情况下，都有可能释放锁。</p><ul><li>当前获得锁的客户端机器发生<strong>宕机</strong>或<strong>重启</strong>，那么该临时节点就会<strong>被删除，释放锁</strong>。</li><li>正常执行完业务逻辑后，客户端就会<strong>主动</strong>将自己创建的临时节点<strong>删除，释放锁</strong>。</li></ul><p>无论在什么情况下移除了lock节点，ZooKeeper都会<strong>通知</strong>所有在/exclusive_lock节点上注册了节点变更Watcher监听的客户端。这些客户端在接收到通知后，再次<strong>重新发起</strong>分布式锁获取，即重复『获取锁』过程。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><blockquote><p>共享锁（Shared Locks，简称S锁），又称为读锁。如果事务T1对数据对象O1加上了共享锁，那么T1只能对O1进行<strong>读操作</strong>，其他事务也能<strong>同时对O1加共享锁</strong>（不能是排他锁），直到O1上的所有共享锁都释放后O1才能被加排他锁。</p></blockquote><p>总结：可以<strong>多个事务同时获得</strong>一个对象的<strong>共享锁</strong>（同时读），有共享锁就不能再加排他锁（因为排他锁是写锁）</p><h2 id="ZooKeeper在大型分布式系统中的应用"><a href="#ZooKeeper在大型分布式系统中的应用" class="headerlink" title="ZooKeeper在大型分布式系统中的应用"></a>ZooKeeper在大型分布式系统中的应用</h2><p>前面已经介绍了ZooKeeper的典型应用场景。本节将以常见的大数据产品Hadoop和HBase为例来介绍ZooKeeper在其中的应用，帮助大家更好地理解ZooKeeper的分布式应用场景。</p><h3 id="ZooKeeper在Hadoop中的应用"><a href="#ZooKeeper在Hadoop中的应用" class="headerlink" title="ZooKeeper在Hadoop中的应用"></a>ZooKeeper在Hadoop中的应用</h3><p>在Hadoop中，ZooKeeper主要用于<strong>实现HA(High Availability）</strong>，包括<strong>HDFS的NamaNode和YARN的ResourceManager的HA</strong>。同时，在YARN中，ZooKeepr还用来<strong>存储应用的运行状态</strong>。HDFS的NamaNode和YARN的ResourceManager利用ZooKeepr实现HA的原理是一样的，所以本节以YARN为例来介绍。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6326ec291ba11b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YARN架构体系"></p><p>从上图可以看出，YARN主要由ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）和Container四部分组成。其中<strong>最核心</strong>的就是<strong>ResourceManager</strong>。</p><p>ResourceManager负责集群中<strong>所有资源的统一管理和分配</strong>，同时<strong>接收</strong>来自各个节点（NodeManager）的<strong>资源汇报信息</strong>，并把这些信息按照一定的策略分配给各个应用程序（Application Manager），其内部维护了各个应用程序的ApplicationMaster信息、NodeManager信息以及资源使用信息等。</p><p>为了实现HA，必须有<strong>多个ResourceManager并存</strong>（一般就两个），并且<strong>只有一个ResourceManager处于Active状态</strong>，其他的则处于Standby状态，当Active节点无法正常工作（如机器宕机或重启）时，处于Standby的就会通过<strong>竞争选举</strong>产生<strong>新的Active节点</strong>。</p><h4 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h4><p>下面我们就来看看YARN是如何实现多个ResourceManager之间的主备切换的。</p><ol><li><p>创建锁节点<br>在ZooKeeper上会有一个<code>/yarn-leader-election/appcluster-yarn</code>的锁节点，所有的ResourceManager在启动的时候，都会去竞争写一个Lock子节点：<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>，该节点是临时节点。ZooKeepr能够为我们保证最终<strong>只有一个</strong>ResourceManager能够<strong>创建成功</strong>。<strong>创建成功</strong>的那个ResourceManager就切换为<strong>Active状态</strong>，<strong>没有成功</strong>的那些ResourceManager则切换为<strong>Standby状态</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 16] get /yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</span><br><span class="line"></span><br><span class="line">appcluster-yarnrm2</span><br><span class="line">cZxid = 0x1b00133dc0</span><br><span class="line">ctime = Tue Jan 03 15:44:42 CST 2017</span><br><span class="line">mZxid = 0x1f00000540</span><br><span class="line">mtime = Sat Jan 07 00:50:20 CST 2017</span><br><span class="line">pZxid = 0x1b00133dc0</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 28</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li></ol><p>可以看到此时集群中ResourceManager2为Active。</p><ol start="2"><li><p>注册Watcher监听<br>所有Standby状态的ResourceManager都会向<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>节点注册一个节点变更的<strong>Watcher监听</strong>，利用<strong>临时节点的特性</strong>，能够快速感知到Active状态的ResourceManager的运行情况。</p></li><li><p>主备切换<br>当Active状态的ResourceManager出现诸如<strong>宕机或重启</strong>的异常情况时，其在ZooKeeper上连接的客户端<strong>会话就会失效</strong>，因此<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>节点就会<strong>被删除</strong>。此时其余各个Standby状态的ResourceManager就都会<strong>接收到</strong>来自ZooKeeper服务端的<strong>Watcher事件通知</strong>，然后会<strong>重复进行步骤1的操作</strong>。</p></li></ol><p>以上就是利用ZooKeeper来实现ResourceManager的主备切换的过程，实现了ResourceManager的HA。</p><p>HDFS中NameNode的HA的实现原理跟YARN中ResourceManager的HA的实现原理相同。其锁节点为<code>/hadoop-ha/mycluster/ActiveBreadCrumb</code>。</p><h4 id="ResourceManager状态存储"><a href="#ResourceManager状态存储" class="headerlink" title="ResourceManager状态存储"></a>ResourceManager状态存储</h4><p>在 ResourceManager 中，<strong>RMStateStore</strong> 能够存储一些 RM 的<strong>内部状态信息</strong>，包括 Application 以及它们的 Attempts 信息、Delegation Token 及 Version Information 等。需要注意的是，RMStateStore 中的绝大多数状态信息都是<strong>不需要持久化存储</strong>的，因为<strong>很容易从上下文信息中将其重构出来</strong>，如资源的使用情况。在存储的设计方案中，提供了三种可能的实现，分别如下。</p><ul><li>基于内存实现，一般是用于日常开发测试。</li><li>基于文件系统的实现，如HDFS。</li><li>基于ZooKeeper实现。</li></ul><p>由于这些状态信息的<strong>数据量都不是很大</strong>，因此Hadoop<strong>官方建议基于ZooKeeper来实现状态信息的存储</strong>。在ZooKeepr上，ResourceManager 的状态信息都被存储在<code>/rmstore</code>这个根节点下面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">28</span>] ls /rmstore/ZKRMStateRoot</span><br><span class="line">[RMAppRoot, AMRMTokenSecretManagerRoot, EpochNode, RMDTSecretManagerRoot, RMVersionNode]</span><br></pre></td></tr></table></figure><p>RMAppRoot 节点下存储的是与各个 Application 相关的信息，RMDTSecretManagerRoot 存储的是与安全相关的 Token 等信息。每个 Active 状态的 ResourceManager 在<strong>初始化阶段</strong>都会从 ZooKeeper 上<strong>读取到这些状态信息</strong>，并根据这些状态信息继续进行相应的处理。</p><p>小结：</p><p>ZooKeepr在Hadoop中的应用主要有：</p><ol><li>HDFS中NameNode的HA和YARN中ResourceManager的HA。</li><li>存储RMStateStore状态信息</li></ol><h3 id="ZooKeeper在HBase中的应用"><a href="#ZooKeeper在HBase中的应用" class="headerlink" title="ZooKeeper在HBase中的应用"></a>ZooKeeper在HBase中的应用</h3><p>HBase主要用ZooKeeper来实现<strong>HMaster选举与主备切换、系统容错、RootRegion管理、Region状态管理和分布式SplitWAL任务管理</strong>等。</p><h4 id="HMaster选举与主备切换"><a href="#HMaster选举与主备切换" class="headerlink" title="HMaster选举与主备切换"></a>HMaster选举与主备切换</h4><p>HMaster选举与主备切换的原理和HDFS中NameNode及YARN中ResourceManager的HA原理相同。</p><h4 id="系统容错"><a href="#系统容错" class="headerlink" title="系统容错"></a>系统容错</h4><p>当HBase启动时，每个<strong>RegionServer</strong>都会到ZooKeeper的<code>/hbase/rs</code>节点下创建一个信息节点（下文中，我们称该节点为”rs状态节点”），例如<code>/hbase/rs/[Hostname]</code>，同时，<strong>HMaster</strong>会对这个节点<strong>注册监听</strong>。当某个 RegionServer 挂掉的时候，ZooKeeper会因为在一段时间内无法接受其心跳（即 Session 失效），而删除掉该 RegionServer 服务器对应的 rs 状态节点。与此同时，HMaster 则会接收到 ZooKeeper 的 NodeDelete 通知，从而感知到某个节点断开，并立即开始容错工作。</p><p>HBase为什么不直接让HMaster来负责RegionServer的监控呢？如果HMaster直接通过<strong>心跳机制</strong>等来管理RegionServer的状态，随着<strong>集群越来越大</strong>，HMaster的<strong>管理负担会越来越重</strong>，另外它自身也有挂掉的可能，因此数据还<strong>需要持久化</strong>。在这种情况下，ZooKeeper就成了理想的选择。</p><h4 id="RootRegion管理"><a href="#RootRegion管理" class="headerlink" title="RootRegion管理"></a>RootRegion管理</h4><p>对应HBase集群来说，数据存储的<strong>位置信息</strong>是记录在<strong>元数据region</strong>，也就是<strong>RootRegion</strong>上的。每次客户端发起新的请求，需要知道数据的位置，就会去查询RootRegion，而<strong>RootRegion自身位置则是记录在ZooKeeper上</strong>的（默认情况下，是记录在ZooKeeper的<code>/hbase/meta-region-server</code>节点中）。当RootRegion发生变化，比如Region的手工移动、重新负载均衡或RootRegion所在服务器发生了故障等是，就能够通过ZooKeeper来感知到这一变化并做出一系列相应的容灾措施，从而保证客户端总是能够拿到正确的RootRegion信息。</p><h4 id="Region管理"><a href="#Region管理" class="headerlink" title="Region管理"></a>Region管理</h4><p>HBase里的Region会经常发生变更，这些变更的原因来自于系统故障、负载均衡、配置修改、Region分裂与合并等。一旦Region发生移动，它就会经历<strong>下线（offline）和重新上线（online）</strong>的过程。</p><p>在<strong>下线期间</strong>数据是<strong>不能被访问</strong>的，并且Region的这个状态变化必须<strong>让全局知晓</strong>，否则可能会出现<strong>事务性的异常</strong>。对于大的HBase集群来说，Region的数量可能会多达十万级别，甚至更多，这样规模的Region状态管理交给ZooKeeper来做也是一个很好的选择。</p><h4 id="分布式SplitWAL任务管理"><a href="#分布式SplitWAL任务管理" class="headerlink" title="分布式SplitWAL任务管理"></a>分布式SplitWAL任务管理</h4><p>当某台<strong>RegionServer服务器挂掉</strong>时，由于总有一部分<strong>新写入的数据还没有持久化到HFile中</strong>，因此在迁移该RegionServer的服务时，一个重要的工作就是<strong>从WAL中恢复</strong>这部分还在内存中的数据，而这部分工作<strong>最关键的一步</strong>就是<strong>SplitWAL</strong>，即HMaster需要遍历该RegionServer服务器的WAL，并按Region切分成小块移动到新的地址下，并进行<strong>日志的回放（replay）</strong>。</p><p>由于单个RegionServer的日志量相对庞大（可能有上千个Region，上GB的日志），而用户又往往希望系统能够快速完成日志的恢复工作。因此一个可行的方案是将这个处理WAL的任务<strong>分给多台RegionServer服务器</strong>来共同处理，而这就又需要一个<strong>持久化组件来辅助HMaster完成任务的分配</strong>。当前的做法是，HMaster会在ZooKeeper上创建一个<strong>SplitWAL节点</strong>（默认情况下，是<code>/hbase/SplitWAL</code>节点），将<strong>“哪个RegionServer处理哪个Region”</strong>这样的信息以<strong>列表的形式</strong>存放到该节点上，然后由各个RegionServer服务器自行到该节点上去<strong>领取任务</strong>并在任务执行成功或失败后再<strong>更新该节点的信息</strong>，以通知HMaster继续进行后面的步骤。ZooKeeper在这里担负起了分布式集群中<strong>相互通知和信息持久化</strong>的角色。</p><p>小结：</p><p>以上就是一些HBase中依赖ZooKeeper完成分布式协调功能的典型场景。但事实上，HBase对ZooKeepr的依赖还不止这些，比如HMaster还依赖ZooKeeper来完成Table的enable/disable状态记录，以及HBase中<strong>几乎所有的元数据存储</strong>都是放在ZooKeeper上的。</p><p>由于ZooKeeper出色的分布式协调能力及良好的通知机制，HBase在各版本的演进过程中越来越多地增加了ZooKeeper的应用场景，从趋势上来看两者的交集越来越多。HBase中所有对ZooKeeper的操作都封装在了org.apache.hadoop.hbase.zookeeper这个包中，感兴趣的同学可以自行研究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《从Paxos到Zookeeper》</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper是一个开源的&lt;strong&gt;分布式协调服务&lt;/strong&gt;，由雅虎创建，是Google &lt;strong&gt;Chubby的开源实现&lt;/strong&gt;。分布式应用程序可以基于ZooKeeper实现诸如&lt;strong&gt;数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列&lt;/strong&gt;等功能。&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://linbingdong.com/categories/ZooKeeper/"/>
    
    
      <category term="大数据" scheme="http://linbingdong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ZooKeeper" scheme="http://linbingdong.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://linbingdong.com/2017/03/15/Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://linbingdong.com/2017/03/15/Python函数式编程/</id>
    <published>2017-03-15T08:24:20.000Z</published>
    <updated>2017-03-15T08:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 Python 不是函数式编程语言（是命令式编程语言），但是支持许多有价值的函数式编程工具。Python 提供 3 种内建函数和 lambda 表达式等来支持函数式编程。</p><a id="more"></a><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Python 允许用 lambda 关键字创造匿名函数。匿名顾名思义就是没有名字，即不需要以标准的方式来声明，比如说，使用 def 加函数名来声明。一个完整的 lambda “语句”代表了一个表达式，这个表达式的定义体必须和声明放在同一行。语法如下：</p><p><code>lambda [arg1[, arg2, ... argN]]: expression</code></p><p>参数是可选的，如果使用参数的话，参数通常也会出现在表达式中。</p><p>注意：lambda 表达式返回可调用的函数对象。其实 lambda 表达式本身就是一个函数，这个函数定义了输入（冒号左边）和输出（冒号右边），只不过这个函数没有名字，但是我们可以把它赋给一个变量。</p><p>比如简单的加法函数。一般我们是这么写的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure><p>lambda 表达式这么写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y : x + y</span><br></pre></td></tr></table></figure><p>我们可以把 <code>lambda x, y : x + y</code> 赋值给 f ，然后给 f 传参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x10377f320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">12</span>, <span class="number">100</span>)</span><br><span class="line"><span class="number">112</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-33</span>, <span class="number">-22</span>)</span><br><span class="line"><span class="number">-55</span></span><br></pre></td></tr></table></figure><p>可以看到，f 确实是个函数，可以接收两个参数，并返回这两个参数的和，等价于上面的 add 函数。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫 Higher-order function 。一般函数的输入参数和返回值都只能是变量或常量，如果某个函数可以接收函数作为其输入参数，或者其返回值中包含函数，那么该函数就是高阶函数。</p><p>Python 中有三个内建的用来支持函数式编程的高阶函数，分别是  <a href="https://docs.python.org/2.7/library/functions.html#filter" target="_blank" rel="noopener">filter()</a>，<a href="https://docs.python.org/2.7/library/functions.html#map" target="_blank" rel="noopener">map()</a> 和 <a href="https://docs.python.org/2.7/library/functions.html#reduce" target="_blank" rel="noopener">reduce()</a>。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter(function, sequence) 返回一个 sequence (序列)，返回的序列中包括了输入序列中所有调用 function(item) 后返回值为 true 的元素。</p><p>filter() 工作流程如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-274646d0478cb876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="how the filter() built-in function works"></p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(f, range(<span class="number">2</span>, <span class="number">25</span>))</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><p>因为 filter() 的输入参数中包含函数 f() ，所以 filter() 是高阶函数。上面的例子中返回 2~24 中能被 3 或 5 整除的数组成的列表。</p><p>当然，也可以使用匿名函数 lambda 表达式实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x : x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span>, range(<span class="number">2</span>, <span class="number">25</span>))</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><p>或者使用列表生成式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">25</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map() 与 filter() 相似，因为它也能通过函数来处理序列。map()<br>将函数调用“映射”到序列的每个元素上，并返回一个含有所有返回值的列表。</p><p>map() 工作流程如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-117f98c795acfd5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the map() built-in function works"></p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x**<span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(cube, range(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p>上面的例子中，将 1~10 里的每个数分别调用 cube() ，并将返回值（x 的 3 次方）放入列表中。</p><p>lambda 表达式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x : x**<span class="number">3</span>, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p>列表生成式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：map() 也可以处理多个序列。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: (x+y, x-y), [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[(<span class="number">3</span>, <span class="number">-1</span>), (<span class="number">7</span>, <span class="number">-1</span>), (<span class="number">11</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>工作流程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-881a52aa250e3bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the map() built-in function works with &gt; 1 sequence"></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce(function, sequence) 返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。</p><p>reduce() 工作流程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-b6f3bb3a8024a63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the reduce() built-in function works"></p><p>例如，以下程序计算 0 到 5 的整数之和:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span> <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>实际上 reduce() 执行了如下的运算：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">((((0+1)+2)+3)+4)   ==&gt;  10</span><br></pre></td></tr></table></figure><p>lambda 表达式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x, y : x + y, range(<span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值（类似于默认值）。</p><p>举个栗子：</p><p>int() 函数可以把字符串转换为整数，当仅传入字符串时，int() 函数默认按十进制转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>)</span><br><span class="line"><span class="number">11111</span></span><br></pre></td></tr></table></figure><p>但 int() 函数还提供额外的 base 参数（默认值为10） 。如果传入 base 参数，就可以做 N 进制的转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">4681</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>,base=<span class="number">16</span>)</span><br><span class="line"><span class="number">69905</span></span><br></pre></td></tr></table></figure><p>假设要转换大量的二进制字符串，每次都传入 int(x, base=2) 非常麻烦，于是，我们想到，可以定义一个 int2() 的函数，默认把 base=2 传进去：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br></pre></td></tr></table></figure><p>这样，我们就可以方便地转换二进制了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code> 就是帮助我们创建一个偏函数的，不需要我们自己定义 int2() ，可以直接使用下面的代码创建一个新的函数 int2 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>)</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'10000'</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>总结一下，<code>functools.partial</code> 的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>需要注意的是，上面的新的 int2 函数，仅仅是把 base 参数重新设定默认值为 2 ，但也可以在函数调用时传入其他值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>,base=<span class="number">10</span>)</span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>,base=<span class="number">8</span>)</span><br><span class="line"><span class="number">4681</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Python核心编程》</li><li>Python官方文档</li><li>廖雪峰的Python教程</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 Python 不是函数式编程语言（是命令式编程语言），但是支持许多有价值的函数式编程工具。Python 提供 3 种内建函数和 lambda 表达式等来支持函数式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://linbingdong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://linbingdong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关于Java字符串的几个常见问题</title>
    <link href="http://linbingdong.com/2017/03/11/%E5%85%B3%E4%BA%8EJava%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://linbingdong.com/2017/03/11/关于Java字符串的几个常见问题/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>列举几个关于Java字符串的常见问题并给出答案。</p><a id="more"></a><h3 id="1-如何比较两个字符串？用”-”还是”equals”"><a href="#1-如何比较两个字符串？用”-”还是”equals”" class="headerlink" title="1. 如何比较两个字符串？用”==”还是”equals”?"></a>1. 如何比较两个字符串？用”==”还是”equals”?</h3><ul><li>“==”对比的是引用是否相同（是否同一个对象）</li><li>“equals”对比的是值是否相同</li></ul><p>除非想要比较两个字符串是否是同一个对象，否则应该一直使用”equals”。</p><h3 id="2-为什么对安全性敏感的信息更喜欢用char-而不是String来存储？"><a href="#2-为什么对安全性敏感的信息更喜欢用char-而不是String来存储？" class="headerlink" title="2. 为什么对安全性敏感的信息更喜欢用char[]而不是String来存储？"></a>2. 为什么对安全性敏感的信息更喜欢用char[]而不是String来存储？</h3><p>因为String是不可变对象，这就意味着只要String被创建，它们就会一直存在直到被垃圾回收器收集。因此，用String保存的信息安全性会降低。</p><h3 id="3-在switch语句中可以使用字符串吗？"><a href="#3-在switch语句中可以使用字符串吗？" class="headerlink" title="3. 在switch语句中可以使用字符串吗？"></a>3. 在switch语句中可以使用字符串吗？</h3><p>从Java7开始，可以在switch语句中使用字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (aString) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">           value = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">           value = <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-如何将字符串转为int？"><a href="#4-如何将字符串转为int？" class="headerlink" title="4. 如何将字符串转为int？"></a>4. 如何将字符串转为int？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Integer.parseInt(<span class="string">"10"</span>);</span><br></pre></td></tr></table></figure><p>虽然很简单，但是使用频率很高。</p><h3 id="5-如何用空格切分字符串？"><a href="#5-如何用空格切分字符串？" class="headerlink" title="5. 如何用空格切分字符串？"></a>5. 如何用空格切分字符串？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strArray = aString.split(<span class="string">"\\s+"</span>);</span><br></pre></td></tr></table></figure><h3 id="6-substring-方法会创建一个新字符串吗？"><a href="#6-substring-方法会创建一个新字符串吗？" class="headerlink" title="6. substring()方法会创建一个新字符串吗？"></a>6. substring()方法会创建一个新字符串吗？</h3><p>从Java7开始，substring()方法会创建一个新的char数组，而不是使用已经存在的。</p><p>在Java6中，substring()方法不会创建一个新的char数组，如果想创建新的，可以用以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.substring(m,n) + <span class="string">""</span>;</span><br></pre></td></tr></table></figure><h3 id="7-String-vs-StringBuilder-vs-StringBuffer"><a href="#7-String-vs-StringBuilder-vs-StringBuffer" class="headerlink" title="7. String vs StringBuilder vs StringBuffer"></a>7. String vs StringBuilder vs StringBuffer</h3><p>String是不可变的，StringBuilder和StringBuffer都是可变的。</p><p>StringBuffer是同步的，线程安全的，效率低。</p><p>StringBuilder是非同步的，非线程安全，效率比StringBuffer高。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举几个关于Java字符串的常见问题并给出答案。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式系列文章——分布式系统的特点及问题</title>
    <link href="http://linbingdong.com/2017/03/11/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E9%97%AE%E9%A2%98/"/>
    <id>http://linbingdong.com/2017/03/11/分布式系列文章——分布式系统的特点及问题/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着数据量越来越大，计算机需要处理的业务越来越复杂，单机已经无法满足需求。一个有效的解决方案是把众多廉价的计算机整合起来，共同提供服务，这就是分布式系统。接下来介绍分布式系统的定义、特点，以及分布式环境中存在的问题和挑战。</p><a id="more"></a><h2 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h2><p>在《分布式系统概念与设计》一书中，对分布式系统做了 如下定义：</p><blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p></blockquote><p>也就是说一个分布式系统中的计算机在空间部署上可以是<strong>随意分布</strong>的，这些计算机可能被放在不同的机柜上，也可能在不同的机房中，甚至分布在不同的城市。这些计算机之间<strong>通过网络来通信</strong>。</p><h2 id="分布式的特点"><a href="#分布式的特点" class="headerlink" title="分布式的特点"></a>分布式的特点</h2><p>分布式系统有如下体征：</p><h3 id="分布性"><a href="#分布性" class="headerlink" title="分布性"></a>分布性</h3><p>分布式系统中的多台计算机在空间上随意分步。当然，机器的分布情况也会随时变动。</p><h3 id="对等性"><a href="#对等性" class="headerlink" title="对等性"></a>对等性</h3><p>分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是<strong>对等的</strong>。</p><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，比如数据库或分布式存储等。如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战。</p><h3 id="缺乏全局时钟"><a href="#缺乏全局时钟" class="headerlink" title="缺乏全局时钟"></a>缺乏全局时钟</h3><p>在分布式系统中，<strong>很难定义两个事件究竟谁先谁后</strong>，原因就是分布式系统缺乏一个全局的时钟控制序列。</p><h3 id="故障总是会发生"><a href="#故障总是会发生" class="headerlink" title="故障总是会发生"></a>故障总是会发生</h3><p>组成分布式系统的所有计算机，都有可能发生任何形式的故障。实践表明，在分布式系统中，计算机发生故障是比较常见的。因此，在分布式系统设计时，必须考虑到该问题。</p><h2 id="分布式环境的各种问题"><a href="#分布式环境的各种问题" class="headerlink" title="分布式环境的各种问题"></a>分布式环境的各种问题</h2><p>分布式系统体系结构从其出现之初就伴随着诸多的难题和挑战，本节介绍分布式系统中的一些典型的问题。</p><h3 id="通信异常"><a href="#通信异常" class="headerlink" title="通信异常"></a>通信异常</h3><p>分布式系统中个计算机之间是通过网络进行通信的。由于<strong>网络本身的不可靠性</strong>，每次网络通信都会伴随着网络不可用的风险。即使分布式系统各节点之间的网络通信能够正常进行，其延时也会远远大于单机操作。在分布式系统中，<strong>消息延时和消息丢失非常普遍</strong>。</p><h3 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h3><p>当网络发生异常情况，可能导致分布式系统中某些节点之间能够正常通信，而某些节点之间无法通信——该现象就是网络分区，就是俗称的『脑裂』。当网络分区出现时，分布式系统就会出现局部小集群，小集群内计算机可以相互通信，小集群之间计算机无法通信。这就对分布式一致性提出了非常大的挑战。</p><h3 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h3><p>因为在分布式系统中，网络可能会出现各式各样的问题，因此分布式系统的每一次请求和响应，存在特有的『三态』概念，即<strong>成功、失败与超时</strong>。在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的相应：成功或失败。而在分布式系统中，由于网络是不可靠的，当网络出现异常的情况下，就可能出现超时现象，发生消息丢失现象。</p><h3 id="节点故障"><a href="#节点故障" class="headerlink" title="节点故障"></a>节点故障</h3><p>节点故障是分布式环境下一个比较常见的问题，指的是组成分布式系统的服务器节点出现宕机或『僵死』现象。通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生。<br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着数据量越来越大，计算机需要处理的业务越来越复杂，单机已经无法满足需求。一个有效的解决方案是把众多廉价的计算机整合起来，共同提供服务，这就是分布式系统。接下来介绍分布式系统的定义、特点，以及分布式环境中存在的问题和挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性算法：Raft 算法（Raft 论文翻译）</title>
    <link href="http://linbingdong.com/2017/03/11/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%EF%BC%9ARaft%20%E7%AE%97%E6%B3%95%EF%BC%88Raft%20%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91%EF%BC%89/"/>
    <id>http://linbingdong.com/2017/03/11/分布式一致性算法：Raft 算法（Raft 论文翻译）/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Raft 算法是可以用来替代 Paxos 算法的分布式一致性算法，而且 raft 算法比 Paxos 算法更易懂且更容易实现。本文对 raft 论文进行翻译，希望能有助于读者更方便地理解 raft 的思想。如果对 Paxos 算法感兴趣，可以看我的另一篇文章：<a href="http://linbingdong.com/2016/12/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/">分布式系列文章——Paxos算法原理与推导</a></p><a id="more"></a><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟 multi-Paxos 作用相同，效率也相当，但是它的组织结构跟 Paxos 不同。这使得 Raft 比 Paxos 更容易理解并且更容易在工程实践中实现。为了使 Raft 协议更易懂，Raft 将一致性的关键元素分开，如 leader 选举、日志复制和安全性，并且它实施更强的一致性以减少必须考虑的状态的数量。用户研究的结果表明，Raft 比 Paxos 更容易学习。 Raft 还包括一个用于变更集群成员的新机制，它使用重叠的大多数（overlapping majorities）来保证安全性。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>一致性算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。 正因为如此，一致性算法在建立可靠的大规模软件系统方面发挥了关键作用。 在过去十年中，Paxos [15,16] 主导了关于一致性算法的讨论：大多数一致性的实现都是基于 Paxos 或受其影响，Paxos 已成为用于教授学生一致性相关知识的主要工具。</p><p>不幸的是，Paxos 实在是太难以理解，尽管许多人一直在努力尝试使其更易懂。 此外，其架构需要复杂的改变来支持实际系统。 结果是，系统开发者和学生都在与 Paxos 斗争。</p><p>在我们自己与 Paxos 斗争之后，我们开始着手寻找一个新的一致性算法，可以为系统开发和教学提供更好的基础。 我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以为实际系统定义一个一致性算法，并以比 Paxos 更容易学习的方式描述它吗？在该算法的设计过程中，重要的不仅是如何让该算法起作用，还有清晰地知道该算法为什么会起作用。</p><p>这项工作的结果是一个称为 Raft 的一致性算法。 在设计 Raft 时，我们使用了特定的技术来提高可理解性，包括分解（Raft 分离 leader 选举，日志复制和安全）和状态空间减少（相对于 Paxos ，Raft 减少了不确定性程度和服务器之间彼此不一致的方式 ）。 一项针对两个大学的 43 名学生的用户研究表明，Raft 比 Paxos 更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答关于 Raft 的问题。</p><p>Raft 在许多方面类似于现有的一致性算法（尤其是 Oki 和 Liskov 的 Viewstamped Replication [29,22]），但它有几个新特性：</p><ul><li><strong>Strong leader</strong>：在 Raft 中，日志条目（log entries）只从 leader 流向其他服务器。 这简化了复制日志的管理，使得 raft 更容易理解。</li><li><strong>Leader 选举</strong>：Raft 使用随机计时器进行 leader 选举。 这只需在任何一致性算法都需要的心跳（heartbeats）上增加少量机制，同时能够简单快速地解决冲突。</li><li><strong>成员变更</strong>：Raft 使用了一种新的联合一致性方法，其中两个不同配置的大多数在过渡期间重叠。 这允许集群在配置更改期间继续正常运行。</li></ul><p>我们认为，Raft 优于 Paxos 和其他一致性算法，不仅在教学方面，在工程实现方面也是。 它比其他算法更简单且更易于理解; 它被描述得十分详细足以满足实际系统的需要; 它有多个开源实现，并被多家公司使用; 它的安全性已被正式规定和验证; 它的效率与其他算法相当。</p><p>本文的剩余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优点和缺点（第3节），描述了我们实现易理解性的方法（第 4 节），提出了 Raft 一致性算法（第 5-8 节），评估 Raft（第 9 节），并讨论了相关工作（第 10 节）。</p><h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2 复制状态机"></a>2 复制状态机</h2><p>一致性算法是在复制状态机[37]的背景下产生的。 在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器宕机，也可以继续运行。</p><p>复制状态机用于解决分布式系统中的各种容错问题。 例如，具有单个 leader 的大规模系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33] ，通常使用单独的复制状态机来进行 leader 选举和存储 leader 崩溃后重新选举需要的配置信息。Chubby [2] 和 ZooKeeper [11] 都是复制状态机。</p><p>复制状态机通常使用复制日志实现，如图 1 所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行日志中的命令。 每个日志中命令都相同并且顺序也一样，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-b2e0dc4401aefd3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p><p>一致性算法的工作就是保证复制日志的一致性。 每台服务器上的一致性模块接收来自客户端的命令，并将它们添加到其日志中。 它与其他服务器上的一致性模块通信，以确保每个日志最终以相同的顺序包含相同的命令，即使有一些服务器失败。 一旦命令被正确复制，每个服务器上的状态机按日志顺序处理它们，并将输出返回给客户端。 这样就形成了高可用的复制状态机。</p><p>实际系统中的一致性算法通常具有以下属性：</p><ul><li><p>它们确保在所有非拜占庭条件下（包括网络延迟，分区和数据包丢失，重复和乱序）的安全性（不会返回不正确的结果）。</p></li><li><p>只要任何大多数（过半）服务器都可以运行，并且可以相互通信和与客户通信，一致性算法就可用。 因此，五台服务器的典型集群可以容忍任何两台服务器的故障。 假设服务器突然宕机，它们可以稍后从状态恢复并重新加入群集。</p></li><li><p>它们不依赖于时序来确保日志的一致性：错误的时钟和极端消息延迟在最坏的情况下会导致可用性问题（译者注：言外之意是可以保证一致性）。</p></li><li><p>在通常情况下，只要集群的大部分（过半服务器）已经响应了单轮远程过程调用，命令就可以完成; 少数（一半以下）慢服务器不会影响整个系统性能。</p></li></ul><h2 id="3-Paxos-存在的问题"><a href="#3-Paxos-存在的问题" class="headerlink" title="3 Paxos 存在的问题"></a>3 Paxos 存在的问题</h2><p>在过去十年里，Leslie Lamport 的 Paxos 协议[15]几乎成为一致性的同义词：它是课堂上教授最多的一致性协议，并且大多数一致性的实现也以它为起点。 Paxos 首先定义了能够在单个决策（例如单个复制日志条目）上达成一致的协议。 我们将这个子集称为 single-decree Paxos。 然后 Paxos 组合该协议的多个实例以促进一系列决策，例如日志（multi-Paxos）。 Paxos能够确保安全性和活性，并且支持集群成员的变更。它的正确性已被证明，并且在正常情况下是高效的。</p><p>不幸的是，Paxos 有两个显著的缺点。 第一个缺点是 Paxos 非常难以理解。 Paxos 的描述晦涩难懂，臭名昭著（译者注：《The Part-time Parliament》比较晦涩难懂，但是《Paxos Made Simple》就比较容易理解）; 很少有人成功地理解它，即使能理解也必须付出巨大的努力。 因此，已有几个尝试用更简单的方式来描述 Paxos [16,20,21] 。 这些描述集中在 single-degree Paxos ，但它们仍然具有挑战性。 在对 NSDI 2012 参会者的非正式调查中，我们发现很少有人喜欢 Paxos ，即使是经验丰富的研究人员。 我们自己也跟 Paxos 进行了艰苦的斗争; 我们也无法完全理解整个协议，直到阅读了几个更简单的描述和自己设计替代 Paxos 的协议，整个过程花了将近一年。</p><p>Paxos 晦涩难懂的原因是作者选择了single-degree Paxos作为基础。Single-decree Paxos 分成两个阶段，这两个阶段没有简单直观的说明，并且不能被单独理解。因此，很难理解为什么该算法能起作用。Multi-Paxos 的合成规则又增加了许多复杂性。我们相信，对多个决定（日志而不是单个日志条目）达成一致的总体问题可以用其他更直接和更明显的方式进行分解。</p><p>Paxos的第二个问题是它不能为构建实际的实现提供良好的基础。 一个原因是没有针对 multi-Paxos 的广泛同意的算法。 Lamport的描述主要是关于 single-decree Paxos; 他描述了 multi-Paxos 的可能方法，但缺少许多细节。 已经有几个尝试来具体化和优化 Paxos ，例如[26]，[39]和[13]，但这些彼此各不相同并且跟 Lamport 描述的也不同。 像Chubby [4] 这样的系统已经实现了类 Paxos（Paxos-like）算法，但大多数情况下，它们的细节并没有公布。</p><p>此外，Paxos 的架构对于构建实际系统来说是一个糟糕的设计，这是 single-decree 分解的另一个结果。 例如，独立地选择日志条目集合，然后再将它们合并到顺序日志中几乎没有任何好处，这只会增加复杂性。 围绕日志设计系统是更简单和有效的方法，新日志条目按照约束顺序地添加到日志中。 Paxos 的做法适用于只需要做一次决策的情况，如果需要做一系列决策，更简单和快速的方法是先选择一个 leader ，然后让该 leader 协调这些决策。</p><p>因此，实际的系统跟 Paxos 相差很大。几乎所有的实现都是从 Paxos 开始，然后发现很多实现上的难题，接着就开发了一种和 Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos 本身晦涩难懂使得该问题更加严重。Paxos 的公式可能可以很好地证明它的正确性，但是现实的系统和 Paxos 差别是如此之大，以至于这些证明并没有什么太大的价值。下面来自 Chubby 作者的评论非常典型：</p><blockquote><p>在Paxos算法描述和实现现实系统之间有着巨大的鸿沟。最终的系统往往建立在一个还未被证明的协议之上。</p></blockquote><p>由于以上问题，我们得出的结论是 Paxos 算法没有为系统实践和教学提供一个良好的基础。考虑到一致性问题在大规模软件系统中的重要性，我们决定尝试设计一个能够替代 Paxos 并且具有更好特性的一致性算法。Raft算法就是这次实验的结果。</p><h2 id="4-为可理解性而设计"><a href="#4-为可理解性而设计" class="headerlink" title="4 为可理解性而设计"></a>4 为可理解性而设计</h2><p>在设计 Raft 算法过程中我们有几个目标：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在典型的应用条件下是可用的；并且在正常情况下是高效的。但是我们最重要的目标也是最大的挑战是可理解性。它必须保证能够被大多数人容易地理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行扩展。</p><p>在设计 Raft 算法的时候，很多情况下我们需要在多个备选方案中进行选择。在这种情况下，我们基于可理解性来评估备选方案：解释各个备选方案的难道有多大（例如，Raft 的状态空间有多复杂，是否有微妙的含义）？对于一个读者而言，完全理解这个方案和含义是否容易？</p><p>我们意识到这样的分析具有高度的主观性；但是我们使用了两种通用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成 leader 选举，日志复制，安全性和成员变更几个部分。</p><p>我们使用的第二个方法是通过减少状态的数量来简化状态空间，使得系统更加连贯并且尽可能消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了使日志之间不一致的方式。尽管在大多数情况下我们都试图去消除不确定性，但是在某些情况下不确定性可以提高可理解性。特别是，随机化方法虽然引入了不确定性，但是他们往往能够通过使用相近的方法处理可能的选择来减少状态空间。我们使用随机化来简化 Raft 中的 leader 选举算法。</p><h2 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h2><p>Raft 是一种用来管理第 2 节中描述的复制日志的算法。图 2 是该算法的浓缩，可用作参考，图 3 列举了该算法的一些关键特性。图中的这些内容将在剩下的章节中逐一介绍。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-07c1c597333affd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-15c4d42eb6548a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3"></p><p>Raft 通过首先选举一个 distinguished leader，然后让它全权负责管理复制日志来实现一致性。Leader 从客户端接收日志条目，把日志条目复制到其他服务器上，并且在保证安全性的时候通知其他服务器将日志条目应用到他们的状态机中。拥有一个 leader 大大简化了对复制日志的管理。例如，leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都是从 leader 流向其他服务器。leader 可能宕机，也可能和其他服务器断开连接，这时一个新的 leader 会被选举出来。</p><p>通过选举一个 leader 的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p><ul><li><strong>Leader 选举</strong>：当前的 leader 宕机时，一个新的 leader 必须被选举出来。（5.2 节）</li><li><strong>日志复制</strong>：Leader 必须从客户端接收日志条目然后复制到集群中的其他节点，并且强制要求其他节点的日志和自己的保持一致。</li><li><strong>安全性</strong>：Raft 中安全性的关键是图 3 中状态机的安全性：如果有任何的服务器节点已经应用了一个特定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一条不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；该解决方案在选举机制（5.2 节）上增加了额外的限制。</li></ul><p>在展示一致性算法之后，本章节将讨论可用性的一些问题以及时序在系统中的作用。</p><h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这样的系统可以容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：leader、follower 或者 candidate 。在正常情况下，集群中只有一个 leader 并且其他的节点全部都是 follower 。Follower 都是被动的：他们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 follower 通信，follower 会将请求重定向给 leader）。第三种状态，candidate ，是用来选举一个新的 leader（章节 5.2）。图 4 展示了这些状态和他们之间的转换关系；这些转换关系在接下来会进行讨论。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-b308efb041bee9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4"></p><p>Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。Raft 保证了在任意一个任期内，最多只有一个 leader 。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a405ff884cfcac10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5"></p><p>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间使用 RPC 进行通信，并且基本的一致性算法只需要两种类型的 RPC。请求投票（RequestVote） RPC 由 candidate 在选举期间发起（章节 5.2），追加条目（AppendEntries）RPC 由 leader 发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPC 来获得最佳的性能。</p><h3 id="5-2-Leader-选举"><a href="#5-2-Leader-选举" class="headerlink" title="5.2 Leader 选举"></a>5.2 Leader 选举</h3><p>Raft 使用一种心跳机制来触发 leader 选举。当服务器程序启动时，他们都是 follower 。一个服务器节点只要能从 leader 或 candidate 处接收到有效的 RPC 就一直保持 follower 状态。Leader 周期性地向所有 follower 发送心跳（不包含日志条目的 AppendEntries RPC）来维持自己的地位。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的 leader 。</p><p>要开始一次选举过程，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己并且并行地向集群中的其他服务器节点发送 RequestVote RPC（让其他服务器节点投票给它）。Candidate 会一直保持当前状态直到以下三件事情之一发生：(a) 它自己赢得了这次的选举（收到过半的投票），(b) 其他的服务器节点成为 leader ，(c) 一段时间之后没有任何获胜者。这些结果会在下面的章节里分别讨论。</p><p>当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。对于同一个任期，每个服务器节点只会投给一个 candidate ，按照先来先服务（first-come-first-served）的原则（注意：5.4 节在投票上增加了额外的限制）。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举（图 3 中的选举安全性）。一旦 candidate 赢得选举，就立即成为 leader 。然后它会向其他的服务器节点发送心跳消息来确定自己的地位并阻止新的选举。</p><p>在等待投票期间，candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号（包含在RPC中）不小于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p><p>第三种可能的结果是 candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。</p><p>Raft 算法使用随机选举超时时间的方法来确保很少发生选票瓜分的情况，就算发生也能很快地解决。为了阻止选票一开始就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后该服务器赢得选举并在其他服务器超时之前发送心跳。同样的机制被用来解决选票被瓜分的情况。每个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后一直等待直到选举超时；这样减小了在新的选举中再次发生选票瓜分情况的可能性。9.3 节展示了该方案能够快速地选出一个 leader 。</p><p>选举的例子可以很好地展示可理解性是如何指导我们选择设计方案的。起初我们打算使用一种等级系统（ranking system）：每一个 candidate 都被赋予一个唯一的等级（rank），等级用来在竞争的 candidate 之间进行选择。如果一个 candidate 发现另一个 candidate 拥有更高的等级，它就会回到 follower 状态，这样高等级的 candidate 能够更加容易地赢得下一次选举。但是我们发现这种方法在可用性方面会有一下小问题。我们对该算法进行了多次调整，但是每次调整之后都会有新的小问题。最终我们认为随机重试的方法更加显然且易于理解。</p><h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 AppendEntries RPC 给其他的服务器，让它们复制该条目。当该条目被安全地复制（下面会介绍），leader 会应用该条目到它的状态机中（状态机执行该指令）然后把执行的结果返回给客户端。如果 follower 崩溃或者运行缓慢，或者网络丢包，leader 会不断地重试 AppendEntries RPC（即使已经回复了客户端）直到所有的 follower 最终都存储了所有的日志条目。</p><p>日志以图 6 展示的方式组织。每个<strong>日志条目</strong>存储一条<strong>状态机指令</strong>和 leader 收到该指令时的<strong>任期号</strong>。任期号用来检测多个日志副本之间的不一致情况，同时也用来保证图 3 中的某些性质。每个日志条目都有一个整数索引值来表明它在日志中的位置。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6ceba6710280cbaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6"></p><p>Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交的</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就会被提交（例如在图 6 中的条目 7）。同时，leader 日志中该日志条目之前的所有日志条目也都会被提交，包括由其他 leader 创建的条目。5.4 节讨论在 leader 变更之后应用该规则的一些细节，并且证明了这种提交的规则是安全的。Leader 追踪将会被提交的日志条目的最大索引，未来的所有 AppendEntries RPC 都会包含该索引，这样其他的服务器才能最终知道哪些日志条目需要被提交。Follower 一旦知道某个日志条目已经被提交就会将该日志条目应用到自己的本地状态机中（按照日志的顺序）。</p><p>我们设计了 Raft 日志机制来维持不同服务器之间日志高层次的一致性。这么做不仅简化了系统的行为也使得系统行为更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 维护着以下特性，这些同时也构成了图 3 中的日志匹配特性：</p><ul><li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li><li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li></ul><p>Leader 在特定的任期号内的一个日志索引处最多创建一个日志条目，同时日志条目在日志中的位置也从来不会改变。该点保证了上面的第一条特性。第二个特性是由 AppendEntries RPC 执行一个简单的一致性检查所保证的。在发送 AppendEntries RPC 的时候，leader 会将前一个日志条目的索引位置和任期号包含在里面。如果 follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足 Log Matching Property（日志匹配特性） 的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，每当 AppendEntries RPC 返回成功时，leader 就知道 follower 的日志一定和自己相同（从第一个日志条目到最新条目）。</p><p>正常操作期间，leader 和 follower 的日志保持一致，所以 AppendEntries RPC 的一致性检查从来不会失败。然而，leader 崩溃的情况会使日志处于不一致的状态（老的 leader 可能还没有完全复制它日志里的所有条目）。这种不一致会在一系列的 leader 和 follower 崩溃的情况下加剧。图 7 展示了在什么情况下 follower 的日志可能和新的 leader 的日志不同。Follower 可能缺少一些在新 leader 中有的日志条目，也可能拥有一些新 leader 没有的日志条目，或者同时发生。缺失或多出日志条目的情况可能会涉及到多个任期。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-fc1352afc54b5ce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7"></p><blockquote><p>图 7：当一个 leader 成功当选时（最上面那条日志），follower 可能是（a-f）中的任何情况。每一个盒子表示一个日志条目；里面的数字表示任期号。Follower 可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能这样发生，f 对应的服务器在任期 2 的时候是 leader ，追加了一些日志条目到自己的日志中，一条都还没提交（commit）就崩溃了；该服务器很快重启，在任期 3 重新被选为 leader，又追加了一些日志条目到自己的日志中；在这些任期 2 和任期 3 中的日志都还没被提交之前，该服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p></blockquote><p>在 Raft 算法中，leader 通过强制 follower 复制它的日志来解决不一致的问题。这意味着 follower 中跟 leader 冲突的日志条目会被 leader 的日志条目覆盖。5.4 节会证明通过增加一个限制可以保证安全性。</p><p>要使得 follower 的日志跟自己一致，leader 必须找到两者达成一致的最大的日志条目（索引最大），删除 follower 日志中从那个点之后的所有日志条目，并且将自己从那个点之后的所有日志条目发送给 follower 。所有的这些操作都发生在对 AppendEntries RPCs 中一致性检查的回复中。Leader 针对每一个 follower 都维护了一个 nextIndex ，表示 leader 要发送给 follower 的下一个日志条目的索引。当选出一个新 leader 时，该 leader 将所有 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图 7 中的 11）。如果 follower 的日志和 leader 的不一致，那么下一次 AppendEntries RPC 中的一致性检查就会失败。在被 follower 拒绝之后，leaer 就会减小 nextIndex 值并重试 AppendEntries RPC 。最终 nextIndex 会在某个位置使得 leader 和 follower 的日志达成一致。此时，AppendEntries RPC 就会成功，将 follower 中跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（如果有需要追加的日志条目的话）。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 一致，并且在该任期接下来的时间里保持一致。</p><blockquote><p>如果想要的话，该协议可以被优化来减少被拒绝的 AppendEntries RPC 的个数。例如，当拒绝一个 AppendEntries RPC 的请求的时候，follower 可以包含冲突条目的任期号和自己存储的那个任期的第一个 index 。借助这些信息，leader  可以跳过那个任期内所有冲突的日志条目来减小 nextIndex；这样就变成每个有冲突日志条目的任期需要一个 AppendEntries RPC 而不是每个条目一次。在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p></blockquote><p>通过这种机制，leader 在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。Leader 只需要进行正常的操作，然后日志就能在回复 AppendEntries 一致性检查失败的时候自动趋于一致。Leader 从来不会覆盖或者删除自己的日志条目（图 3 的 Leader Append-Only 属性）。</p><p>这样的日志复制机制展示了第 2 节中描述的一致性特性：只要过半的服务器能正常运行，Raft 就能够接受，复制并应用新的日志条目；在正常情况下，新的日志条目可以在一个 RPC 来回中被复制给集群中的过半机器；并且单个运行慢的 follower 不会影响整体的性能。</p><h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何进行 leader 选举和日志复制的。然而，到目前为止描述的机制并不能充分地保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目，然后这个 follower 可能会被选举为 leader 并且用新的日志条目覆盖这些日志条目；结果，不同的状态机可能会执行不同的指令序列。</p><p>这节通过对 leader 选举增加一个限制来完善 Raft 算法。这一限制保证了对于给定的任意任期号， leader 都包含了之前各个任期所有被提交的日志条目（图 3 中的 Leader Completeness 性质）。有了这一 leader 选举的限制，我们也使得提交规则更加清晰。最后，我们展示了对于 Leader Completeness 性质的简要证明并且说明该性质是如何领导复制状态机执行正确的行为的。</p><h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于 leader 的一致性算法中，leader 最终都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication[22]，一开始并没有包含所有已经提交的日志条目的服务器也可能被选为 leader 。这种算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的 leader ，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证新 leader 在当选时就包含了之前所有任期号中已经提交的日志条目，不需要再传送这些日志条目给新 leader 。这意味着日志条目的传送是单向的，只从 leader 到 follower，并且 leader 从不会覆盖本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止 candidate 赢得选举除非该 candidate 包含了所有已经提交的日志条目。候选人为了赢得选举必须与集群中的过半节点通信，这意味着至少其中一个服务器节点包含了所有已提交的日志条目。如果 candidate 的日志至少和过半的服务器节点一样新（接下来会精确地定义“新”），那么他一定包含了所有已经提交的日志条目。RequestVote RPC 执行了这样的限制： RPC 中包含了 candidate 的日志信息，如果投票者自己的日志比 candidate 的还新，它会拒绝掉该投票请求。</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。如果两份日志最后条目的任期号不同，那么任期号大的日志更新。如果两份日志最后条目的任期号相同，那么日志较长的那个更新。</p><h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节描述的那样，一旦当前任期内的某个日志条目已经存储到过半的服务器节点上，leader 就知道该日志条目已经被提交了。如果某个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会试图完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到过半的服务器节点上，leader 也无法立即断定该日志条目已经被提交了。图 8 展示了一种情况，一个已经被存储到过半节点上的老日志条目，仍然有可能会被未来的 leader 覆盖掉。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-f23fc91c5094c2cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8"></p><blockquote><p>图 8：如图的时间序列展示了为什么 leader 无法判断老的任期号内的日志是否已经被提交。在 (a) 中，S1 是 leader ，部分地复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 中通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，继续复制日志。此时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这种情况下，之前的所有日志也被提交了。</p></blockquote><p>为了消除图 8 中描述的问题，Raft 永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader 当前任期内的日志条目才通过计算副本数目的方式来提交；一旦当前任期的某个日志条目以这种方式被提交，那么由于日志匹配特性，之前的所有日志条目也都会被间接地提交。在某些情况下，领导人可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。</p><p>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的一致性算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出（reason about）日志条目，因为他们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p><h4 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h4><p>在给出了完整的 Raft 算法之后，我们现在可以更加精确的讨论 leader 完整性特性（Leader Completeness Prop-erty）（这一讨论基于 9.2 节的安全性证明）。我们假设 leader 完整性特性是不满足的，然后我们推出矛盾来。假设任期 T 的 leader（leader T）在任期内提交了一个日志条目，但是该日志条目没有被存储到未来某些任期的 leader 中。假设 U 是大于 T 的没有存储该日志条目的最小任期号。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-03fb8b6791409bb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9"></p><blockquote><p>图 9：如果 S1 （任期 T 的 leader）在它的任期里提交了一个新的日志条目，然后 S5 在之后的任期 U 里被选举为 leader ，那么肯定至少会有一个节点，如 S3，既接收了来自 S1 的日志条目，也给 S5 投票了。</p></blockquote><ol><li><p>U 一定在刚成为 leader 的时候就没有那条被提交的日志条目了（leader 从不会删除或者覆盖任何条目）。</p></li><li><p>Leader T 复制该日志条目给集群中的过半节点，同时，leader U 从集群中的过半节点赢得了选票。因此，至少有一个节点（投票者）同时接受了来自 leader T 的日志条目和给 leader U 投票了，如图 9。该投票者是产生矛盾的关键。</p></li><li><p>该投票者必须在给 leader U 投票之前先接受了从 leader T 发来的已经被提交的日志条目；否则它就会拒绝来自 leader T 的 AppendEntries 请求（因为此时它的任期号会比 T 大）。</p></li><li><p>该投票者在给 leader U 投票时依然保有这该日志条目，因为任何 U 、T 之间的 leader 都包含该日志条目（根据上述的假设），leader 从不会删除条目，并且 follower 只有跟 leader 冲突的时候才会删除条目。</p></li><li><p>该投票者把自己选票投给 leader U 时，leader U 的日志必须至少和投票者的一样新。这就导致了以下两个矛盾之一。</p></li><li><p>首先，如果该投票者和 leader U 的最后一个日志条目的任期号相同，那么 leader U 的日志至少和该投票者的一样长，所以 leader U 的日志一定包含该投票者日志中的所有日志条目。这是一个矛盾，因为该投票者包含了该已被提交的日志条目，但是在上述的假设里，leader U 是不包含的。</p></li><li><p>否则，leader U 的最后一个日志条目的任期号就必须比该投票者的大了。此外，该任期号也比 T 大，因为该投票者的最后一个日志条目的任期号至少和 T 一样大（它包含了来自任期 T 的已提交的日志）。创建了 leader U 最后一个日志条目的之前的 leader 一定已经包含了该已被提交的日志条目（根据上述假设，leader U 是第一个不包含该日志条目的 leader）。所以，根据日志匹配特性，leader U 一定也包含该已被提交的日志条目，这里产生了矛盾。</p></li><li><p>因此，所有比 T 大的任期的 leader 一定都包含了任期 T 中提交的所有日志条目。</p></li><li><p>日志匹配特性保证了未来的 leader 也会包含被间接提交的日志条目，例如图 8 (d) 中的索引 2。</p></li></ol><p>通过 Leader 完整性特性，我们就能证明图 3 中的状态机安全特性，即如果某个服务器已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的服务器就不会在相同的索引处应用一个不同的日志条目。在一个服务器应用一个日志条目到自己的状态机中时，它的日志和 leader 的日志从开始到该日志条目都相同，并且该日志条目必须被提交。现在考虑如下最小任期号：某服务器在该任期号中某个特定的索引处应用了一个日志条目；日志完整性特性保证拥有更高任期号的 leader 会存储相同的日志条目，所以之后任期里服务器应用该索引处的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 要求服务器按照日志索引顺序应用日志条目。再加上状态机安全特性，这就意味着所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中。</p><h3 id="5-5-Follower-和-candidate-崩溃"><a href="#5-5-Follower-和-candidate-崩溃" class="headerlink" title="5.5 Follower 和 candidate 崩溃"></a>5.5 Follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。Follower 和 candidate 崩溃后的处理方式比 leader 崩溃要简单的多，并且两者的处理方式是相同的。如果 follower 或者 candidate 崩溃了，那么后续发送给他们的 RequestVote 和 AppendEntries RPCs 都会失败。Raft 通过无限的重试来处理这种失败；如果崩溃的机器重启了，那么这些 RPC 就会成功地完成。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在它重启之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样的重试不会造成任何伤害。例如，一个 follower 如果收到 AppendEntries 请求但是它的日志中已经包含了这些日志条目，它就会直接忽略这个新的请求中的这些日志条目。</p><h3 id="5-6-定时（timing）和可用性"><a href="#5-6-定时（timing）和可用性" class="headerlink" title="5.6 定时（timing）和可用性"></a>5.6 定时（timing）和可用性</h3><p>Raft 的要求之一就是安全性不能依赖定时：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。但是，可用性（系统能够及时响应客户端）不可避免的要依赖于定时。例如，当有服务器崩溃时，消息交换的时间就会比正常情况下长，candidate 将不会等待太长的时间来赢得选举；没有一个稳定的 leader ，Raft 将无法工作。</p><p>Leader 选举是 Raft 中定时最为关键的方面。 只要整个系统满足下面的时间要求，Raft 就可以选举出并维持一个稳定的 leader：</p><blockquote><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><p>在这个不等式中，广播时间指的是一个服务器并行地发送 RPCs 给集群中所有的其他服务器并接收到响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举超时时间；平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须比选举超时时间小一个量级，这样 leader 才能够可靠地发送心跳消息来阻止 follower 开始进入选举状态；再加上随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定地运行。当 leader 崩溃后，整个系统会有大约选举超时时间不可用；我们希望该情况在整个时间里只占一小部分。</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化地保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒之间，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的要求。</p><h2 id="6-集群成员变更"><a href="#6-集群成员变更" class="headerlink" title="6 集群成员变更"></a>6 集群成员变更</h2><p>到目前为止，我们都假设集群的配置（参与一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔会改变集群的配置的，例如替换那些宕机的机器或者改变复制程度。尽管可以通过使整个集群下线，更新所有配置，然后重启整个集群的方式来实现，但是在更改期间集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定将配置变更自动化并将其纳入到 Raft 一致性算法中来。</p><p>为了使配置变更机制能够安全，在转换的过程中不能够存在任何时间点使得同一个任期里可能选出两个 leader 。不幸的是，任何服务器直接从旧的配置转换到新的配置的方案都是不安全的。一次性自动地转换所有服务器是不可能的，所以在转换期间整个集群可能划分成两个独立的大多数（见图 10）。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-284d88f08ab84f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10"></p><blockquote><p>图 10：直接从一种配置转到另一种配置是不安全的，因为各个机器会在不同的时候进行转换。在这个例子中，集群从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，同一个任期里两个不同的 leader 会被选出。一个获得旧配置里过半机器的投票，一个获得新配置里过半机器的投票。</p></blockquote><p>为了保证安全性，配置变更必须采用一种两阶段方法。目前有很多种两阶段的实现。例如，有些系统（比如，[22]）在第一阶段停掉旧的配置所以不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为联合一致（joint consensus）；一旦联合一致已经被提交了，那么系统就切换到新的配置上。联合一致结合了老配置和新配置：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为 leader 。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得过半的支持。</li></ul><p>联合一致允许独立的服务器在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合一致允许集群在配置变更期间依然响应客户端请求。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6a440c013876545a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11"></p><p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置变更过程。当一个 leader 接收到一个改变配置从 C-old 到 C-new 的请求，它就为联合一致将该配置（图中的 C-old,new）存储为一个日志条目，并以前面描述的方式复制该条目。一旦某个服务器将该新配置日志条目增加到自己的日志中，它就会用该配置来做出未来所有的决策（服务器总是使用它日志中最新的配置，无论该配置日志是否已经被提交）。这就意味着 leader 会使用 C-old,new 的规则来决定 C-old,new 的日志条目是什么时候被提交的。如果 leader 崩溃了，新 leader 可能是在 C-old 配置也可能是在 C-old,new 配置下选出来的，这取决于赢得选举的 candidate 是否已经接收到了 C-old,new 配置。在任何情况下， C-new 在这一时期都不能做出单方面决定。</p><p>一旦 C-old,new 被提交，那么 C-old 和 C-new 都不能在没有得到对方认可的情况下做出决定，并且 leader 完整性特性保证了只有拥有 C-old,new 日志条目的服务器才能被选举为 leader 。现在 leader 创建一个描述 C-new 配置的日志条目并复制到集群其他节点就是安全的了。此外，新的配置被服务器收到后就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新配置的服务器就可以被关闭了。如图 11 所示，任何时刻 C-old 和 C-new 都不能单方面做出决定；这保证了安全性。</p><p>在关于配置变更还有三个问题需要解决。第一个问题是，新的服务器开始时可能没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，它们需要一段时间来更新来赶上其他服务器，这段它们无法提交新的日志条目。为了避免因此而造成的系统短时间的不可用，Raft 在配置变更前引入了一个额外的阶段，在该阶段，新的服务器以没有投票权身份加入到集群中来（leader 也复制日志给它们，但是考虑过半的时候不用考虑它们）。一旦该新的服务器追赶上了集群中的其他机器，配置变更就可以按上面描述的方式进行。</p><p>第二个问题是，集群的 leader 可能不是新配置中的一员。在这种情况下，leader 一旦提交了 C-new 日志条目就会退位（回到 follower 状态）。这意味着有这样的一段时间（leader 提交 C-new 期间），leader 管理着一个不包括自己的集群；它复制着日志但不把自己算在过半里面。Leader 转换发生在 C-new 被提交的时候，因为这是新配置可以独立运转的最早时刻（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p><p>第三个问题是，那些被移除的服务器（不在 C-new 中）可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，它们就会进行新的选举过程。它们会发送带有新任期号的 RequestVote RPCs ，这样会导致当前的 leader 回到 follower 状态。新的 leader 最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致系统可用性很差。</p><p>为了防止这种问题，当服务器认为当前 leader 存在时，服务器会忽略RequestVote RPCs 。特别的，当服务器在最小选举超时时间内收到一个 RequestVote RPC，它不会更新任期号或者投票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待最小选举超时时间。相反，这有利于避免被移除的服务器的扰乱：如果 leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p><h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7 日志压缩"></a>7 日志压缩</h2><p>Raft 的日志在正常操作中随着包含更多的客户端请求不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来回放。如果没有一定的机制来清除日志中积累的过期的信息，最终就会带来可用性问题。</p><p>快照技术是日志压缩最简单的方法。在快照技术中，整个当前系统的状态都以快照的形式持久化到稳定的存储中，该时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p><p>增量压缩方法，例如日志清理或者日志结构合并树（log-structured merge trees，LSM 树），都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，它们先选择一个积累了大量已经被删除或者被覆盖的对象的数据区域，然后重写该区域还活着的对象，之后释放该区域。和快照技术相比，它们需要大量额外的机制和复杂性，快照技术通过操作整个数据集来简化该问题。状态机可以用和快照技术相同的接口来实现 LSM 树，但是日志清除方法就需要修改 Raft 了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-708be6a9e8be699d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图12"></p><blockquote><p>一台服务器用一个新快照替代了它日志中已经提交了的条目（索引 1 到 5），该快照只存储了当前的状态（变量 x 和 y 的值）。快照的 last included index 和 last included term 被保存来定位日志中条目 6 之前的快照</p></blockquote><p>图 12 展示了 Raft 中快照的基本思想。每个服务器独立地创建快照，快照只包括自己日志中已经被提交的条目。主要的工作是状态机将自己的状态写入快照中。Raft 快照中也包含了少量的元数据：the last included index 指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目），the last included term 是该条目的任期号。保留这些元数据是为了支持快照后第一个条目的 AppendEntries 一致性检查，因为该条目需要之前的索引值和任期号。为了支持集群成员变更（第 6 节），快照中也包括日志中最新的配置作为 last included index 。一旦服务器完成写快照，他就可以删除 last included index 之前的所有日志条目，包括之前的快照。</p><p>尽管通常服务器都是独立地创建快照，但是 leader 必须偶尔发送快照给一些落后的跟随者。这通常发生在 leader 已经丢弃了需要发送给 follower 的下一条日志条目的时候。幸运的是这种情况在常规操作中是不可能的：一个与 leader 保持同步的 follower 通常都会有该日志条目。然而一个例外的运行缓慢的 follower 或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让该 follower 更新到最新的状态的方式就是通过网络把快照发送给它。</p><p>Leader 使用 InstallSnapshot RPC 来发送快照给太落后的 follower ；见图 13。当 follower 收到带有这种 RPC 的快照时，它必须决定如何处理已经存在的日志条目。通常该快照会包含接收者日志中没有的信息。在这种情况下，follower 丢弃它所有的日志；这些会被该快照所取代，并且可能一些没有提交的条目会和该快照产生冲突。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目仍然有用并保留。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-97e86b90137791b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图13"></p><p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower 可以在不知道 leader 状态的情况下创建快照。但是我们认为这种违背是合乎情理的。Leader 的存在，是为了防止在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，因此没有决策会冲突。数据依然只能从 leader 流到 follower ，只是 follower 可以重新组织它们的数据了。</p><p>我们考虑过一种可替代的基于 leader 的快照方案，在该方案中，只有leader 会创建快照，然后 leader 会发送它的快照给所有的 follower 。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照过程。每个 follower 都已经拥有了创建自己的快照所需要的信息，而且很显然，follower 从本地的状态中创建快照远比通过网络接收别人发来的要来得经济。第二，leader 的实现会更加复杂。例如，leader 发送快照给 follower 的同时也要并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求。</p><p>还有两个问题会影响快照的性能。首先，服务器必须决定什么时候创建快照。如果快照创建过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，就要承担耗尽存储容量的风险，同时也增加了重启时日志回放的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽负载就会很小。</p><p>第二个性能问题就是写入快照需要花费一段时间，并且我们不希望它影响到正常的操作。解决方案是通过写时复制的技术，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛函数据结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如 Linux 上的 fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p><h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8 客户端交互"></a>8 客户端交互</h2><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 的客户端发送所有的请求给 leader 。当客户端第一次启动的时候，它会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是 leader ，那么该服务器会拒绝客户端的请求并且提供关于它最近接收到的领导人的信息（AppendEntries 请求包含了 leader 的网络地址）。如果 leader 已经崩溃了，客户端请求就会超时；客户端之后会再次随机挑选服务器进行重试。</p><p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在它的调用和回复之间）。但是，如上述，Raft 可能执行同一条命令多次：例如，如果 leader 在提交了该日志条目之后，响应客户端之前崩溃了，那么客户端会和新的 leader 重试这条指令，导致这条命令被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的回复。如果接收到一条指令，该指令的序列号已经被执行过了，就立即返回结果，而不重新执行该请求。</p><p>只读的操作可以直接处理而不需要记录日志。但是，如果不采取任何其他措施，这么做可能会有返回过时数据（stale data）的风险，因为 leader 响应客户端请求时可能已经被新的 leader 替代了，但是它还不知道自己已经不是最新的 leader 了。线性化的读操作肯定不会返回过时数据，Raft 需要使用两个额外的预防措施来在不使用日志的情况下保证这一点。首先，leader 必须有关于哪些日志条目被提交了的最新信息。Leader 完整性特性保证了 leader 一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，它可能不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。Raft 通过让 leader 在任期开始的时候提交一个空的没有任何操作的日志条目到日志中来处理该问题。第二，leader 在处理只读请求之前必须检查自己是否已经被替代了（如果一个更新的 leader 被选举出来了，它的信息就是过时的了）。Raft 通过让 leader 在响应只读请求之前，先和集群中的过半节点交换一次心跳信息来处理该问题。另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式，但是这种方法依赖 timing 来保证安全性（假设时间误差是有界的）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>[1] BOLOSKY, W. J., BRADSHAW, D., HAAGENS, R. B., KUSTERS, N. P., AND LI, P. Paxos replicated state machines as the basis of a high-performance data store. In Proc. NSDI’11, USENIX Conference on Networked Systems Design and Implementation (2011), USENIX, pp. 141–154.</li><li>[2] BURROWS, M. The Chubby lock service for loosely- coupled distributed systems. In Proc. OSDI’06, Sympo- sium on Operating Systems Design and Implementation (2006), USENIX, pp. 335–350.</li><li>[3] CAMARGOS, L. J., SCHMIDT, R. M., AND PEDONE, F. Multicoordinated Paxos. In Proc. PODC’07, ACM Sym- posium on Principles of Distributed Computing (2007), ACM, pp. 316–317.</li><li>[4] CHANDRA, T. D., GRIESEMER, R., AND REDSTONE, J. Paxos made live: an engineering perspective. In Proc. PODC’07, ACM Symposium on Principles of Distributed Computing (2007), ACM, pp. 398–407.</li><li>[5] CHANG, F., DEAN, J., GHEMAWAT, S., HSIEH, W. C., WALLACH, D. A., BURROWS, M., CHANDRA, T., FIKES, A., AND GRUBER, R. E. Bigtable: a distributed storage system for structured data. In Proc. OSDI’06, USENIX Symposium on Operating Systems Design and Implementation (2006), USENIX, pp. 205–218.</li><li>[6] CORBETT, J. C., DEAN, J., EPSTEIN, M., FIKES, A., FROST, C., FURMAN, J. J., GHEMAWAT, S., GUBAREV, A., HEISER, C., HOCHSCHILD, P., HSIEH, W., KAN- THAK, S., KOGAN, E., LI, H., LLOYD, A., MELNIK, S., MWAURA, D., NAGLE, D., QUINLAN, S., RAO, R., ROLIG, L., SAITO, Y., SZYMANIAK, M., TAYLOR, C., WANG, R., AND WOODFORD, D. Spanner: Google’s globally-distributed database. In Proc. OSDI’12, USENIX Conference on Operating Systems Design and Implemen- tation (2012), USENIX, pp. 251–264.</li><li>[7] COUSINEAU, D., DOLIGEZ, D., LAMPORT, L., MERZ, S., RICKETTS, D., AND VANZETTO, H. TLA+ proofs. In Proc. FM’12, Symposium on Formal Methods (2012), D. Giannakopoulou and D. Me ́ry, Eds., vol. 7436 of Lec- ture Notes in Computer Science, Springer, pp. 147–154.</li><li>[8] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The Google file system. In Proc. SOSP’03, ACM Symposium on Operating Systems Principles (2003), ACM, pp. 29–43.</li><li>[9] GRAY,C.,ANDCHERITON,D.Leases:Anefficientfault- tolerant mechanism for distributed file cache consistency. In Proceedings of the 12th ACM Ssymposium on Operating Systems Principles (1989), pp. 202–210.</li><li>[10] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctness condition for concurrent objects. ACM Trans- actions on Programming Languages and Systems 12 (July 1990), 463–492.</li><li>[11] HUNT, P., KONAR, M., JUNQUEIRA, F. P., AND REED, B. ZooKeeper: wait-free coordination for internet-scale systems. In Proc ATC’10, USENIX Annual Technical Con- ference (2010), USENIX, pp. 145–158.</li><li>[12] JUNQUEIRA, F. P., REED, B. C., AND SERAFINI, M. Zab: High-performance broadcast for primary-backup sys- tems. In Proc. DSN’11, IEEE/IFIP Int’l Conf. on Depend- able Systems &amp; Networks (2011), IEEE Computer Society, pp. 245–256.</li><li>[13] KIRSCH, J., AND AMIR, Y. Paxos for system builders. Tech. Rep. CNDS-2008-2, Johns Hopkins University, 2008.</li><li>[14] LAMPORT, L. Time, clocks, and the ordering of events in a distributed system. Commununications of the ACM 21, 7 (July 1978), 558–565.</li><li>[15] LAMPORT, L. The part-time parliament. ACM Transac- tions on Computer Systems 16, 2 (May 1998), 133–169.</li><li>[16] LAMPORT, L. Paxos made simple. ACM SIGACT News 32, 4 (Dec. 2001), 18–25.</li><li>[17] LAMPORT, L. Specifying Systems, The TLA+ Language and Tools for Hardware and Software Engineers. Addison- Wesley, 2002.</li><li>[18] LAMPORT, L. Generalized consensus and Paxos. Tech. Rep. MSR-TR-2005-33, Microsoft Research, 2005.</li><li>[19] LAMPORT, L. Fast paxos. Distributed Computing 19, 2 (2006), 79–103.</li><li>[20] LAMPSON, B. W. How to build a highly available system using consensus. In Distributed Algorithms, O. Baboaglu and K. Marzullo, Eds. Springer-Verlag, 1996, pp. 1–17.</li><li>[21] LAMPSON, B. W. The ABCD’s of Paxos. In Proc. PODC’01, ACM Symposium on Principles of Distributed Computing (2001), ACM, pp. 13–13.</li><li>[22] LISKOV, B., AND COWLING, J. Viewstamped replica- tion revisited. Tech. Rep. MIT-CSAIL-TR-2012-021, MIT, July 2012.<br>17</li><li>[23] LogCabin source code. logcabin/logcabin.<br><a href="http://github.com/" target="_blank" rel="noopener">http://github.com/</a></li><li>[24] LORCH, J. R., ADYA, A., BOLOSKY, W. J., CHAIKEN, R., DOUCEUR, J. R., AND HOWELL, J. The SMART way to migrate replicated stateful services. In Proc. Eu- roSys’06, ACM SIGOPS/EuroSys European Conference on Computer Systems (2006), ACM, pp. 103–115.</li><li>[25] MAO, Y., JUNQUEIRA, F. P., AND MARZULLO, K. Mencius: building efficient replicated state machines for<br>WANs. In Proc. OSDI’08, USENIX Conference on Operating Systems Design and Implementation (2008), USENIX, pp. 369–384.</li><li>[26] MAZIE` RES, D. Paxos made practical.<br>//<a href="http://www.scs.stanford.edu/" target="_blank" rel="noopener">www.scs.stanford.edu/</a> ̃dm/home/ papers/paxos.pdf, Jan. 2007.</li><li>[27] MORARU, I., ANDERSEN, D. G., AND KAMINSKY, M. There is more consensus in egalitarian parliaments. In Proc. SOSP’13, ACM Symposium on Operating System Principles (2013), ACM.</li><li>[28] Raft user study. <a href="http://ramcloud.stanford" target="_blank" rel="noopener">http://ramcloud.stanford</a>. edu/ ̃ongaro/userstudy/.</li><li>[29] OKI, B. M., AND LISKOV, B. H. Viewstamped replication: A new primary copy method to support highly-available distributed systems. In Proc. PODC’88, ACM Symposium on Principles of Distributed Computing (1988), ACM, pp. 8–17.</li><li>[30] O’NEIL, P., CHENG, E., GAWLICK, D., AND ONEIL, E. The log-structured merge-tree (LSM-tree). Acta Informat- ica 33, 4 (1996), 351–385.</li><li>[31] ONGARO, D. Consensus: Bridging Theory and Practice. PhD thesis, Stanford University, 2014 (work in progress).<a href="http://ramcloud.stanford.edu/" target="_blank" rel="noopener">http://ramcloud.stanford.edu/</a> ̃ongaro/ thesis.pdf.</li><li>[32] ONGARO, D., AND OUSTERHOUT, J. In search of an understandable consensus algorithm. In Proc ATC’14, USENIX Annual Technical Conference (2014), USENIX.</li><li>[33] OUSTERHOUT, J., AGRAWAL, P., ERICKSON, D., KOZYRAKIS, C., LEVERICH, J., MAZIE`RES, D., MI- TRA, S., NARAYANAN, A., ONGARO, D., PARULKAR, G., ROSENBLUM, M., RUMBLE, S. M., STRATMANN, E., AND STUTSMAN, R. The case for RAMCloud. Com- munications of the ACM 54 (July 2011), 121–130.</li><li>[34] Raft consensus algorithm website. <a href="http://raftconsensus.github.io" target="_blank" rel="noopener">http://raftconsensus.github.io</a>.</li><li>[35] REED, B. Personal communications, May 17, 2013.</li><li>[36] ROSENBLUM, M., AND OUSTERHOUT, J. K. The design and implementation of a log-structured file system. ACM Trans. Comput. Syst. 10 (February 1992), 26–52.</li><li>[37] SCHNEIDER, F. B. Implementing fault-tolerant services using the state machine approach: a tutorial. ACM Com- puting Surveys 22, 4 (Dec. 1990), 299–319.</li><li>[38] SHVACHKO, K., KUANG, H., RADIA, S., AND CHANSLER, R. The Hadoop distributed file system. In Proc. MSST’10, Symposium on Mass Storage Sys- tems and Technologies (2010), IEEE Computer Society, pp. 1–10.</li><li>[39] VAN RENESSE, R. Paxos made moderately complex. Tech. rep., Cornell University, 2012.</li></ul><p><a href="https://raft.github.io/" target="_blank" rel="noopener">Raft 网站</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Raft 算法是可以用来替代 Paxos 算法的分布式一致性算法，而且 raft 算法比 Paxos 算法更易懂且更容易实现。本文对 raft 论文进行翻译，希望能有助于读者更方便地理解 raft 的思想。如果对 Paxos 算法感兴趣，可以看我的另一篇文章：&lt;a href=&quot;http://linbingdong.com/2016/12/30/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/&quot;&gt;分布式系列文章——Paxos算法原理与推导&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Raft" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/Raft/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="论文翻译" scheme="http://linbingdong.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Raft" scheme="http://linbingdong.com/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>Python日志模块示例</title>
    <link href="http://linbingdong.com/2017/03/11/Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E7%A4%BA%E4%BE%8B/"/>
    <id>http://linbingdong.com/2017/03/11/Python日志模块示例/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>给出Python日志模块显示配置和文件配置两种方式的示例</p><a id="more"></a><h2 id="显示配置"><a href="#显示配置" class="headerlink" title="显示配置"></a>显示配置</h2><p>在程序中直接调用函数来设置参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'example'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个输出到控制台的handler</span></span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line">sh.setLevel(logging.ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个输出到文件的handler</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'loggingtest.log'</span>)</span><br><span class="line">fh.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出格式</span></span><br><span class="line">fmt = logging.Formatter(<span class="string">'%(asctime)s - %(threadName)s - [%(levelname)s] : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># handler设置formatter</span></span><br><span class="line">sh.setFormatter(fmt)</span><br><span class="line">fh.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># logger添加handler</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写日志</span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>通过配置文件进行配置，使用fileConfig()函数读取配置文件</p><ul><li>配置文件 logging.conf :</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,example01</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line"></span><br><span class="line">[logger_example01]</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line">qualname=example01</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=hand01,hand02</span><br><span class="line"></span><br><span class="line">[handler_hand01]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_hand02]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=form01</span><br><span class="line">args=(&apos;log.log&apos;,&apos;a&apos;)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line"></span><br><span class="line">[formatter_form02]</span><br><span class="line">format=%(asctime)s - %(threadName)s - [%(levelname)s] : %(message)s</span><br></pre></td></tr></table></figure><ul><li>程序 LogByFile.py :</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">logging.config.fileConfig(<span class="string">'logging.conf'</span>)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'example01'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写日志</span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出Python日志模块显示配置和文件配置两种方式的示例&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://linbingdong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://linbingdong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关于Java Collections的几个常见问题</title>
    <link href="http://linbingdong.com/2017/03/11/Stack%20Overflow%E4%B8%8A%E5%85%B3%E4%BA%8EJava%20Collections%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://linbingdong.com/2017/03/11/Stack Overflow上关于Java Collections的几个常见问题/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>列举几个关于Java Collections的常见问题并给出答案。</p><a id="more"></a><h3 id="1-什么时候用LinkedList，什么时候用ArrayList？"><a href="#1-什么时候用LinkedList，什么时候用ArrayList？" class="headerlink" title="1. 什么时候用LinkedList，什么时候用ArrayList？"></a>1. 什么时候用LinkedList，什么时候用ArrayList？</h3><p><code>ArrayList</code>是使用数组实现的list，本质上就是数组。ArrayList中的元素可以通过索引随机获取一个元素。但是如果该数组已满，当添加新元素时需要分配一个新的数组然后将原来数组的元素移动过去，需要O(n)的时间复杂度。添加或删除一个元素需要移动数组中的其他元素。这是ArrayList最大的缺点。</p><p><code>LinkedList</code>是一个双向链表。因此，当需要获取list中某个元素，需要从头到尾遍历list。另一方面，在链表中添加或删除元素很快，只需要O(1)的时间复杂度。从空间上来说，在链表中一个节点需要两个额外的指针来指向它的previous和next节点。</p><p>总结：</p><p>从<strong>时间复杂度</strong>来说，如果对list增加或删除操作较多，优先用LinkedList；如果查询操作较多，优先用ArrayList。</p><p>从<strong>空间复杂度</strong>来说，LinkedList会占用较多空间。</p><h3 id="2-如何边遍历边移除Collection中的元素"><a href="#2-如何边遍历边移除Collection中的元素" class="headerlink" title="2. 如何边遍历边移除Collection中的元素"></a>2. 如何边遍历边移除Collection中的元素</h3><p>边遍历边修改Collection的唯一正确方式是使用<code>Iterator.remove()</code>方法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种最常见的<strong>错误</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报<code>ConcurrentModificationException</code>异常。这是因为当使用<code>foreach</code>(for(Integer i : list))语句时，会自动生成一个iterator来遍历该list，但同时该list正在被<code>Iterator.remove()</code>修改。在Java中，一般不允许一个线程在遍历collection时另一个线程在修改它。</p><h3 id="3-如何将List转化成int-？"><a href="#3-如何将List转化成int-？" class="headerlink" title="3. 如何将List转化成int[]？"></a>3. 如何将List转化成int[]？</h3><p>很多人可能认为只需用<code>List.toArray()</code>即可，其实不然。List.toArray()方法只可能得到Integer[]，无法得到int[]。</p><p>最简单的方法是使用<code>Apache Commons Lang</code>库中的<code>ArrayUtils</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = ArrayUtils.toPrimitive(list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure><p>在JDK中，没有捷径。需要注意的是，不能直接使用<code>List.toArray()</code>,因为这样会将List转化成Integer[]而不是int[]。正确的做法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">array[i] = list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-如何将int-转化成List？"><a href="#4-如何将int-转化成List？" class="headerlink" title="4. 如何将int[]转化成List？"></a>4. 如何将int[]转化成List？</h3><p>同上，很多人以为只需用<code>Arrays.asList()</code>即可，其实不然。因为不能以int[]作为该方法的参数，要的话也只能是Integer[]。</p><p>关于<code>Arrays.asList()</code>方法有如下特性：</p><ul><li>1.该方法对于基本数据类型的数组支持并不好,当数组是基本数据类型时不建议使用 </li><li>2.当使用asList()方法时，数组就和列表链接在一起了。当更新其中之一时，另一个将自动获得更新。因为asList获得的List实际引用的就是数组  注意:仅仅针对对象数组类型,基本数据类型数组不具备该特性。</li><li>3.asList得到的数组是的没有add和remove方法的。因为asList返回的List是Arrays中的内部类,而该类并没有定义add和remove方法。</li></ul><p>那么如何将int[]转化成List呢？</p><p>还是得自己实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: array) &#123;</span><br><span class="line">  list.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-过滤一个Collection最好的方法是什么？"><a href="#5-过滤一个Collection最好的方法是什么？" class="headerlink" title="5. 过滤一个Collection最好的方法是什么？"></a>5. 过滤一个Collection最好的方法是什么？</h3><p>如过滤掉list中大于5的整数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="keyword">int</span> i = it.next();</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">5</span>) &#123;  <span class="comment">//过滤掉大于5的整数</span></span><br><span class="line">it.remove(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-将List转化成Set最简单的方法？"><a href="#6-将List转化成Set最简单的方法？" class="headerlink" title="6. 将List转化成Set最简单的方法？"></a>6. 将List转化成Set最简单的方法？</h3><p>有两种方法，取决于你怎么要怎么定义两个元素相等。第一种方法是将list放入<code>HashSet</code>里，该方法元素是否相等是通过它们的hashCode()来比较的。如果需要自己定义比较的方法，需要用<code>TreeSet</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;(list);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;(aComparator);</span><br><span class="line">set.addAll(list);</span><br></pre></td></tr></table></figure><h3 id="7-如何删除ArrayList中重复的元素？"><a href="#7-如何删除ArrayList中重复的元素？" class="headerlink" title="7. 如何删除ArrayList中重复的元素？"></a>7. 如何删除ArrayList中重复的元素？</h3><p>如果不关心元素在ArrayList中的顺序，可以将list放入set中来删除重复元素，然后在放回list。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;(list);</span><br><span class="line">list.clear();</span><br><span class="line">list.addAll(set);</span><br></pre></td></tr></table></figure><p>如果关心元素在ArrayList中的顺序，可以用<code>LinkedHashSet</code>。</p><h3 id="8-有序的collection"><a href="#8-有序的collection" class="headerlink" title="8. 有序的collection"></a>8. 有序的collection</h3><p>Java里有很多方法来维持一个collection有序。有的需要实现Comparable接口，有的需要自己指定Comparator。</p><ol><li><code>Collections.sort()</code>可以用来对list排序。该排序是稳定的，并且可以保证nlog(n)的性能。</li><li><code>PriorityQueue</code>提供排序的队列。<code>PriorityQueue</code>和<code>Collections.sort()</code>的区别是，<code>PriorityQueue</code>动态维护一个有序的队列（每添加或删除一个元素就会重新排序），但是只能获队列中的头元素。</li><li>如果collection中没有重复的元素，<code>TreeSet</code>是另一个选择。跟<code>PriorityQueue</code>一样的是，<code>TreeSet</code>也动态维护一个有序的集合。可以从<code>TreeSet</code>中获取最大和最小的元素。</li></ol><p>总结：<code>Collections.sort()</code>提供一个一次排序的list。<code>PriorityQueue</code>和<code>TreeSet</code>动态维护排序的collection。</p><h3 id="9-拷贝list"><a href="#9-拷贝list" class="headerlink" title="9. 拷贝list"></a>9. 拷贝list</h3><p>有两种方法可以用来拷贝list。一种是使用<code>ArrayList</code>构造器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; dstList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(srcList);</span><br></pre></td></tr></table></figure><p>另一种是使用<code>Collections.copy()</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; dstList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(srcList.size());</span><br><span class="line">Collections.copy(dstList, srcList);</span><br></pre></td></tr></table></figure><p>需要注意的是，使用该方法的话目标list至少跟源list长度一样长。否则会报<code>IndexOutOfBoundsException</code>异常。</p><p>另外有两点需要注意：</p><ol><li>两种方法都是浅拷贝</li><li><code>Collections.copy()</code>方法的两个参数必须都是list，而<code>ArrayList</code>方法参数只要是collection即可，因此<code>ArrayList</code>方法更通用。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举几个关于Java Collections的常见问题并给出答案。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
</feed>
