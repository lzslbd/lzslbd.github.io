<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LBD&#39;s Blog</title>
  
  <subtitle>大数据与分布式</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linbingdong.com/"/>
  <updated>2019-05-18T06:32:24.230Z</updated>
  <id>http://linbingdong.com/</id>
  
  <author>
    <name>LBD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang小记</title>
    <link href="http://linbingdong.com/2019/05/18/Golang%E5%B0%8F%E8%AE%B0/"/>
    <id>http://linbingdong.com/2019/05/18/Golang小记/</id>
    <published>2019-05-18T06:22:24.897Z</published>
    <updated>2019-05-18T06:32:24.230Z</updated>
    
    <content type="html"><![CDATA[<p>记录go语言使用中的一些注意事项。</p><a id="more"></a><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><ol><li>通道是用来让不同goroutine之间通信的，如果只有一个goroutine，就没必要用通道 </li><li>make(chan bool) 等价于 make(chan bool, 0)  != make(chan bool, 1)</li><li>默认是无缓冲通道，用于同步；有缓冲通道用于解耦</li><li>不管是无缓冲通道还是有缓冲通道，只要有goroutine无限等待发生，就会死锁</li><li>close(channel)用来通知读该channel的goroutine退出，防止无限等待导致死锁 </li><li>对一个已经关闭的channel，会得到已经发送的值，等发送的值都读完后，读到通道类型对应的零值 </li><li>通道并不一定要关闭，除非想用来通知其他goroutine </li><li>用 x := range channel 来遍历通道，当channel关闭时，循环会自动退出，不会阻塞 </li><li>向已经关闭的通道发送数据会导致panic；关闭已关闭的通道也会panic </li><li>可以将双向通道转为单向通道。反之不行；参数传递时会隐式转换 </li><li>select用于处理多个通道；随机选择一个到达的通道执行 </li><li>channel可以比较，但好像也没啥意义 </li></ol><h2 id="Timer和Ticker"><a href="#Timer和Ticker" class="headerlink" title="Timer和Ticker"></a>Timer和Ticker</h2><ul><li>time.NewTimer(5 * time.Second) or time.NewTicker(5 * time.Second) </li><li>Timer是定时器，只在指定时间后发送一个当前时间 </li><li>Ticker为节拍器，每隔指定时间发送当前时间，不间断 </li></ul><h2 id="数组和切片slice："><a href="#数组和切片slice：" class="headerlink" title="数组和切片slice："></a>数组和切片slice：</h2><p>​        go中很少使用数组，一般使用切片！ </p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组长度是数组类型的一部分。长度不同的数组之间无法比较 </li><li>两个同类型的数组可以比较。用”==”比较，比较的是数组中的元素，如果两个数组的元素都相同，则为true </li><li>go中数组是值传递。所以如果参数传一个很大的数组会很低效；当然也可以传递一个数组的指针 </li><li>声明数组时，数组中每个元素默认被初始化为零值 </li><li>数组指针 != 数组第一个元素的地址 </li><li>数组的len和cap是一样的 </li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><ul><li>slice有三个属性：指针，长度len和容量cap </li><li>slice的底层是数组 </li><li>对slice的修改就是对其底层数组的修改 </li><li>一个底层数组可以对应多个slice，如果多个slice都是从同一个底层数组而来，且有重叠，则修改其中一个slice，其他slice也会改变 </li><li>slice传参是引用传递 </li><li>slice的len为当前元素的个数；cap取决于底层数组（非循环数组），如底层数组a长度为10, s := a[3:5], 则len(s) == 2, cap(s) == 7 </li><li>slice的零值为nil，值为nil的slice（var s []int）没有底层数组，len和cap都为0 </li><li>创建slice三种方式：1. 先创建数组，再从数组得到slice  2. make或字面量创建  3.从slice得到另一个slice（引用同一个底层数组） </li><li>使用append对slice进行追加时，如果原有数组容量不够，会对数组扩容，每次扩为原来的两倍（不一定） </li><li>s := make([]int, 0) 此时slice的值为[], != nil（因为分配了底层数组，只不过数组长度为0）, len和cap都为0 </li><li>检查slice是否为空：len(s) == 0? </li><li>make([]T, len, cap) 至少要有len，可以没有cap。如果不确定容量，则make([]T, 0), 等价于 s := []T{}；确定容量，则make([]T, 0, cap) (适用于需要用append来填充slice的)或make([]T, cap)(适用于用下标来给slice赋值的)</li><li>slice append 另一个slice：x = append(x, y…) </li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li>map键的类型，必须是可以用”==”来比较的。slice不能作为键 </li><li>对于不存在的key，value为V类型的零值 </li><li>map的键是唯一的，因此可以用map[T]bool来实现set，value都为true </li><li>创建map两种方式：1. make(map[K]V)   2.  m := map[K]V{k1:v1, k2:v2,}，或者写成 var m = map[K]V{k1:v1, k2:v2,} </li><li>map可以用range迭代，迭代的顺序是随机的，因此如果要按序迭代，需要维护一个有序的key的slice </li><li>map和slice一样，都是不可比较的 </li><li>map和slice在设置值前都必须初始化，不能只声明。var m map[K]V 只是声明了一个map，此时m为nil，没有引用任何散列表，不能赋值 </li><li>用make创建map的时候，不需要（也不应该）指定len，因为没有意义（底层是散列表，内存不连续，大小无限制） </li><li>map的容量是无限的，因此不能调用cap(m)；但是可以调用len(m)，结果为m中k,v对的个数 </li><li>无法获取map元素的地址，因为随着map的增长，已有的元素可能会被重新散列到别的位置，也就是元素的地址是不固定的 </li><li>map的value可以是map或slice，从而实现一个key，对应多个value </li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li><p>reflect.TypeOf()返回Type    reflect.ValueOf()返回Value</p></li><li><p>Type主要用于获取类型信息，Value主要用于数据读写</p></li><li><p>若要修改数据，需要传入指针，且后面必须加.Elem()获得对象实例</p></li></ul><h2 id><a href="#" class="headerlink" title=":="></a>:=</h2><ul><li>当 := 左边有两个变量，如 a, err := 时，如果之前已经声明过 err ，这里会声明新变量 a ，只会对 err 赋值，不会声明新变量 err  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录go语言使用中的一些注意事项。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://linbingdong.com/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://linbingdong.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的问题</title>
    <link href="http://linbingdong.com/2018/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://linbingdong.com/2018/04/18/分布式系统的问题/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-22T14:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文内容翻译自《Designing Data-Intensive Applications》一书的第8章。</p></blockquote><a id="more"></a><p>近几章主要介绍系统如何处理错误。例如，我们讨论了副本故障转移，复制滞后和事务的并发控制。当我们理解实际系统中可能出现的各种边界情况时，我们就能更好地处理它们。</p><p>前几章虽然谈论了很多关于错误的问题，但是还是太乐观了。在本章中，我们将最悲观地假设“任何可能出故障的，最终都会出故障”。</p><p>分布式系统编程与在单机上编写软件有本质区别——主要区别在于分布式系统中有很多新奇的可能出故障的方式。 本章中，我们将了解在实践中出现的问题，并了解哪些我们可以依赖，哪些不行。</p><p>最后，作为工程师，我们的任务是构建能够完成工作的系统（即满足用户所期望的保证），尽管各个部件都出错了。 在第9章中，我们将看看可以在分布式系统中提供这种保证的算法的一些示例。 但首先，在本章中，我们必须了解我们面临的挑战。</p><p>本章是对分布式系统中可能出现的问题的悲观和沮丧的概述。 我们将研究网络问题（第277页的“不可靠的网络”）; 时钟和时序问题（第287页上的“不可靠的时钟”）; 我们将讨论它们可以避免的程度。 所有这些问题造成的后果都会让人迷惑，因此我们将探讨如何思考分布式系统的状态以及如何推理已发生的事情（第300页的“知识，真相和谎言”）。</p><h2 id="错误和部分故障"><a href="#错误和部分故障" class="headerlink" title="错误和部分故障"></a>错误和部分故障</h2><p>当你在单机上写程序时，它通常会以一种可预测的方式运行：要么正常工作，要么无法工作。有bug的软件可能会让人觉得电脑出问题了（通常重新启动就能解决问题），但大部分还是软件写得不好的后果。</p><p>没有什么根本原因能让单机上的软件表现得奇怪：当硬件正常工作时，相同的操作总是产生相同的结果（这是确定性的）。如果存在硬件问题（例如，内存损坏或连接器松动），其后果通常是整个系统失效（例如“蓝屏死机”，无法启动）。具有良好软件的单机通常功能完好或完全损坏，而不在两者之间。</p><p>这是计算机设计中的一个慎重选择：如果发生内部故障，我们宁愿计算机完全崩溃，而不是返回错误的结果，因为错误的结果很难处理，并且令人困惑。因此，计算机隐藏了它们实现所依赖的模糊物理现实，并提出了一个理想化的系统模型，它可以与数学完美结合起来。CPU指令总是做同样的事情; 如果你将一些数据写入内存或磁盘，则该数据保持完好并且不会随机损坏。 这种始终正确计算的设计目标可以追溯到第一台数字计算机。</p><p>当你编写运行在多台计算机上并通过网络连接的软件时，情况完全不同。 在分布式系统中，我们不再处于理想系统模型中 - 我们别无选择，只能面对物理世界的混乱现实。 而在现实世界中，正如这个轶事所示，各种各样的事情可能会出错：</p><blockquote><p>在我有限的经验中，我处理过单个数据中心（DC）中的长时间网络分区，PDU（配电单元）故障，交换机故障，整个机架的意外电源故障，全DC主干故障，全DC 电力故障和一位低血糖驾驶员将他的福特皮卡撞进空调系统。我甚至不是一个运维人员。——Coda Hale</p></blockquote><p>在分布式系统中，可能出现这样的情况，尽管系统的其他部分工作正常，但系统的某些部分可能会以某种不可预知的方式出故障。这就叫做部分故障。该问题的难点在于部分故障是不确定的：如果你试图做任何包含多个节点和网络的事情，它可能有时工作正常，有时出现不可预知的故障。正如我们将要看到的，你可能甚至不知道某件事是否成功，因为消息在网络中传播所花费的时间也是不确定的！</p><p>这种不确定性和部分故障的可能性是分布式系统难以处理的原因。</p><h3 id="云计算和超级计算"><a href="#云计算和超级计算" class="headerlink" title="云计算和超级计算"></a>云计算和超级计算</h3><p>关于如何构建大型计算系统有一系列哲学：</p><ul><li><p>规模的一端是高性能计算（HPC）领域。拥有数千个CPU的超级计算机通常用于计算密集型科学计算任务，如天气预报或分子动力学（模拟原子和分子的运动）。</p></li><li><p>另一端是云计算，云计算没有非常明确的定义，但通常与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及按时计费联系在一起。</p></li></ul><p>有了这些哲学，处理错误的方法就非常不同了。在超级计算机中，作业通常会对其计算状态不时地做检查点到持久存储上。如果一个节点发生故障，通常的解决方案是简单地停止整个集群工作负载。故障节点修复后，从上一个检查点重新开始计算。因此，超级计算机更像是一台单节点计算机而不是分布式系统：它通过升级为完全故障来处理部分故障 - 当系统的任何部分发生故障，简单地让整个系统崩溃（就像单机上的内核恐慌一样）。</p><p>在本书中，我们重点介绍实现互联网服务的系统，这些系统通常看起来与超级计算机有很大不同：</p><ul><li><p>许多与互联网有关的应用程序都是在线的，在某种意义上它们需要能够随时为用户提供低延迟服务。服务不可用（例如，停止群集以进行修复）是不可接受的。相比之下，像天气模拟这样的离线（批处理）作业可以停止并重启，而且影响很小。</p></li><li><p>超级计算机通常由专用硬件构建，其中每个节点都非常可靠，并且节点通过共享内存和远程直接内存访问（RDMA）进行通信。另一方面，云服务中的节点是由普通机器构建的，它们能以较低的成本提供相同的性能，但也具有较高的故障率。</p></li><li><p>大型数据中心网络通常基于IP和以太网，以Clos拓扑排列来提供高对分带宽。超级计算机通常使用专门的网络拓扑结构，例如多维网格和toruses，这为具有已知通信模式的HPC工作负载提供了更好的性能。</p></li><li><p>系统越大，系统中有组件出故障的概率越高。随着时间的推移，故障被修复，新的组件又出故障，但是在一个有数千个节点的系统中，认为系统中总是在发生故障是一个合理的假设。当错误处理策略不够有效时，一个大型系统最终会花费大量的时间从故障中恢复，而不是做有用的工作。</p></li><li><p>如果系统可以容忍失败的节点并且仍然作为一个整体继续工作，这对于操作和维护是一个非常有用的特性：例如，可以执行滚动升级（参阅第4章），一次重启一个节点，系统继续为用户提供服务而不中断。在云环境中，如果一台虚拟机运行不佳，可以将其杀死并请求一台新的虚拟机（希望新的虚拟机速度更快）。</p></li><li><p>在地理分布式部署中（保持数据在地理位置上接近用户以减少访问延迟），通信很可能通过互联网进行，与本地网络相比，速度慢且不可靠。超级计算机通常假设它们的所有节点都靠近在一起。</p></li></ul><p>如果我们想让分布式系统工作，就必须接受部分故障的可能性，并在软件中建立容错机制。换句话说，我们需要从不可靠的组件中构建可靠的系统。（正如在第6页的“可靠性”中所讨论的那样，没有完美的可靠性，所以我们需要了解我们可以实际承诺的极限。）</p><p>即使在只有少数节点的小型系统中，考虑部分故障也很重要。在一个小型系统中，很可能大部分组件在大多数时间都正常工作。但是，迟早会有一部分系统出现故障，软件将不得不以某种方式处理它。故障处理必须是软件设计的一部分，并且软件的操作员需要知道发生故障时软件会出现什么行为。</p><p>假定错误很少发生，并只往好的想是不明智的。考虑各种可能的错误（甚至是不太可能的错误），并在测试环境中人为地创建这些情况以查看会发生什么是非常重要的。在分布式系统中，抱着怀疑，悲观和偏执的态度才能取得成功。</p><h3 id="从不可靠的组件中构建可靠的系统"><a href="#从不可靠的组件中构建可靠的系统" class="headerlink" title="从不可靠的组件中构建可靠的系统"></a>从不可靠的组件中构建可靠的系统</h3><p>你可能会怀疑这是否有道理——直觉上，一个系统只能和其最不可靠的组件（它最薄弱的环节）一样可靠。事实并非如此：事实上，从不太可靠的基础构建更可靠的系统，这在计算中是一个古老的想法。 例如：</p><ul><li><p>纠错码允许数字数据在通信信道上准确传输，偶尔会出现某些位错误，例如由于无线网络上的无线电干扰。</p></li><li><p>IP（互联网协议）是不可靠的：数据包可能丢失，延迟，重复或乱序。TCP（传输控制协议）在IP之上提供了一个更可靠的传输层：它确保丢失的数据包被重传，消除重复，并且数据包被重新组装为它们的发送顺序。</p></li></ul><p>虽然系统可能比其基础部分更可靠，但它的可靠性总是有限的。例如，纠错码可以处理少量的单比特错误，但是如果信号被干扰所淹没，那么通过通信信道可以获得的数据量就有一个基本限制。TCP可以对我们隐藏数据包丢失，重复和乱序，但它不能在网络中奇迹般地消除延迟。</p><p>虽然更可靠的更高级别的系统并不完美，但它仍然很有用，因为它可以处理一些棘手的低级故障，因此通常也可以更轻松地解决和处理其余的故障。</p><h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p>正如在第二部分的介绍中所讨论的，我们在本书中关注的分布式系统是shared-nothing系统：即一堆机器通过网络连接。网络是这些机器可以通信的唯一方式。我们假设每台机器有自己的内存和磁盘，一台机器无法访问另一台机器的内存或磁盘（除了通过网络向服务发出请求外）。</p><p>shared-nothing并不是构建系统的唯一方式，但它已经成为构建互联网服务的主要方式，原因有几个：它相对便宜，因为它不需要特殊的硬件，可以利用商品化的云计算服务， 可以通过跨多个地理分布的数据中心进行冗余来实现高可靠性。</p><p>互联网和数据中心的大部分内部网络（通常是以太网）都是异步分组网络。 在这种网络中，一个节点可以向另一个节点发送一个消息（一个数据包），但是网络不能保证它何时到达，甚至是否能到达。如果你发送请求并期待响应，很多事情可能会出错（其中一些如图8-1所示）：</p><ol><li>你的请求可能已经丢失（可能是某人拔掉了网线）。</li><li>你的请求可能正在队列中等待，稍后会被发送（也许网络或收件人过载）。</li><li>远程节点可能失败（可能崩溃或掉电）。</li><li>远程节点可能暂时停止了响应（可能正在经历长时间的垃圾回收暂停;请参阅第295页上的“进程暂停”），但稍后它会再次开始响应。</li><li>远程节点可能处理了你的请求，但响应在网络上丢失了（可能是网络交换机配置错误）。</li><li>远程节点可能已经处理了你的请求，但响应已经延迟并且将稍后发送（可能是网络或你自己的机器过载）。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1752522-5d73a60621d1b78f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-1 如果你发送了一个请求没有得到响应，无法区分是发生了以下哪种情况：（a）请求丢失了（b）对方节点宕机（c）响应丢失了"></p><p>发送方甚至无法知道数据包是否已经被发送：唯一的选择是让接收方发送响应消息，这可能会丢失或延迟。这些问题在异步网络中难以区分：你拥有的唯一信息是你尚未收到响应。如果你向另一个节点发送请求并且未收到回复，也无法知道是什么原因。</p><p>处理该问题通常的方法是使用超时：一段时间后就放弃等待并假设响应不会送达。但是，当发生超时时，你仍然不知道远程节点是否收到了你的请求（如果请求仍然在某个地方排队，它仍然可能会被传送给接收方，即使发送方已经放弃了）。</p><h3 id="网络故障实践"><a href="#网络故障实践" class="headerlink" title="网络故障实践"></a>网络故障实践</h3><p>几十年来我们一直在建立计算机网络——人们可能希望现在我们已经知道了如何使它们变得可靠。但是，似乎我们还没有成功。</p><p>有一些系统的研究和大量的轶事证据表明，即使在由公司运营的数据中心那样的受控环境中，网络问题也可能非常普遍。在一家中等规模的数据中心进行的一项研究发现，每个月大约发生12次网络故障，其中一半单台机器断开连接，一半整个机架断开连接。另一项研究测量了架顶式交换机，汇聚交换机和负载平衡器等组件的故障率，发现添加冗余网络设备不会像你所希望的那样减少故障，因为它不能防范人为错误（例如，配置错误的交换机），这是造成网络中断的主要原因。</p><p>公共云服务（如EC2）因频繁出现短暂的网络故障而臭名昭着，管理良好的专用数据中心网络会比较稳定。尽管如此，没有人能够避免网络问题的干扰：例如，交换机软件升级期间的问题可能会触发网络拓扑重新配置，在此期间网络数据包可能会延迟超过一分钟。鲨鱼可能咬住海底电缆并损坏它们。其他令人惊讶的故障包括网络接口有时会丢弃所有入站数据包，但成功发送出站数据包。因此，仅仅因为网络链接在一个方向上正常工作并不能保证它也在相反的方向也正常工作。</p><blockquote><p><strong>网络分区</strong><br>当网络的一部分由于网络故障而与其余部分断开时，有时称为网络分区或网络分割。 在本书中，我们使用更一般的术语网络故障，以避免与如第6章所述的存储系统的分区（碎片）混淆。</p></blockquote><p>即使你的环境中很少发生网络故障，但可能发生故障的事实意味着你的软件需要能够处理它们。网络上的通信总有可能会失败，这是没有办法的。</p><p>如果网络故障的错误处理未经过定义和测试，则可能会发生反复无常的错误：例如，即使网络恢复，群集也可能会死锁并永久无法为请求提供服务，甚至可能会删除你的所有数据。如果软件不在受控的情况下，可能会有意想不到的行为。</p><p>处理网络故障并不一定意味着容忍它们：如果你的网络通常相当可靠，则有效的方法可能是在网络遇到问题时向用户简单显示错误消息。但是，你需要知道你的软件会对网络问题做出什么反应，并确保系统能够从中恢复。刻意地触发网络问题并测试系统响应是有意义的（这是Chaos Monkey背后的想法;请参阅第6页的“可靠性”）。</p><h3 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h3><p>很多系统都需要自动检测故障节点。 例如：</p><ul><li>负载平衡器需要停止向死节点发送请求。</li><li>在single-leader复制的分布式数据库中，如果leader发生故障，需要提升一个follower成为新的leader（参阅第152页的“处理节点故障”）。</li></ul><p>不幸的是，网络的不确定性使得判断一个节点是否正常工作变得很困难。在某些特定情况下，你可能会收到一些反馈信息，以明确告诉你某些组件不正常工作：</p><ul><li><p>如果你可以到达运行节点的机器，但没有进程正在监听目标端口（例如，因为进程崩溃），操作系统将通过发送RST或FIN数据包来帮助关闭或拒绝TCP连接。但是，如果节点在处理请求过程中崩溃，你将无法知道远程节点实际已经处理了多少数据。</p></li><li><p>如果节点进程崩溃（或被管理员杀死）但节点的操作系统仍在运行，脚本可以通知其他节点有关崩溃的信息，以便另一个节点可以快速接管而无需等待超时。</p></li><li><p>如果你有权限访问数据中心网络交换机的管理界面，则可以查询它们以检测硬件级别的链路故障（例如，远程机器是否关闭电源）。如果你通过互联网连接，或者你处于共享数据中心但无权限无法访问交换机，或者由于网络问题而无法访问管理界面，则无法使用该选项。</p></li><li><p>如果路由器确定你尝试连接的IP地址无法访问，它可能会用ICMP目标无法访问的数据包回复你。但是，路由器不具备神奇的故障检测能力——它受到与网络其他组成部分相同的限制。</p></li><li><p>远程节点宕机的快速反馈很有用，但你不能指望它。即使TCP确认数据包已发送，应用程序在处理数据之前可能已崩溃。如果你想确认一个请求是成功的，需要在应用程序本身积极响应。</p></li><li><p>相反，如果出现问题，你可能会在某个层次上得到错误响应，但通常你必须假设根本得不到响应。你可以重试几次（TCP重试是透明的，但您你可以在应用程序级别重试），等待超时过去，并且如果在超时范围内没有收到响应，才最终宣布节点失效。</p></li></ul><h3 id="超时和无限延迟"><a href="#超时和无限延迟" class="headerlink" title="超时和无限延迟"></a>超时和无限延迟</h3><p>如果超时是检测故障的唯一可靠方法，那么超时时间应该多长？不幸的是没有简单的答案。</p><p>超时时间长意味着需要长时间等待才能宣告一个节点死亡（并且在此期间，用户可能不得不等待或看到错误消息）。超时时间短可以更快地检测到故障，但是会带来更高的误判的风险，例如节点可能只是暂时变慢（比如由于工作或网络负载高峰）就被误判为死亡。</p><p>过早地宣告一个节点已经死亡是有问题的：如果节点实际上处于活动状态并且正在执行一些操作（例如，发送电子邮件），然后另一个节点接管，那么该操作最终可能会执行两次。我们将在第300页的“知识，真相和谎言”以及第9章和第11章中更详细地讨论该问题。</p><p>当一个节点被宣告死亡时，其职责需要转移到其他节点，这会给其他节点和网络带来额外的负担。如果系统已经处于高负载状态，过早宣告节点死亡会使问题变得更糟。特别地，可能节点实际上并未死亡，只是由于负载太高而响应缓慢。将其负载转移到其他节点可能会导致瀑布式的失败（在极端情况下，所有节点都宣告对方死亡，然后一切都停止工作）。</p><p>假设一个虚拟系统的网络可以保证数据包的最大延迟——每个数据包要么在一段时间内送达，要么丢失，但时间永远不会超过d。此外，假设可以保证非故障节点在总是在一段时间r内处理请求。在这种情况下，可以保证每个成功的请求都会在2d + r的时间内收到响应，并且如果在此时间内没有收到响应，则知道网络或远程节点不工作。如果情况真如上述那样，2d + r将是一个合理的超时时间。</p><p>不幸的是，我们所使用的大多数系统都没有这些保证：异步网络具有无限的延迟（即它们尽可能快地发送数据包，但数据包到达所需的时间没有上限） ，并且大多数服务器实现不能保证它们可以在特定时间内处理请求（请参阅“响应时间保证”（第298页））。对于故障检测，大部分时间内快是不够的：如果超时时间较短，则往返时间只需要瞬间上升就会导致系统失去平衡。</p><h4 id="网络拥塞和排队"><a href="#网络拥塞和排队" class="headerlink" title="网络拥塞和排队"></a>网络拥塞和排队</h4><p>在开车汽车时，由于交通堵塞，在路上花的时间往往不尽相同。类似的，计算机网络上的数据包延迟的可变性通常也是由于排队：</p><ul><li>如果多个不同的节点同时尝试向相同的目的地发送数据包，则网络交换机必须将它们排队并将它们逐个送入目标网络链路（如图8-2所示）。在繁忙的网络链路上，数据包可能需要等待一段时间才能获得一个槽（这称为网络拥塞）。如果传入的数据太多以至于交换机队列填满，数据包将被丢弃，因此需要重新发送数据包，即使网络运行良好。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1752522-24120c1100abacf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8-2"></p><ul><li><p>当数据包到达目标机器时，如果所有CPU内核当前都处于繁忙状态，则来自网络的传入请求将被操作系统排队，直到应用程序准备好处理它为止。根据机器的负载情况，这可能需要一段任意长度的时间。</p></li><li><p>在虚拟化环境中，当另一个虚拟机正在使用CPU核的时候，正在运行的操作系统通常会暂停几十毫秒。在此期间，虚拟机无法使用网络中的任何数据，因此输入数据被虚拟机监视器排队（缓冲），这进一步增加了网络延迟的可变性。</p></li><li><p>TCP执行流量控制（也称为拥塞避免或背压），节点限制自己的发送速率以避免网络链路或接收节点过载。这意味着甚至在数据进入网络之前，发送者也会让数据排队。</p></li></ul><p>此外，如果TCP在某个超时时间内未得到确认（根据观察的往返时间计算），则认为数据包丢失，并且丢失的数据包将自动重新发送。尽管应用程序没有看到数据包丢失和重传，但它确实会看到由此产生的延迟（等待超时过期，然后等待重传的数据包得到确认）。</p><p><strong>TCP与UDP</strong></p><p>一些对延迟敏感的应用程序（如视频会议和IP语音（VoIP））使用UDP而不是TCP。这是延迟的可靠性和可变性之间的折衷：由于UDP不执行流量控制并且不重传丢失的数据包，所以它避免了一些可变网络延迟的原因（尽管它仍然易受交换机队列和调度延迟的影响）。</p><p>在延迟数据毫无价值的情况下，UDP是一个不错的选择。例如，在VoIP电话呼叫中，可能没有足够的时间在其数据将在扬声器上播放之前重新传输丢失的数据包。在这种情况下，重传数据包没有意义——应用程序必须用无声填充丢失数据包的时隙（导致声音短暂中断），然后在数据流中继续。相反，重试发生在人类层面。（“你能再说一遍吗？刚刚没声音了。”）</p><p>所有这些因素都会造成网络延迟的变化。当系统接近其最大容量时，排队延迟的范围很大：拥有大量备用容量的系统可以轻松消化队列，而在高度使用的系统中，很快就会排起长队列。</p><p>在公有云和多租户数据中心中，资源被许多客户共享：网络链路和交换机，甚至每台计算机的网络接口和CPU（在虚拟机上运行时）都是共享的。批处理工作负载（如MapReduce）（请参阅第10章）可以轻松地使网络链接饱和。由于你无法控制或了解其他客户对共享资源的使用情况，如果你身边的某个人正在使用大量资源，网络延迟可能会变化无常。</p><p>在这样的环境中，你只能通过实验来选择超时时间：在一个延长的周期中测试和多台机器的网络往返时间分布，以确定延迟可变性的期望。然后，考虑应用程序的特性，你可以在故障检测延迟与过早超时风险之间确定一个适当的折衷。</p><p>更好的是，系统不是使用配置的常量超时，而是能够连续测量响应时间及其变化（抖动），并根据观察到的响应时间分布自动调整超时。这可以用Phi Accrual故障检测器完成，该检测器在Akka和Cassandra中被使用。TCP重传超时运行原理类似。</p><h4 id="同步与异步网络"><a href="#同步与异步网络" class="headerlink" title="同步与异步网络"></a>同步与异步网络</h4><p>如果我们可以依赖网络来传递具有固定最大延迟的数据包，而不是丢弃数据包，那么分布式系统就会简单得多。为什么我们不能在硬件级别解决这个问题，并使网络可靠，以便软件不必考虑这些问题？</p><p>为了回答这个问题，将数据中心网络与非常可靠的传统固定电话网络（非蜂窝，非VoIP）进行比较是很有趣的：延迟音频帧和掉话是非常罕见的。电话呼叫需要始终较低的端到端延迟和足够的带宽来传输语音的音频样本。在计算机网络中拥有类似的可靠性和可预测性不是很好吗？</p><p>当你通过电话网络拨打电话时，它会建立一条线路：沿着两个呼叫者之间的整个路由为呼叫分配固定的有保证的带宽量。该线路保持占用，直到通话结束。例如，ISDN网络以每秒4000帧的固定速率运行。呼叫建立后，每个帧内（每个方向）分配16位空间。因此，在通话期间，每一方都保证能够每250微秒发送一个精确的16位音频数据。</p><p>这种网络是同步的：即使数据通过多个路由器，也不会受到排队的影响，因为呼叫的16位空间已经在网络的下一跳中保留下来了。而且由于没有排队，网络的最大端到端延迟是固定的。我们称之为有限的延迟。</p><p><strong>我们不能简单地使网络延迟可预测吗？</strong></p><p>请注意，电话网络中的线路与TCP连接非常不同：线路是固定数量的预留带宽，在线路建立时没有人可以使用，而TCP连接的数据包有机会使用任何可用的网络带宽。你可以为TCP提供可变大小的数据块（例如电子邮件或网页），TCP会尽可能在最短的时间内传输它。当TCP连接空闲时，不使用任何带宽。如果数据中心网络和互联网是线路交换网络，那么建立线路后可以确保最大往返时间。然而，它们并不是：以太网和IP是分组交换协议，它们受到排队的影响，从而导致网络无限延迟。这些协议没有线路的概念。</p><p>为什么数据中心网络和互联网使用分组交换？答案是，它们针对突发流量进行了优化。一个电路适用于音频或视频通话，在通话期间需要每秒传送相当恒定的比特数。另一方面，请求网页，发送电子邮件或传输文件没有任何特定的带宽需求，我们只是希望它尽快完成。</p><p>如果你想通过线路传输文件，则必须猜测带宽分配。如果你猜的太低，传输速度会不必要的太慢，导致网络容量没有使用。如果你猜得太高，线路就无法建立（因为如果无法保证其带宽分配，网络不能建立线路）。因此，使用线路进行突发数据传输会浪费网络容量，并导致传输不必要的缓慢。相比之下，TCP会动态调整数据传输速率以适应可用的网络容量。</p><p>已经有一些尝试构建支持线路交换和分组交换的混合网络，例如ATM。例如InfiniBand：它实现了链路层的端到端流量控制，减少了网络排队的概率，尽管它仍然可能因链路拥塞而遭受延迟。通过谨慎使用服务质量（QoS，数据包的优先级和调度）和准入控制（限速发送器），可以仿真分组网络上的线路交换，或提供统计上有界的延迟。</p><p><strong>延迟和资源使用</strong></p><p>更一般地说，你可以将可变延迟视为动态资源分区的结果。</p><p>假设两台电话交换机之间有一条线路，可以同时进行10,000个呼叫。通过此线路切换的每个电路都占用其中一个呼叫插槽。因此，你可以将线路视为可由多达10,000个并发用户共享的资源。资源以静态方式分配：即使你现在是线路上唯一的电话，并且所有其他9,999个插槽都未使用，你的线路仍将分配跟线路被充分利用时相同的固定数量的带宽。</p><p>相比之下，互联网动态分享网络带宽。发送者竞争以尽可能快地通过网络获得它们的分组，并且网络交换机决定发送哪个分组（即，带宽分配）。这种方法有排队的缺点，但优点是它最大限度地利用了线路。线路成本固定，所以如果你更充分地利用它，通过该线路发送的每个字节都更便宜。</p><p>CPU也会出现类似的情况：如果你在多个线程之间动态共享每个CPU核，则有时候一个线程必须在另一个线程运行时等待操作系统的运行队列，因此线程可能被暂停不同的时间长度。但是，与为每个线程分配静态数量的CPU周期相比，这会更充分地利用硬件（请参阅第298页的“响应时间保证”）。更高的硬件利用率也是使用虚拟机的重要动机。</p><p>如果资源是静态分区的（例如，专用硬件和专用带宽分配），则在某些环境中可实现延迟保证。但是，这是以降低利用率为代价的。换句话说，它是更昂贵的。另一方面，动态资源分配下的多租户提供了更好的利用率，所以它更便宜，但它具有可变延迟的缺点。</p><p>网络中的可变延迟不是自然规律，而仅仅是成本/收益折衷的结果。</p><p>但是，此类服务质量目前尚未在多租户数据中心和公有云或通过互联网进行通信时可用。当前部署的技术无法让我们对网络的延迟或可靠性做出任何保证：我们必须假定网络拥塞，排队和无限延迟可能发生。因此，超时时间没有“正确”的值，需要通过实验确定。</p><p><strong>未完待续。。。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文内容翻译自《Designing Data-Intensive Applications》一书的第8章。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PhxPaxos源码分析——Paxos算法实现</title>
    <link href="http://linbingdong.com/2017/11/21/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://linbingdong.com/2017/11/21/PhxPaxos源码分析——Paxos算法实现/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-11-22T00:41:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇主要来分析Paxos算法实现的部分，我想这应该也是读者最感兴趣的。在看这篇文章之前，如果之前对Paxos算法没有了解的童鞋可以看下这篇文章：<a href="http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/">Paxos算法原理与推导</a>，相信了解Paxos算法后再来通过源码看算法实现应该会很酸爽。</p><a id="more"></a><p>Paxos算法中最重要的两个角色是<strong>Proposer</strong>和<strong>Acceptor</strong>。当然Leaner也很重要，特别是在PhxPaxos的实现中，Leaner具有重要的功能。但是因为《Paxos Made Simple》论文中主要还是Proposer和Acceptor，因此这篇文章还是以这两个角色为主，通过源码来回顾论文中Paxos算法的过程，同时也看看工程实现和论文的描述有什么区别。</p><p>这里先贴出Paxos算法的过程，方便大家对照接下来的工程实现。</p><ul><li><p><strong>Prepare阶段：</strong></p><p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。</p><p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给Proposer，同时该Acceptor承诺不再接受任何编号小于N的提案。</p></li><li><p><strong>Accept阶段：</strong></p><p>(a) 如果Proposer收到半数以上Acceptor对其发出的编号为N的Prepare请求的响应，那么它就会发送一个针对[N,V]提案的Accept请求给半数以上的Acceptor。注意：V就是收到的响应中编号最大的提案的value，如果响应中不包含任何提案，那么V就由Proposer自己决定。</p><p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor没有对编号大于N的Prepare请求做出过响应，它就接受该提案。</p></li></ul><h2 id="Proposer"><a href="#Proposer" class="headerlink" title="Proposer"></a>Proposer</h2><p>因为Proposer需要维护或者说记录一些状态信息，包括自己的提案编号ProposalID、提出的Value、其他Proposer提出的最大的提案编号HighestOtherProposalID、Acceptor已经接受过的编号最大的提案的值等，因此这里专门有一个ProposerState类来管理这些信息。同样Acceptor也有一个AcceptorState类来管理Acceptor相关的信息。</p><p>先来看下ProposerState的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ProposerState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProposerState(<span class="keyword">const</span> Config * poConfig);</span><br><span class="line">    ~ProposerState();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetStartProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">NewPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddPreAcceptValue</span><span class="params">(<span class="keyword">const</span> BallotNumber &amp; oOtherPreAcceptBallot, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sOtherPreAcceptValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> uint64_t <span class="title">GetProposalID</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> &amp; <span class="title">GetValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetOtherProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llOtherProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetHighestOtherPreAcceptBallot</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llProposalID;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llHighestOtherProposalID;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> m_sValue;</span><br><span class="line"></span><br><span class="line">    BallotNumber m_oHighestOtherPreAcceptBallot;</span><br><span class="line"></span><br><span class="line">    Config * m_poConfig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本都是对这些信息的set跟get，很容易理解。直接来看Proposer类的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Proposer : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Proposer(</span><br><span class="line">            <span class="keyword">const</span> Config * poConfig, </span><br><span class="line">            <span class="keyword">const</span> MsgTransport * poMsgTransport,</span><br><span class="line">            <span class="keyword">const</span> Instance * poInstance,</span><br><span class="line">            <span class="keyword">const</span> Learner * poLearner,</span><br><span class="line">            <span class="keyword">const</span> IOLoop * poIOLoop);</span><br><span class="line">    ~Proposer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置起始的ProposalID</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetStartProposalID</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint64_t</span> llProposalID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化新的一轮Paxos过程，每一轮叫做一个Paxos Instance，每一轮确定一个值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitForNewPaxosInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Proposer发起提案的入口函数。参数sValue即Proposer自己想提出的value，当然最终提出的value不一定是这个，需要根据Acceptor再Prepare阶段的回复来确定</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NewValue</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断Proposer是否处于Prepare阶段或Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsWorking</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应Paxos算法中的Prepare阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prepare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> bNeedNewBallot = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段等待Acceptor的回复，统计投票并确定是否进入Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPrepareReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段被拒绝</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExpiredPrepareReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对应Paxos算法中的Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段等待Acceptor的回复，统计投票并确定值(Value)是否被选定(Chosen)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAcceptReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段被拒绝</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExpiredAcceptReply</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPrepareTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段超时</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAcceptTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出Prepare阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExitPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExitAccept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消跳过Prepare阶段，也就是必须先Prepare阶段再Accept阶段</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CancelSkipPrepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddPrepareTimer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs = <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddAcceptTimer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ProposerState m_oProposerState;</span><br><span class="line">    MsgCounter m_oMsgCounter;</span><br><span class="line">    Learner * m_poLearner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bIsPreparing;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsAccepting;</span><br><span class="line"></span><br><span class="line">    IOLoop * m_poIOLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> m_iPrepareTimerID;</span><br><span class="line">    <span class="keyword">int</span> m_iLastPrepareTimeoutMs;</span><br><span class="line">    <span class="keyword">uint32_t</span> m_iAcceptTimerID;</span><br><span class="line">    <span class="keyword">int</span> m_iLastAcceptTimeoutMs;</span><br><span class="line">    <span class="keyword">uint64_t</span> m_llTimeoutInstanceID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bCanSkipPrepare;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> m_bWasRejectBySomeone;</span><br><span class="line"></span><br><span class="line">    TimeStat m_oTimeStat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="NewValue"><a href="#NewValue" class="headerlink" title="NewValue"></a>NewValue</h3><p>下面就从NewValue方法入手：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Proposer :: NewValue(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sValue)</span><br><span class="line">&#123;</span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;NewProposal(sValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_oProposerState.GetValue().size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_oProposerState.SetValue(sValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_iLastPrepareTimeoutMs = START_PREPARE_TIMEOUTMS;</span><br><span class="line">    m_iLastAcceptTimeoutMs = START_ACCEPT_TIMEOUTMS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果可以跳过Prepare阶段并且没有被Acceptor拒绝过，则直接进入Accept阶段</span></span><br><span class="line">    <span class="keyword">if</span> (m_bCanSkipPrepare &amp;&amp; !m_bWasRejectBySomeone)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;NewProposalSkipPrepare();</span><br><span class="line"></span><br><span class="line">        PLGHead(<span class="string">"skip prepare, directly start accept"</span>);</span><br><span class="line">        Accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则先进入Prepare阶段</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//if not reject by someone, no need to increase ballot</span></span><br><span class="line">        Prepare(m_bWasRejectBySomeone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以直接进入Accept阶段的前提是该Proposer已经发起过Prepare请求且得到半数以上的同意（即通过了Prepare阶段），并且没有被任何Acceptor拒绝（说明没有Acceptor响应过比该Proposer的提案编号更高的提案）。那么，什么情况下可以跳过Prepare请求呢，这里应该对应的是选出一个master的情况？相当于raft里的leader？</p><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>接下来直接看Prepare阶段：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: Prepare(<span class="keyword">const</span> <span class="keyword">bool</span> bNeedNewBallot)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Now.InstanceID %lu MyNodeID %lu State.ProposalID %lu State.ValueLen %zu"</span>,</span><br><span class="line">            GetInstanceID(), m_poConfig-&gt;GetMyNodeID(), m_oProposerState.GetProposalID(),</span><br><span class="line">            m_oProposerState.GetValue().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;Prepare();</span><br><span class="line">    m_oTimeStat.Point();</span><br><span class="line">    </span><br><span class="line">    ExitAccept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表明Proposer正处于Prepare阶段</span></span><br><span class="line">    m_bIsPreparing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能跳过Prepare阶段</span></span><br><span class="line">    m_bCanSkipPrepare = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目前还未被任意一个Acceptor拒绝</span></span><br><span class="line">    m_bWasRejectBySomeone = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    m_oProposerState.ResetHighestOtherPreAcceptBallot();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要产生新的投票，就调用NewPrepare产生新的ProposalID，新的ProposalID为当前已知的最大ProposalID+1</span></span><br><span class="line">    <span class="keyword">if</span> (bNeedNewBallot)</span><br><span class="line">    &#123;</span><br><span class="line">        m_oProposerState.NewPrepare();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PaxosMsg oPaxosMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Prepare消息的各个字段</span></span><br><span class="line">    oPaxosMsg.set_msgtype(MsgType_PaxosPrepare);</span><br><span class="line">    oPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oPaxosMsg.set_proposalid(m_oProposerState.GetProposalID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//MsgCount是专门用来统计票数的，根据计算的结果确定是否通过Prepare阶段或者Accept阶段</span></span><br><span class="line">    m_oMsgCounter.StartNewRound();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare超时定时器</span></span><br><span class="line">    AddPrepareTimer();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END OK"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Prepare消息发送到各个节点</span></span><br><span class="line">    BroadcastMessage(oPaxosMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proposer在Prepare阶段主要做了这么几件事：</p><ol><li>重置各个状态位，表明当前正处于Prepare阶段。</li><li>获取提案编号ProposalID。当bNeedNewBallot为true时需要将ProposalID+1。否则沿用之前的ProposalID。bNeedNewBallot是在NewValue中调用Prepare方法时传入的m_bWasRejectBySomeone参数。也就是如果之前没有被任何Acceptor拒绝（说明还没有明确出现更大的ProposalID），则不需要获取新的ProposalID。对应的场景是Prepare阶段超时了，在超时时间内没有收到过半Acceptor同意的消息，因此需要重新执行Prepare阶段，此时只需要沿用原来的ProposalID即可。</li><li>发送Prepare请求。该请求PaxosMsg是Protocol Buffer定义的一个message，包含MsgType、InstanceID、NodeID、ProposalID等字段。在BroadcastMessage(oPaxosMsg)中还会将oPaxosMsg序列化后才发送出去。</li></ol><p>PaxosMsg的定义如下，Prepare和Accept阶段Proposer和Acceptor的所有消息都用PaxosMsg来表示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">message PaxosMsg</span><br><span class="line">&#123;</span><br><span class="line">required int32 MsgType = <span class="number">1</span>;</span><br><span class="line">optional uint64 InstanceID = <span class="number">2</span>;</span><br><span class="line">optional uint64 NodeID = <span class="number">3</span>;</span><br><span class="line">optional uint64 ProposalID = <span class="number">4</span>;</span><br><span class="line">optional uint64 ProposalNodeID = <span class="number">5</span>;</span><br><span class="line">optional bytes Value = <span class="number">6</span>;</span><br><span class="line">optional uint64 PreAcceptID = <span class="number">7</span>;</span><br><span class="line">optional uint64 PreAcceptNodeID = <span class="number">8</span>;</span><br><span class="line">optional uint64 RejectByPromiseID = <span class="number">9</span>;</span><br><span class="line">optional uint64 NowInstanceID = <span class="number">10</span>;</span><br><span class="line">optional uint64 MinChosenInstanceID = <span class="number">11</span>;</span><br><span class="line">optional uint32 LastChecksum = <span class="number">12</span>;</span><br><span class="line">optional uint32 Flag = <span class="number">13</span>;</span><br><span class="line">optional bytes SystemVariables = <span class="number">14</span>;</span><br><span class="line">optional bytes MasterVariables = <span class="number">15</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="OnPrepareReply"><a href="#OnPrepareReply" class="headerlink" title="OnPrepareReply"></a>OnPrepareReply</h3><p>Proposer发出Prepare请求后就开始等待Acceptor的回复。当Proposer所在节点收到PaxosPrepareReply消息后，就会调用Proposer的OnPrepareReply(oPaxosMsg)，其中oPaxosMsg是Acceptor回复的消息。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: OnPrepareReply(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.ProposalID %lu State.ProposalID %lu Msg.from_nodeid %lu RejectByPromiseID %lu"</span>,</span><br><span class="line">            oPaxosMsg.proposalid(), m_oProposerState.GetProposalID(), </span><br><span class="line">            oPaxosMsg.nodeid(), oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;OnPrepareReply();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果Proposer不是在Prepare阶段，则忽略该消息</span></span><br><span class="line">    <span class="keyword">if</span> (!m_bIsPreparing)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnPrepareReplyButNotPreparing();</span><br><span class="line">        <span class="comment">//PLGErr("Not preparing, skip this msg");</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ProposalID不同，也忽略</span></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.proposalid() != m_oProposerState.GetProposalID())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnPrepareReplyNotSameProposalIDMsg();</span><br><span class="line">        <span class="comment">//PLGErr("ProposalID not same, skip this msg");</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入一个收到的消息，用于MsgCounter统计</span></span><br><span class="line">    m_oMsgCounter.AddReceive(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该消息不是拒绝，即Acceptor同意本次Prepare请求</span></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.rejectbypromiseid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BallotNumber oBallot(oPaxosMsg.preacceptid(), oPaxosMsg.preacceptnodeid());</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] PreAcceptedID %lu PreAcceptedNodeID %lu ValueSize %zu"</span>, </span><br><span class="line">                oPaxosMsg.preacceptid(), oPaxosMsg.preacceptnodeid(), oPaxosMsg.value().size());</span><br><span class="line">        <span class="comment">//加入MsgCounter用于统计投票</span></span><br><span class="line">        m_oMsgCounter.AddPromiseOrAccept(oPaxosMsg.nodeid());</span><br><span class="line">        <span class="comment">//将Acceptor返回的它接受过的编号最大的提案记录下来（如果有的话），用于确定Accept阶段的Value</span></span><br><span class="line">        m_oProposerState.AddPreAcceptValue(oBallot, oPaxosMsg.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Acceptor拒绝了Prepare请求</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Reject] RejectByPromiseID %lu"</span>, oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样也要记录到MsgCounter用于统计投票</span></span><br><span class="line">        m_oMsgCounter.AddReject(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录被Acceptor拒绝过，待会儿如果重新进入Prepare阶段的话就需要获取更大的ProposalID</span></span><br><span class="line">        m_bWasRejectBySomeone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录下别的Proposer提出的更大的ProposalID。这样重新发起Prepare请求时才知道需要用多大的ProposalID</span></span><br><span class="line">        m_oProposerState.SetOtherProposalID(oPaxosMsg.rejectbypromiseid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//本次Prepare请求通过了。也就是得到了半数以上Acceptor的同意</span></span><br><span class="line">    <span class="keyword">if</span> (m_oMsgCounter.IsPassedOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iUseTimeMs = m_oTimeStat.Point();</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;PreparePass(iUseTimeMs);</span><br><span class="line">        PLGImp(<span class="string">"[Pass] start accept, usetime %dms"</span>, iUseTimeMs);</span><br><span class="line">        m_bCanSkipPrepare = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入Accept阶段</span></span><br><span class="line">        Accept();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本次Prepare请求没有通过</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_oMsgCounter.IsRejectedOnThisRound()</span><br><span class="line">            || m_oMsgCounter.IsAllReceiveOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;PrepareNotPass();</span><br><span class="line">        PLGImp(<span class="string">"[Not Pass] wait 30ms and restart prepare"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//随机等待一段时间后重新发起Prepare请求</span></span><br><span class="line">        AddPrepareTimer(OtherUtils::FastRand() % <span class="number">30</span> + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该阶段Proposer主要做了以下事情：</p><ol><li><p>判断消息是否有效。包括ProposalID是否相同，自身是否处于Prepare阶段等。因为网络是不可靠的，有些消息可能延迟很久，等收到的时候已经不需要了，所以需要做这些判断。</p></li><li><p>将收到的消息加入MsgCounter用于统计。</p></li><li><p>根据收到的消息更新自身状态。包括Acceptor承诺过的ProposalID，以及Acceptor接受过的编号最大的提案等。</p></li><li><p>根据MsgCounter统计的Acceptor投票结果决定是进入Acceptor阶段还是重新发起Prepare请求。这里如果判断需要重新发起Prepare请求的话，也不是立即进行，而是等待一段随机的时间，这样做的好处是减少不同Proposer之间的冲突，采取的策略跟raft中leader选举冲突时在一段随机的选举超时时间后重新发起选举的做法类似。</p></li></ol><p>注：这里跟Paxos算法中提案编号对应的并不是ProposalID，而是BallotNumber。BallotNumber由ProposalID和NodeID组成。还实现了运算符重载。如果ProposalID大，则BallotNumber（即提案编号）大。在ProposalID相同的情况下，NodeID大的BallotNumber大。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p>接下来Proposer就进入Accept阶段：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: Accept()</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START ProposalID %lu ValueSize %zu ValueLen %zu"</span>, </span><br><span class="line">            m_oProposerState.GetProposalID(), m_oProposerState.GetValue().size(), m_oProposerState.GetValue().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;Accept();</span><br><span class="line">    m_oTimeStat.Point();</span><br><span class="line">    </span><br><span class="line">    ExitPrepare();</span><br><span class="line">    m_bIsAccepting = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Accept请求的消息内容</span></span><br><span class="line">    PaxosMsg oPaxosMsg;</span><br><span class="line">    oPaxosMsg.set_msgtype(MsgType_PaxosAccept);</span><br><span class="line">    oPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oPaxosMsg.set_proposalid(m_oProposerState.GetProposalID());</span><br><span class="line">    oPaxosMsg.set_value(m_oProposerState.GetValue());</span><br><span class="line">    oPaxosMsg.set_lastchecksum(GetLastChecksum());</span><br><span class="line"></span><br><span class="line">    m_oMsgCounter.StartNewRound();</span><br><span class="line"></span><br><span class="line">    AddAcceptTimer();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发给各个节点</span></span><br><span class="line">    BroadcastMessage(oPaxosMsg, BroadcastMessage_Type_RunSelf_Final);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Accept请求中PaxosMsg里的Value是这样确定的：如果Prepare阶段有Acceptor的回复中带有提案值，则该Value为所有的Acceptor的回复中，编号最大的提案的值。否则就是Proposer在最初调用NewValue时传入的值。</p><h3 id="OnAcceptReply"><a href="#OnAcceptReply" class="headerlink" title="OnAcceptReply"></a>OnAcceptReply</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Proposer :: OnAcceptReply(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.ProposalID %lu State.ProposalID %lu Msg.from_nodeid %lu RejectByPromiseID %lu"</span>,</span><br><span class="line">            oPaxosMsg.proposalid(), m_oProposerState.GetProposalID(), </span><br><span class="line">            oPaxosMsg.nodeid(), oPaxosMsg.rejectbypromiseid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetProposerBP()-&gt;OnAcceptReply();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_bIsAccepting)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLGErr("Not proposing, skip this msg");</span></span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnAcceptReplyButNotAccepting();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.proposalid() != m_oProposerState.GetProposalID())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLGErr("ProposalID not same, skip this msg");</span></span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;OnAcceptReplyNotSameProposalIDMsg();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_oMsgCounter.AddReceive(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oPaxosMsg.rejectbypromiseid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Accept]"</span>);</span><br><span class="line">        m_oMsgCounter.AddPromiseOrAccept(oPaxosMsg.nodeid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Reject]"</span>);</span><br><span class="line">        m_oMsgCounter.AddReject(oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">        m_bWasRejectBySomeone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        m_oProposerState.SetOtherProposalID(oPaxosMsg.rejectbypromiseid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_oMsgCounter.IsPassedOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iUseTimeMs = m_oTimeStat.Point();</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;AcceptPass(iUseTimeMs);</span><br><span class="line">        PLGImp(<span class="string">"[Pass] Start send learn, usetime %dms"</span>, iUseTimeMs);</span><br><span class="line">        ExitAccept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让Leaner学习被选定（Chosen）的值</span></span><br><span class="line">        m_poLearner-&gt;ProposerSendSuccess(GetInstanceID(), m_oProposerState.GetProposalID());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_oMsgCounter.IsRejectedOnThisRound()</span><br><span class="line">            || m_oMsgCounter.IsAllReceiveOnThisRound())</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetProposerBP()-&gt;AcceptNotPass();</span><br><span class="line">        PLGImp(<span class="string">"[Not pass] wait 30ms and Restart prepare"</span>);</span><br><span class="line">        AddAcceptTimer(OtherUtils::FastRand() % <span class="number">30</span> + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里跟OnPrepareReply的过程基本一致，因此就不加太多注释了。比较大的区别在于最后如果过半的Acceptor接受了该Accept请求，则说明该Value被选定（Chosen）了，就发送消息，让每个节点上的Learner学习该Value。因为Leaner不是本文的重点，这里就不详细介绍了。</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>Acceptor的逻辑比Proposer更简单。同样先看它的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Acceptor : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Acceptor(</span><br><span class="line">            <span class="keyword">const</span> Config * poConfig, </span><br><span class="line">            <span class="keyword">const</span> MsgTransport * poMsgTransport, </span><br><span class="line">            <span class="keyword">const</span> Instance * poInstance,</span><br><span class="line">            <span class="keyword">const</span> LogStorage * poLogStorage);</span><br><span class="line">    ~Acceptor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InitForNewPaxosInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AcceptorState * <span class="title">GetAcceptorState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare阶段回复Prepare请求</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OnPrepare</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Accept阶段回复Accept请求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAccept</span><span class="params">(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">    AcceptorState m_oAcceptorState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="OnPrepare"><a href="#OnPrepare" class="headerlink" title="OnPrepare"></a>OnPrepare</h3><p>OnPrepare用于处理收到的Prepare请求，逻辑如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Acceptor :: OnPrepare(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.InstanceID %lu Msg.from_nodeid %lu Msg.ProposalID %lu"</span>,</span><br><span class="line">            oPaxosMsg.instanceid(), oPaxosMsg.nodeid(), oPaxosMsg.proposalid());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetAcceptorBP()-&gt;OnPrepare();</span><br><span class="line">    </span><br><span class="line">    PaxosMsg oReplyPaxosMsg;</span><br><span class="line">    oReplyPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oReplyPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oReplyPaxosMsg.set_proposalid(oPaxosMsg.proposalid());</span><br><span class="line">    oReplyPaxosMsg.set_msgtype(MsgType_PaxosPrepareReply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造接收到的Prepare请求里的提案编号</span></span><br><span class="line">    BallotNumber oBallot(oPaxosMsg.proposalid(), oPaxosMsg.nodeid());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提案编号大于承诺过的提案编号</span></span><br><span class="line">    <span class="keyword">if</span> (oBallot &gt;= m_oAcceptorState.GetPromiseBallot())</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] State.PromiseID %lu State.PromiseNodeID %lu "</span></span><br><span class="line">                <span class="string">"State.PreAcceptedID %lu State.PreAcceptedNodeID %lu"</span>,</span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llProposalID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//返回之前接受过的提案的编号</span></span><br><span class="line">oReplyPaxosMsg.set_preacceptid(m_oAcceptorState.GetAcceptedBallot().m_llProposalID);</span><br><span class="line">        oReplyPaxosMsg.set_preacceptnodeid(m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line">        <span class="comment">//如果接受过的提案编号大于0（&lt;=0说明没有接受过提案），则设置接受过的提案的Value</span></span><br><span class="line">        <span class="keyword">if</span> (m_oAcceptorState.GetAcceptedBallot().m_llProposalID &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            oReplyPaxosMsg.set_value(m_oAcceptorState.GetAcceptedValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新承诺的提案编号为新的提案编号（因为新的提案编号更大）</span></span><br><span class="line">        m_oAcceptorState.SetPromiseBallot(oBallot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//信息持久化</span></span><br><span class="line">        <span class="keyword">int</span> ret = m_oAcceptorState.Persist(GetInstanceID(), GetLastChecksum());</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BP-&gt;GetAcceptorBP()-&gt;OnPreparePersistFail();</span><br><span class="line">            PLGErr(<span class="string">"Persist fail, Now.InstanceID %lu ret %d"</span>,</span><br><span class="line">                    GetInstanceID(), ret);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnPreparePass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提案编号小于承诺过的提案编号，需要拒绝</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnPrepareReject();</span><br><span class="line"></span><br><span class="line">        PLGDebug(<span class="string">"[Reject] State.PromiseID %lu State.PromiseNodeID %lu"</span>, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//拒绝该Prepare请求，并返回承诺过的ProposalID      </span></span><br><span class="line">oReplyPaxosMsg.set_rejectbypromiseid(m_oAcceptorState.GetPromiseBallot().m_llProposalID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nodeid_t</span> iReplyNodeID = oPaxosMsg.nodeid();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END Now.InstanceID %lu ReplyNodeID %lu"</span>,</span><br><span class="line">            GetInstanceID(), oPaxosMsg.nodeid());;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向发出Prepare请求的Proposer回复消息</span></span><br><span class="line">    SendMessage(iReplyNodeID, oReplyPaxosMsg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnAccept"><a href="#OnAccept" class="headerlink" title="OnAccept"></a>OnAccept</h3><p>再来看看OnAccept：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Acceptor :: OnAccept(<span class="keyword">const</span> PaxosMsg &amp; oPaxosMsg)</span><br><span class="line">&#123;</span><br><span class="line">    PLGHead(<span class="string">"START Msg.InstanceID %lu Msg.from_nodeid %lu Msg.ProposalID %lu Msg.ValueLen %zu"</span>,</span><br><span class="line">            oPaxosMsg.instanceid(), oPaxosMsg.nodeid(), oPaxosMsg.proposalid(), oPaxosMsg.value().size());</span><br><span class="line"></span><br><span class="line">    BP-&gt;GetAcceptorBP()-&gt;OnAccept();</span><br><span class="line"></span><br><span class="line">    PaxosMsg oReplyPaxosMsg;</span><br><span class="line">    oReplyPaxosMsg.set_instanceid(GetInstanceID());</span><br><span class="line">    oReplyPaxosMsg.set_nodeid(m_poConfig-&gt;GetMyNodeID());</span><br><span class="line">    oReplyPaxosMsg.set_proposalid(oPaxosMsg.proposalid());</span><br><span class="line">    oReplyPaxosMsg.set_msgtype(MsgType_PaxosAcceptReply);</span><br><span class="line"></span><br><span class="line">    BallotNumber oBallot(oPaxosMsg.proposalid(), oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提案编号不小于承诺过的提案编号（注意：这里是“&gt;=”，而再OnPrepare中是“&gt;”，可以先思考下为什么），需要接受该提案</span></span><br><span class="line">    <span class="keyword">if</span> (oBallot &gt;= m_oAcceptorState.GetPromiseBallot())</span><br><span class="line">    &#123;</span><br><span class="line">        PLGDebug(<span class="string">"[Promise] State.PromiseID %lu State.PromiseNodeID %lu "</span></span><br><span class="line">                <span class="string">"State.PreAcceptedID %lu State.PreAcceptedNodeID %lu"</span>,</span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llProposalID,</span><br><span class="line">                m_oAcceptorState.GetAcceptedBallot().m_llNodeID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新承诺的提案编号；接受的提案编号、提案值</span></span><br><span class="line">        m_oAcceptorState.SetPromiseBallot(oBallot);</span><br><span class="line">        m_oAcceptorState.SetAcceptedBallot(oBallot);</span><br><span class="line">        m_oAcceptorState.SetAcceptedValue(oPaxosMsg.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//信息持久化</span></span><br><span class="line">        <span class="keyword">int</span> ret = m_oAcceptorState.Persist(GetInstanceID(), GetLastChecksum());</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BP-&gt;GetAcceptorBP()-&gt;OnAcceptPersistFail();</span><br><span class="line"></span><br><span class="line">            PLGErr(<span class="string">"Persist fail, Now.InstanceID %lu ret %d"</span>,</span><br><span class="line">                    GetInstanceID(), ret);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnAcceptPass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要拒绝该提案</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetAcceptorBP()-&gt;OnAcceptReject();</span><br><span class="line"></span><br><span class="line">        PLGDebug(<span class="string">"[Reject] State.PromiseID %lu State.PromiseNodeID %lu"</span>, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llProposalID, </span><br><span class="line">                m_oAcceptorState.GetPromiseBallot().m_llNodeID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拒绝的消息中附上承诺过的ProposalID</span></span><br><span class="line">        oReplyPaxosMsg.set_rejectbypromiseid(m_oAcceptorState.GetPromiseBallot().m_llProposalID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nodeid_t</span> iReplyNodeID = oPaxosMsg.nodeid();</span><br><span class="line"></span><br><span class="line">    PLGHead(<span class="string">"END Now.InstanceID %lu ReplyNodeID %lu"</span>,</span><br><span class="line">            GetInstanceID(), oPaxosMsg.nodeid());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将响应发送给Proposer</span></span><br><span class="line">    SendMessage(iReplyNodeID, oReplyPaxosMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过阅读源码可以发现，整个PhxPaxos完全基于Lamport的《Paxos Made Simple》进行工程化，没有进行任何算法变种。这对于学习Paxos算法的人来说真的是一笔宝贵的财富，所以如果对Paxos算法感兴趣，应该深入地去阅读PhxPaxos的源码，相信看完后大家对Paxos会有更深的理解。同时我们也发现，在工程实现上还是有很多细节需要注意，这比单纯理解算法要难得多。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇主要来分析Paxos算法实现的部分，我想这应该也是读者最感兴趣的。在看这篇文章之前，如果之前对Paxos算法没有了解的童鞋可以看下这篇文章：&lt;a href=&quot;http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/&quot;&gt;Paxos算法原理与推导&lt;/a&gt;，相信了解Paxos算法后再来通过源码看算法实现应该会很酸爽。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://linbingdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="PhxPaxos" scheme="http://linbingdong.com/tags/PhxPaxos/"/>
    
  </entry>
  
  <entry>
    <title>PhxPaxos源码分析——网络</title>
    <link href="http://linbingdong.com/2017/11/20/PhxPaxos%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C/"/>
    <id>http://linbingdong.com/2017/11/20/PhxPaxos源码分析——网络/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2017-11-20T10:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>了解分布式系统的童鞋肯定听过Paxos算法的大名。Paxos算法以晦涩难懂著称，其工程实现更难。目前，号称在工程上实现了Paxos算法的应该只有Google、阿里和腾讯。然而，只有腾讯的微信团队真正将代码开源出来，他们将Paxos算法的实现封装成了一个Paxos库，大家可以基于该库实现自己想要的功能，比如用于master选举，或者甚至利用它来实现一个分布式KV数据库等。</p><a id="more"></a><p>之前就对Paxos很感兴趣，但是一直没看过实现的代码，这次微信开源了PhxPaxos后终于有机会深入地了解Paxos的实现细节。在这里感谢微信团队。感谢PhxPaxos的作者。让我们一起来领略Paxos的魅力吧。</p><p>本次的源码分析先从网络部分开始。因为在分布式系统中不可避免会涉及到不同节点以及相同节点上不同进程之间的通信。因此网络部分也是至关重要，所以就先把网络单独拿出来看，接下来再去看Paxos算法的实现部分。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>源码的include/phxpaxos目录下是公共头文件。include/phpaxos/network.h 是网络模块的抽象函数，如果用户想使用自己的网络协议，可以通过重写这些函数实现网络模块的自定义。</p><p>我们先来看下network.h的内容：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> phxpaxos</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//You can use your own network to make paxos communicate. :)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> NetWork</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NetWork();</span><br><span class="line">    <span class="keyword">virtual</span> ~NetWork() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Network must not send/recieve any message before paxoslib called this funtion.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RunNetWork</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//If paxoslib call this function, network need to stop receive any message.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StopNetWork</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SendMessageTCP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">SendMessageUDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//When receive a message, call this funtion.</span></span><br><span class="line">    <span class="comment">//This funtion is async, just enqueue an return.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">OnReceiveMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pcMessage, <span class="keyword">const</span> <span class="keyword">int</span> iMessageLen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> Node;</span><br><span class="line">    Node * m_poNode;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数的作用从名字就可以看出来。而且都是虚函数，即需要重写这些函数。在PhxPaxos中，提供了一个默认的网络模块，就是继承了NetWork类。该类的名字叫DFNetWork，DF应该就是default的缩写了。如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> phxpaxos </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DFNetWork : <span class="keyword">public</span> NetWork</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DFNetWork();</span><br><span class="line">    <span class="keyword">virtual</span> ~DFNetWork();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RunNetWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopNetWork</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendMessageTCP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SendMessageUDP</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UDPRecv m_oUDPRecv;</span><br><span class="line">    UDPSend m_oUDPSend;</span><br><span class="line">    TcpIOThread m_oTcpIOThread;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类的私有成员里有UDPRecv、UDPSend和TcpIOThread三个类的对象，这三个类分别用于接收UDP消息、发送UDP消息以及收发TCP消息。</p><p>Init方法就是将UDPRecv、UDPSend和TcpIOThread分别初始化:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: Init(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount) </span><br><span class="line">&#123;  <span class="comment">//初始化UDPSend</span></span><br><span class="line">    <span class="keyword">int</span> ret = m_oUDPSend.Init();</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化UDPRecv</span></span><br><span class="line">    ret = m_oUDPRecv.Init(iListenPort);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化TCP</span></span><br><span class="line">    ret = m_oTcpIOThread.Init(sListenIp, iListenPort, iIOThreadCount);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"m_oTcpIOThread Init fail, ret %d"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的初始化过程就是调用socket的api。以UDPRecv为例，就是创建socket、设定端口、设置socket属性（如端口可重用）最后绑定端口。如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> UDPRecv :: Init(<span class="keyword">const</span> <span class="keyword">int</span> iPort)</span><br><span class="line">&#123;  <span class="comment">//创建socket，获得socket fd</span></span><br><span class="line">    <span class="keyword">if</span> ((m_iSockFD = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(iPort);  <span class="comment">//设定端口</span></span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设定socket属性，端口可重用</span></span><br><span class="line">    setsockopt(m_iSockFD, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//绑定，用于监听</span></span><br><span class="line">    <span class="keyword">if</span> (bind(m_iSockFD, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RunNetWork就是将UDPRecv、UDPSend和TcpIOThread分别运行起来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> DFNetWork :: RunNetWork()</span><br><span class="line">&#123;  <span class="comment">//UDPSend和UDPRecv都是调用Thread的start方法</span></span><br><span class="line">    m_oUDPSend.start();</span><br><span class="line">    m_oUDPRecv.start();</span><br><span class="line">    <span class="comment">//TCP的Start是封装过的</span></span><br><span class="line">    m_oTcpIOThread.Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TcpIOThread的Start()实际执行的代码如下，分别启动了TcpAcceptor、TcpWrite和TcpRead：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpIOThread :: Start()</span><br><span class="line">&#123;</span><br><span class="line">    m_oTcpAcceptor.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poTcpWrite : m_vecTcpWrite)</span><br><span class="line">    &#123;</span><br><span class="line">        poTcpWrite-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poTcpRead : m_vecTcpRead)</span><br><span class="line">    &#123;</span><br><span class="line">        poTcpRead-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StopNetWork就是将UDPRecv、UDPSend和TcpIOThread停止。</p><p>SendMessageTCP就是将消息用TCP发送：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: SendMessageTCP(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oTcpIOThread.AddMessage(iGroupIdx, sIp, iPort, sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SendMessageUDP就是将消息用UDP发送：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> DFNetWork :: SendMessageUDP(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIp, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oUDPSend.AddMessage(sIp, iPort, sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDPSend"><a href="#UDPSend" class="headerlink" title="UDPSend"></a>UDPSend</h3><p>前面SendMessageUDP调用了m_oUDPSend.AddMessage。这里的UDPSend维护了一个发送队列，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Queue&lt;QueueData *&gt; m_oSendQueue;</span><br></pre></td></tr></table></figure><p>m_oUDPSend.AddMessage就是将消息加入到UDP的m_oSendQueue中。</p><p>然后UDPSend在run方法中一直循环将m_oSendQueue中的消息发送出去：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UDPSend :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QueueData * poData = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//同步，线程安全</span></span><br><span class="line">        m_oSendQueue.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> bSucc = m_oSendQueue.peek(poData, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (bSucc)</span><br><span class="line">        &#123;   <span class="comment">//取出队头消息</span></span><br><span class="line">            m_oSendQueue.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_oSendQueue.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poData != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   <span class="comment">//将消息发送出去</span></span><br><span class="line">            SendMessage(poData-&gt;m_sIP, poData-&gt;m_iPort, poData-&gt;m_sMessage);</span><br><span class="line">            <span class="keyword">delete</span> poData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"UDPSend [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此UDPSend就是把消息加入到消息队列，然后循环将消息队列里的消息发送出去。</p><h3 id="UDPRecv"><a href="#UDPRecv" class="headerlink" title="UDPRecv"></a>UDPRecv</h3><p>接下来看看UDPRecv。UDPRecv的初始化前面已经看过了，就是简单的获得socket fd，设定sockaddr_in，设置socket属性最后将socket fd和sockaddr_in绑定用于监听。</p><p>主要来看看UDPRecv的run方法。这里主要用了I/O多路复用中的poll，注册了一个pollfd，该pollfd的fd即之前创建的绑定了端口的socket fd，events为POLLIN，表示监听数据可读事件，如果有数据可读了，则调用recvfrom读入数据。最后调用OnReceiveMessage将消息添加到当前instance的IoLoop中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UDPRecv :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sBuffer[<span class="number">65536</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in addr;</span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"UDPRecv [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> pollfd fd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        fd.fd = m_iSockFD;</span><br><span class="line">        <span class="comment">//注册POLLIN事件</span></span><br><span class="line">        fd.events = POLLIN;</span><br><span class="line">        <span class="comment">//调用poll检查是否有数据可读</span></span><br><span class="line">        ret = poll(&amp;fd, <span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span> || ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将接收到的数据放入sBuffer中</span></span><br><span class="line">        <span class="keyword">int</span> iRecvLen = recvfrom(m_iSockFD, sBuffer, <span class="keyword">sizeof</span>(sBuffer), <span class="number">0</span>,</span><br><span class="line">                (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;UDPReceive(iRecvLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iRecvLen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;   <span class="comment">//这里会依次调用Node和Instance的OnReceiveMessage方法，最后将消息加入到Instance的IoLoop中</span></span><br><span class="line">            m_poDFNetWork-&gt;OnReceiveMessage(sBuffer, iRecvLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TcpIOThread"><a href="#TcpIOThread" class="headerlink" title="TcpIOThread"></a>TcpIOThread</h3><p>接下来看看收发TCP消息的TcpIOThread：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpIOThread </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpIOThread(NetWork * poNetWork);</span><br><span class="line">    ~TcpIOThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于初始化TcpAcceptor以及iIOThreadCount个m_vecTcpRead和m_vecTcpWrite</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIp, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort, <span class="keyword">const</span> <span class="keyword">int</span> iIOThreadCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动TcpAcceptor用于监听以及所有的m_vecTcpRead和m_vecTcpWrite用于读写消息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止TcpAcceptor和所有的m_vecTcpRead及m_vecTcpWrite</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息加入到特定TcpWrite的消息队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AddMessage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> iGroupIdx, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NetWork * m_poNetWork;</span><br><span class="line">    TcpAcceptor m_oTcpAcceptor;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TcpRead *&gt; m_vecTcpRead;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TcpWrite *&gt; m_vecTcpWrite;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsStarted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TcpRead类似于前面讲的UDPRecv，TcpWrite类似于于UDPSend。严格来讲，TcpAcceptor + TcpRead才是UDPRecv。这里把TcpAcceptor单独抽出来，专门用于监听连接请求并建立连接。TcpRead只需要负责读消息就行。</p><h3 id="TcpAcceptor"><a href="#TcpAcceptor" class="headerlink" title="TcpAcceptor"></a>TcpAcceptor</h3><p>我们来看看TcpAcceptor：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpAcceptor : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpAcceptor();</span><br><span class="line">    ~TcpAcceptor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听端口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Listen</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sListenIP, <span class="keyword">const</span> <span class="keyword">int</span> iListenPort)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一直while循环，监听连接事件并建立连接获得fd，然后添加事件到EventLoop中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEventLoop</span><span class="params">(EventLoop * poEventLoop)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEvent</span><span class="params">(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//服务端的socket，用于监听</span></span><br><span class="line">    ServerSocket m_oSocket;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;EventLoop *&gt; m_vecEventLoop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> m_bIsEnd;</span><br><span class="line">    <span class="keyword">bool</span> m_bIsStarted;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里主要来看下run方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpAcceptor :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    PLHead(<span class="string">"start accept..."</span>);</span><br><span class="line"></span><br><span class="line">    m_oSocket.setAcceptTimeout(<span class="number">500</span>);</span><br><span class="line">    m_oSocket.setNonBlocking(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> pollfd pfd;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        pfd.fd =  m_oSocket.getSocketHandle();</span><br><span class="line">        <span class="comment">//注册事件</span></span><br><span class="line">        pfd.events = POLLIN;</span><br><span class="line">        <span class="comment">//等待事件到来</span></span><br><span class="line">        ret = poll(&amp;pfd, <span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; ret != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SocketAddress oAddr;</span><br><span class="line">            <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//建立连接，获得fd。这里的acceptfd对accept进行了简单的封装</span></span><br><span class="line">                fd = m_oSocket.acceptfd(&amp;oAddr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...)</span><br><span class="line">            &#123;</span><br><span class="line">                fd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                BP-&gt;GetNetworkBP()-&gt;TcpAcceptFd();</span><br><span class="line"></span><br><span class="line">                PLImp(<span class="string">"accepted!, fd %d ip %s port %d"</span>,</span><br><span class="line">                        fd, oAddr.getHost().c_str(), oAddr.getPort());</span><br><span class="line">                <span class="comment">//添加事件</span></span><br><span class="line">                AddEvent(fd, oAddr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"TCP.Acceptor [END]"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看AddEvent方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TcpAcceptor :: AddEvent(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span><br><span class="line">&#123;</span><br><span class="line">    EventLoop * poMinActiveEventLoop = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> iMinActiveEventCount = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; poEventLoop : m_vecEventLoop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iActiveCount = poEventLoop-&gt;GetActiveEventCount();</span><br><span class="line">        <span class="keyword">if</span> (iActiveCount &lt; iMinActiveEventCount)</span><br><span class="line">        &#123;</span><br><span class="line">            iMinActiveEventCount = iActiveCount;</span><br><span class="line">            poMinActiveEventLoop = poEventLoop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">oAddr.getPort());</span><br><span class="line">    poMinActiveEventLoop-&gt;AddEvent(iFD, oAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即找到活跃数最少的EventLoop，将事件添加到该EventLoop中。这里应该是为了负载均衡，防止有些线程工作量很大，有些则很空闲。</p><p>具体EventLoop的AddEvent就是将事件加入到FDQueue中，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: AddEvent(<span class="keyword">int</span> iFD, SocketAddress oAddr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; oLockGuard(m_oMutex);</span><br><span class="line">    m_oFDQueue.push(make_pair(iFD, oAddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里TcpAcceptor的作用及实现基本就很清晰了。</p><h3 id="TcpRead"><a href="#TcpRead" class="headerlink" title="TcpRead"></a>TcpRead</h3><p>先来看看TcpRead类的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpRead : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpRead(NetWork * poNetWork);</span><br><span class="line">    ~TcpRead();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">EventLoop * <span class="title">GetEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop m_oEventLoop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的成员变量是一个EventLoop对象。通过源码发现，Init、run、Stop方法其实都是调用了m_oEventLoop相应的方法，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> TcpRead :: Init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_oEventLoop.Init(<span class="number">20480</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpRead :: run()</span><br><span class="line">&#123;</span><br><span class="line">    m_oEventLoop.StartLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> TcpRead :: Stop()</span><br><span class="line">&#123;</span><br><span class="line">    m_oEventLoop.Stop();</span><br><span class="line">    join();</span><br><span class="line"></span><br><span class="line">    PLHead(<span class="string">"TcpReadThread [END]"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此主要来看下EventLoop。</p><p>首先说下Event。PhxPaxos在TCP这块主要用了I/O多路复用中的epoll。这里主要将数据和通知等都封装成Event，然后由TcpWrite和TcpRead的EventLoop去执行。PhxPaxos中的Event包含两个子类，分别是MessageEvent和Notify。其中MessageEvent主要用于数据的读写；而Notify主要用于通知事件发生。这里的Notify基于管道pipe和EPOLLIN事件来实现，可以通过Notify的Init方法看出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Notify :: Init()</span><br><span class="line">&#123;   <span class="comment">//m_iPipeFD是一个长度为2的int数组，用于存放管道两端的socket fd</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(m_iPipeFD);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"create pipe fail, ret %d"</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fcntl(m_iPipeFD[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">    fcntl(m_iPipeFD[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    AddEvent(EPOLLIN);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到EventLoop。首先看下EventLoop的Init方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> EventLoop :: Init(<span class="keyword">const</span> <span class="keyword">int</span> iEpollLength)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//创建epoll句柄，iEpollLength为监听的fd数</span></span><br><span class="line">    m_iEpollFd = epoll_create(iEpollLength);</span><br><span class="line">    <span class="keyword">if</span> (m_iEpollFd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"epoll_create fail, ret %d"</span>, m_iEpollFd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_poNotify = <span class="keyword">new</span> Notify(<span class="keyword">this</span>);</span><br><span class="line">    assert(m_poNotify != <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化Notify：创建pipe，设置m_iPipeFD并添加EPOLLIN事件</span></span><br><span class="line">    <span class="keyword">int</span> ret = m_poNotify-&gt;Init();</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来看下最重要的StartLoop：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: StartLoop()</span><br><span class="line">&#123;</span><br><span class="line">    m_bIsEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;TcpEpollLoop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iNextTimeout = <span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">        DealwithTimeout(iNextTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PLHead("nexttimeout %d", iNextTimeout);</span></span><br><span class="line"></span><br><span class="line">        OneLoop(iNextTimeout);</span><br><span class="line"></span><br><span class="line">        CreateEvent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_poTcpClient != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_poTcpClient-&gt;DealWithWrite();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_bIsEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            PLHead(<span class="string">"TCP.EventLoop [END]"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主循环是OneLoop：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> EventLoop :: OneLoop(<span class="keyword">const</span> <span class="keyword">int</span> iTimeoutMs)</span><br><span class="line">&#123;  <span class="comment">//调用epoll_wait等待事件发生</span></span><br><span class="line">    <span class="keyword">int</span> n = epoll_wait(m_iEpollFd, m_EpollEvents, MAX_EVENTS, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINTR)</span><br><span class="line">        &#123;</span><br><span class="line">            PLErr(<span class="string">"epoll_wait fail, errno %d"</span>, errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐一处理发生的epoll事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iFd = m_EpollEvents[i].data.fd;</span><br><span class="line">        <span class="keyword">auto</span> it = m_mapEvent.find(iFd);</span><br><span class="line">        <span class="keyword">if</span> (it == end(m_mapEvent))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iEvents = m_EpollEvents[i].events;</span><br><span class="line">        Event * poEvent = it-&gt;second.m_poEvent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (iEvents &amp; EPOLLERR)</span><br><span class="line">        &#123;</span><br><span class="line">            OnError(iEvents, poEvent);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是EPOLLIN事件，表明由数据可读，则调用poEvent的OnRead方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (iEvents &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = poEvent-&gt;OnRead();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是EPOLLOUT事件，表明由数据可写，则调用poEvent的OnWrite方法处理</span></span><br><span class="line">            <span class="keyword">if</span> (iEvents &amp; EPOLLOUT)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = poEvent-&gt;OnWrite();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OnError(iEvents, poEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他具体的细节这里就不再赘述了，有兴趣的可以自己去看看源码。</p><h3 id="TcpWrite"><a href="#TcpWrite" class="headerlink" title="TcpWrite"></a>TcpWrite</h3><p>看完了TcpRead，再来看看TcpWrite。首先还是看它的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> TcpWrite : <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TcpWrite(NetWork * poNetWork);</span><br><span class="line">    ~TcpWrite();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AddMessage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TcpClient m_oTcpClient;</span><br><span class="line">    EventLoop m_oEventLoop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Init、run、Stop跟TcpRead中对应方法的作用一致。AddMessage则是调用了m_oTcpClient的AddMessage方法。发现TcpWrite的成员变量比TcpRead多了一个TcpClient对象，因此主要来看看这个TcpClient是干嘛的。</p><p>刚刚说TcpWrite的AddMessage调用了m_oTcpClient的AddMessage方法。在m_oTcpClient的AddMessage方法中，则是先创建了一个指向MessageEvent对象的指针poEvent，然后再调用poEvent的AddMessage方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> TcpClient :: AddMessage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sIP, <span class="keyword">const</span> <span class="keyword">int</span> iPort, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//PLImp("ok");</span></span><br><span class="line">    MessageEvent * poEvent = GetEvent(sIP, iPort);</span><br><span class="line">    <span class="keyword">if</span> (poEvent == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"no event created for this ip %s port %d"</span>, sIP.c_str(), iPort);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> poEvent-&gt;AddMessage(sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此继续看看MessageEvent的AddMessage方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: AddMessage(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; sMessage)</span><br><span class="line">&#123;</span><br><span class="line">    m_llLastActiveTime = Time::GetSteadyClockMS();</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; oLock(m_oMutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_oInQueue.size() &gt; TCP_QUEUE_MAXLEN)</span><br><span class="line">    &#123;</span><br><span class="line">        BP-&gt;GetNetworkBP()-&gt;TcpQueueFull();</span><br><span class="line">        <span class="comment">//PLErr("queue length %d too long, can't enqueue", m_oInQueue.size());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_iQueueMemSize &gt; MAX_QUEUE_MEM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLErr("queue memsize %d too large, can't enqueue", m_iQueueMemSize);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueueData tData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息封装成QueueData后放入队列</span></span><br><span class="line">    tData.llEnqueueAbsTime = Time::GetSteadyClockMS();</span><br><span class="line">    tData.psValue = <span class="keyword">new</span> <span class="built_in">string</span>(sMessage);</span><br><span class="line">    m_oInQueue.push(tData);</span><br><span class="line"></span><br><span class="line">    m_iQueueMemSize += sMessage.size();</span><br><span class="line"></span><br><span class="line">    oLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出EpollWait，实际是调用SendNotify发送了一个通知</span></span><br><span class="line">    JumpoutEpollWait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里将消息加上入队时间后封装成一个QueueDate，然后放入m_oInQueue队列中。最后调用EventLoop的SendNotify发送了一个通知（利用之前创建的pipe）退出EpollWait。</p><p>说完了消息怎么入队，那消息是怎么发送出去的呢？</p><p>这里主要涉及到MessageEvent的OnWrite函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: OnWrite()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要发送队列不为空或者还有上次未发送完的数据，就调用DoOnWrite执行真正的发送操作</span></span><br><span class="line">    <span class="keyword">while</span> (!m_oInQueue.empty() || m_iLeftWriteLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = DoOnWrite();</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> &amp;&amp; ret != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//need break, wait next write</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteDone();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DoOnWrite:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageEvent :: DoOnWrite()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//上一次的消息还未发送完毕，将剩下的发送完</span></span><br><span class="line">    <span class="keyword">if</span> (m_iLeftWriteLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> WriteLeft();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_oMutex.lock();</span><br><span class="line">    <span class="keyword">if</span> (m_oInQueue.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        m_oMutex.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中取出一条新消息，准备发送</span></span><br><span class="line">    QueueData tData = m_oInQueue.front();</span><br><span class="line">    m_oInQueue.pop();</span><br><span class="line">    m_iQueueMemSize -= tData.psValue-&gt;size();</span><br><span class="line">    m_oMutex.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> * poMessage = tData.psValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果该消息入队太久没有被处理，则抛弃，不发送</span></span><br><span class="line">    <span class="keyword">uint64_t</span> llNowTime = Time::GetSteadyClockMS();</span><br><span class="line">    <span class="keyword">int</span> iDelayMs = llNowTime &gt; tData.llEnqueueAbsTime ? (<span class="keyword">int</span>)(llNowTime - tData.llEnqueueAbsTime) : <span class="number">0</span>;</span><br><span class="line">    BP-&gt;GetNetworkBP()-&gt;TcpOutQueue(iDelayMs);</span><br><span class="line">    <span class="keyword">if</span> (iDelayMs &gt; TCP_OUTQUEUE_DROP_TIMEMS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//PLErr("drop request because enqueue timeout, nowtime %lu unqueuetime %lu",</span></span><br><span class="line">                <span class="comment">//llNowTime, tData.llEnqueueAbsTime);</span></span><br><span class="line">        <span class="keyword">delete</span> poMessage;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算发送缓冲区长度，需要加上4字节用于表示消息长度</span></span><br><span class="line">    <span class="keyword">int</span> iBuffLen = poMessage-&gt;size();</span><br><span class="line">    <span class="keyword">int</span> niBuffLen = htonl(iBuffLen + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iLen = iBuffLen + <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//申请缓冲区</span></span><br><span class="line">    m_oWriteCacheBuffer.Ready(iLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息长度及消息内容拷贝到缓冲区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(m_oWriteCacheBuffer.GetPtr(), &amp;niBuffLen, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(m_oWriteCacheBuffer.GetPtr() + <span class="number">4</span>, poMessage-&gt;c_str(), iBuffLen);</span><br><span class="line"></span><br><span class="line">    m_iLeftWriteLen = iLen;</span><br><span class="line">    m_iLastWritePos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> poMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PLImp("write len %d ip %s port %d", iLen, m_oAddr.getHost().c_str(), m_oAddr.getPort());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始发送消息，有可能消息太大一次发送不完</span></span><br><span class="line">    <span class="keyword">int</span> iWriteLen = m_oSocket.send(m_oWriteCacheBuffer.GetPtr(), iLen);</span><br><span class="line">    <span class="keyword">if</span> (iWriteLen &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"fail, write len %d ip %s port %d"</span>,</span><br><span class="line">                iWriteLen, m_oAddr.getHost().c_str(), m_oAddr.getPort());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要下次再发送</span></span><br><span class="line">    <span class="keyword">if</span> (iWriteLen == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//need wait next write</span></span><br><span class="line">        AddEvent(EPOLLOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PLImp("real write len %d", iWriteLen);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送成功</span></span><br><span class="line">    <span class="keyword">if</span> (iWriteLen == iLen)</span><br><span class="line">    &#123;</span><br><span class="line">        m_iLeftWriteLen = <span class="number">0</span>;</span><br><span class="line">        m_iLastWritePos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//write done</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有一次性全部发送完，剩下的需要下次发送</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iWriteLen &lt; iLen)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//m_iLastWritePos和m_iLeftWriteLen分别用来表示上次写的位置以及剩下需要发送的长度</span></span><br><span class="line">        m_iLastWritePos = iWriteLen;</span><br><span class="line">        m_iLeftWriteLen = iLen - iWriteLen;</span><br><span class="line"></span><br><span class="line">        PLImp(<span class="string">"write buflen %d smaller than expectlen %d"</span>, iWriteLen, iLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PLErr(<span class="string">"write buflen %d large than expectlen %d"</span>, iWriteLen, iLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>先介绍这么多吧，接下去会有更多相关的文章，特别是PhxPaxos中实现Paxos算法的那部分，相信看过Paxos相关论文的童鞋会对这块很感兴趣。</p><p>最后，附上PhxPaxos源码的地址：<a href="https://github.com/Tencent/phxpaxos" target="_blank" rel="noopener">https://github.com/Tencent/phxpaxos</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解分布式系统的童鞋肯定听过Paxos算法的大名。Paxos算法以晦涩难懂著称，其工程实现更难。目前，号称在工程上实现了Paxos算法的应该只有Google、阿里和腾讯。然而，只有腾讯的微信团队真正将代码开源出来，他们将Paxos算法的实现封装成了一个Paxos库，大家可以基于该库实现自己想要的功能，比如用于master选举，或者甚至利用它来实现一个分布式KV数据库等。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://linbingdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="PhxPaxos" scheme="http://linbingdong.com/tags/PhxPaxos/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://linbingdong.com/2017/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://linbingdong.com/2017/11/11/设计模式-适配器模式/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2017-11-11T03:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍适配器模式。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>适配器模式</strong>将一个类的接口，转换成客户端期待的另一个接口。</p><p>比如我们想用苹果的充电线给安卓充电。但是安卓的充电接口（type-c）跟苹果（lightning）的不一样，所以就需要一个适配器，将安卓的type-c接口转换成苹果的lightning接口，这样就能用苹果的充电线给安卓充电了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-44cc41182016b5e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Adapter.jpg"></p><p>图中玫瑰金色的就是适配器。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><strong>目标（Target）</strong>：即期望的接口。</li><li><strong>适配器（Adapter）</strong>：用于将源接口转换成目标接口。</li><li><strong>被适配者（Adaptee）</strong>：即源接口。</li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1752522-ebc5c6a53ad679d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="适配器模式类图.png"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppleLightning appleLighting = <span class="keyword">new</span> AppleLightning();</span><br><span class="line">        System.out.println(<span class="string">"use lightning to charge"</span>);</span><br><span class="line">        appleLighting.chargeWithLightning();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">'\n'</span> + <span class="string">"use type-c to charge"</span>);</span><br><span class="line">        AndroidTypeC androidTypeC = <span class="keyword">new</span> AndroidTypeC();</span><br><span class="line">        androidTypeC.chargeWithTypeC();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">'\n'</span> + <span class="string">"use lightning to charge"</span>);</span><br><span class="line">        Lightning adapter = <span class="keyword">new</span> Adapter(androidTypeC);</span><br><span class="line">        adapter.chargeWithLightning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppleLightning</span> <span class="keyword">implements</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"charging iPhone..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidTypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithTypeC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"charging android..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Lightning</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> AndroidTypeC androidTypeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(AndroidTypeC androidTypeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.androidTypeC = androidTypeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        androidTypeC.chargeWithTypeC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use lightning to charge</span><br><span class="line">charging iPhone...</span><br><span class="line"></span><br><span class="line">use type-c to charge</span><br><span class="line">charging android...</span><br><span class="line"></span><br><span class="line">use lightning to charge</span><br><span class="line">charging android...</span><br></pre></td></tr></table></figure><p>注：以上的例子是对象适配器模式，还有另一种适配器模式叫类适配器模式，这里不再赘述。</p><h2 id="适配器模式在Hadoop源码中的应用"><a href="#适配器模式在Hadoop源码中的应用" class="headerlink" title="适配器模式在Hadoop源码中的应用"></a>适配器模式在Hadoop源码中的应用</h2><p>Hadoop作为广泛应用的大数据组件，其本质是一个分布式系统，在分布式系统中，各个节点之间的通信和交互是必不可少的，为此，Hadoop实现了一套自己的RPC框架，该RPC框架默认使用Protocol Buffer作为序列化工具。</p><p>ClientProtocol协议定义了HDFS Client和NameNode交互的所有方法，但是ClientProtocol协议中方法的参数是无法在网络中传输的，需要对参数进行序列化操作，所以HDFS又定义了ClientNamenodeProtocolPB协议，该协议包含了ClientProtocol定义的所有方法，但是参数却是使用protobuf序列化后的格式。</p><p>ClientNamenodeProtocolTranslatorPB类作为Client侧的<strong>适配器</strong>类，<strong>实现</strong>了ClientProtocol接口，它<strong>内部拥有</strong>一个实现了ClientNamenodeProtocolPB接口的对象，可以将ClientProtocol调用适配成ClientNamenodeProtocolPB调用。以rename()调用为例，ClientNamenodeProtocolPB将rename(String, String)调用中的两个String参数序列化成一个RenameRequestProto对象，然后调用ClientNamenodeProtocolPB对象的rename(RenameRequestProto)方法，这样就完成了ClientProtocol接口到ClientNamenodeProtocolPB接口的适配。</p><p>在该例子中，ClientNamenodeProtocolTranslatorPB类为<strong>适配器</strong>，ClientProtocol为<strong>目标接口</strong>（这里的目标是对客户端来说的），ClientNamenodeProtocolPB为<strong>源接口</strong>。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍适配器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://linbingdong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://linbingdong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系列文章——Paxos算法原理与推导</title>
    <link href="http://linbingdong.com/2017/04/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E2%80%94%E2%80%94Paxos%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A8%E5%AF%BC/"/>
    <id>http://linbingdong.com/2017/04/17/分布式系列文章——Paxos算法原理与推导/</id>
    <published>2017-04-16T16:00:00.000Z</published>
    <updated>2017-09-03T02:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。</p><p>网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文《Paxos Made Simple》，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。</p><a id="more"></a><h2 id="Paxos是什么"><a href="#Paxos是什么" class="headerlink" title="Paxos是什么"></a>Paxos是什么</h2><blockquote><p>Paxos算法是基于<strong>消息传递</strong>且具有<strong>高度容错特性</strong>的<strong>一致性算法</strong>，是目前公认的解决<strong>分布式一致性</strong>问题<strong>最有效</strong>的算法之一。</p></blockquote><p>Google Chubby的作者Mike Burrows说过这个世界上<strong>只有一种</strong>一致性算法，那就是Paxos，其它的算法都是<strong>残次品</strong>。</p><p>虽然Mike Burrows说得有点夸张，但是至少说明了Paxos算法的地位。然而，Paxos算法也因为晦涩难懂而臭名昭著。本文的目的就是带领大家深入浅出理解Paxos算法，不仅理解它的执行流程，还要理解算法的推导过程，作者是怎么一步步想到最终的方案的。只有理解了推导过程，才能深刻掌握该算法的精髓。而且理解推导过程对于我们的思维也是非常有帮助的，可能会给我们带来一些解决问题的思路，对我们有所启发。</p><h2 id="问题产生的背景"><a href="#问题产生的背景" class="headerlink" title="问题产生的背景"></a>问题产生的背景</h2><p>在常见的分布式系统中，总会发生诸如<strong>机器宕机</strong>或<strong>网络异常</strong>（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对<strong>某个数据的值</strong>达成<strong>一致</strong>，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p><p>注：这里<strong>某个数据的值</strong>并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令（command）。。。根据应用场景不同，<strong>某个数据的值</strong>有不同的含义。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-d2136179b456e13e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题产生的背景"></p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在Paxos算法中，有三种角色：</p><ul><li><strong>Proposer</strong></li><li><strong>Acceptor</strong></li><li><strong>Learners</strong></li></ul><p>在具体的实现中，一个进程可能<strong>同时充当多种角色</strong>。比如一个进程可能<strong>既是Proposer又是Acceptor又是Learner</strong>。</p><p>还有一个很重要的概念叫<strong>提案（Proposal）</strong>。最终要达成一致的value就在提案里。</p><p><strong>注：</strong></p><ul><li><strong>暂且</strong>认为『<strong>提案=value</strong>』，即提案只包含value。在我们接下来的推导过程中会发现如果提案只包含value，会有问题，于是我们再对提案<strong>重新设计</strong>。</li><li><strong>暂且</strong>认为『<strong>Proposer可以直接提出提案</strong>』。在我们接下来的推导过程中会发现如果Proposer直接提出提案会有问题，需要增加一个学习提案的过程。</li></ul><p>Proposer可以提出（propose）提案；Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了。</p><p>回到刚刚说的『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）。那么，Proposer、Acceptor、Learner分别在什么情况下才能认为某个value被选定呢？</p><ul><li>Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了。</li><li>Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了。</li><li>Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6980ffa6b43c16d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="相关概念"></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有一组可以<strong>提出（propose）value</strong>（value在提案Proposal里）的<strong>进程集合</strong>。一个一致性算法需要保证提出的这么多value中，<strong>只有一个</strong>value被选定（chosen）。如果没有value被提出，就不应该有value被选定。如果一个value被选定，那么所有进程都应该能<strong>学习（learn）</strong>到这个被选定的value。对于一致性算法，<strong>安全性（safaty）</strong>要求如下：</p><ul><li>只有被提出的value才能被选定。</li><li>只有一个value被选定，并且</li><li>如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个。</li></ul><p>我们不去精确地定义其<strong>活性（liveness）</strong>要求。我们的目标是保证<strong>最终有一个提出的value被选定</strong>。当一个value被选定后，进程最终也能学习到这个value。</p><blockquote><p>Paxos的目标：保证最终有一个value会被选定，当value被选定后，进程最终也能获取到被选定的value。</p></blockquote><p>假设不同角色之间可以通过发送消息来进行通信，那么：</p><ul><li>每个角色以任意的速度执行，可能因出错而停止，也可能会重启。一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。</li><li>消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失。但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）。</li></ul><h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><h3 id="最简单的方案——只有一个Acceptor"><a href="#最简单的方案——只有一个Acceptor" class="headerlink" title="最简单的方案——只有一个Acceptor"></a>最简单的方案——只有一个Acceptor</h3><p>假设只有一个Acceptor（可以有多个Proposer），只要Acceptor接受它收到的第一个提案，则该提案被选定，该提案里的value就是被选定的value。这样就保证只有一个value会被选定。</p><p>但是，如果这个唯一的Acceptor宕机了，那么整个系统就<strong>无法工作</strong>了！</p><p>因此，必须要有<strong>多个Acceptor</strong>！</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a902b09159405eab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只有一个Acceptor"></p><h3 id="多个Acceptor"><a href="#多个Acceptor" class="headerlink" title="多个Acceptor"></a>多个Acceptor</h3><p>多个Acceptor的情况如下图。那么，如何保证在多个Proposer和多个Acceptor的情况下选定一个value呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a85c9965be9d1671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多个Acceptor"></p><p>下面开始寻找解决方案。</p><p>如果我们希望即使只有一个Proposer提出了一个value，该value也最终被选定。</p><p>那么，就得到下面的约束：</p><blockquote><p>P1：一个Acceptor必须接受它收到的第一个提案。</p></blockquote><p>但是，这又会引出另一个问题：如果每个Proposer分别提出不同的value，发给不同的Acceptor。根据P1，Acceptor分别接受自己收到的value，就导致不同的value被选定。出现了不一致。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a2449c74a784bd87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片08.png"></p><p>刚刚是因为『一个提案只要被一个Acceptor接受，则该提案的value就被选定了』才导致了出现上面不一致的问题。因此，我们需要加一个规定：</p><blockquote><p>规定：一个提案被选定需要被<strong>半数以上</strong>的Acceptor接受</p></blockquote><p>这个规定又暗示了：『一个Acceptor必须能够接受不止一个提案！』不然可能导致最终没有value被选定。比如上图的情况。v1、v2、v3都没有被选定，因为它们都只被一个Acceptor的接受。</p><p>最开始讲的『<strong>提案=value</strong>』已经不能满足需求了，于是重新设计提案，给每个提案加上一个提案编号，表示提案被提出的顺序。令『<strong>提案=提案编号+value</strong>』。</p><p>虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值。否则又会出现不一致。</p><p>于是有了下面的约束：</p><blockquote><p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p></blockquote><p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p><blockquote><p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p></blockquote><p>只要满足了P2a，就能满足P2。</p><p>但是，考虑如下的情况：假设总的有5个Acceptor。Proposer2提出[M1,V1]的提案，Acceptor2<del>5（半数以上）均接受了该提案，于是对于Acceptor2</del>5和Proposer2来讲，它们都认为V1被选定。Acceptor1刚刚从宕机状态恢复过来（之前Acceptor1没有收到过任何提案），此时Proposer1向Acceptor1发送了[M2,V2]的提案（V2≠V1且M2&gt;M1），对于Acceptor1来讲，这是它收到的第一个提案。根据P1（一个Acceptor必须接受它收到的第一个提案。）,Acceptor1必须接受该提案！同时Acceptor1认为V2被选定。这就出现了两个问题：</p><ol><li>Acceptor1认为V2被选定，Acceptor2~5和Proposer2认为V1被选定。出现了不一致。 </li><li>V1被选定了，但是编号更高的被Acceptor1接受的提案[M2,V2]的value为V2，且V2≠V1。这就跟P2a（如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v）矛盾了。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-e517a6fd3d55e2c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片10.png"></p><p>所以我们要对P2a约束进行强化！</p><p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所有我们可以对Proposer提出的提案进行约束。得到P2b：</p><blockquote><p>P2b：如果某个value为v的提案被选定了，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p></blockquote><p>由P2b可以推出P2a进而推出P2。</p><p>那么，如何确保在某个value为v的提案被选定后，Proposer提出的编号更高的提案的value都是v呢？</p><p>只要满足P2c即可：</p><blockquote><p>P2c：对于任意的N和V，如果提案[N, V]被提出，那么存在一个半数以上的Acceptor组成的集合S，满足以下两个条件中的任意一个：</p><ul><li>S中每个Acceptor都没有接受过编号小于N的提案。</li><li>S中Acceptor接受过的最大编号的提案的value为V。</li></ul></blockquote><h3 id="Proposer生成提案"><a href="#Proposer生成提案" class="headerlink" title="Proposer生成提案"></a>Proposer生成提案</h3><p>为了满足P2b，这里有个比较重要的思想：Proposer生成提案之前，应该先去<strong>『学习』</strong>已经被选定或者可能被选定的value，然后以该value作为自己提出的提案的value。如果没有value被选定，Proposer才可以自己决定value的值。这样才能达成一致。这个学习的阶段是通过一个<strong>『Prepare请求』</strong>实现的。</p><p>于是我们得到了如下的<strong>提案生成算法</strong>：</p><ol><li><p>Proposer选择一个<strong>新的提案编号N</strong>，然后向<strong>某个Acceptor集合</strong>（半数以上）发送请求，要求该集合中的每个Acceptor做出如下响应（response）。<br>(a) 向Proposer承诺保证<strong>不再接受</strong>任何编号<strong>小于N的提案</strong>。(b) 如果Acceptor已经接受过提案，那么就向Proposer响应<strong>已经接受过</strong>的编号小于N的<strong>最大编号的提案</strong>。</p><p>我们将该请求称为<strong>编号为N</strong>的<strong>Prepare请求</strong>。</p></li><li><p>如果Proposer收到了<strong>半数以上</strong>的Acceptor的<strong>响应</strong>，那么它就可以生成编号为N，Value为V的<strong>提案[N,V]</strong>。这里的V是所有的响应中<strong>编号最大的提案的Value</strong>。如果所有的响应中<strong>都没有提案</strong>，那 么此时V就可以由Proposer<strong>自己选择</strong>。生成提案后，Proposer将该<strong>提案</strong>发送给<strong>半数以上</strong>的Acceptor集合，并期望这些Acceptor能接受该提案。我们称该请求为<strong>Accept请求</strong>。（注意：此时接受Accept请求的Acceptor集合<strong>不一定</strong>是之前响应Prepare请求的Acceptor集合）</p></li></ol><h3 id="Acceptor接受提案"><a href="#Acceptor接受提案" class="headerlink" title="Acceptor接受提案"></a>Acceptor接受提案</h3><p>Acceptor<strong>可以忽略任何请求</strong>（包括Prepare请求和Accept请求）而不用担心破坏算法的<strong>安全性</strong>。因此，我们这里要讨论的是什么时候Acceptor可以响应一个请求。</p><p>我们对Acceptor接受提案给出如下约束：</p><blockquote><p>P1a：一个Acceptor只要尚<strong>未响应过</strong>任何<strong>编号大于N</strong>的<strong>Prepare请求</strong>，那么他就可以<strong>接受</strong>这个<strong>编号为N的提案</strong>。</p></blockquote><p>如果Acceptor收到一个编号为N的Prepare请求，在此之前它已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。当然，也可以回复一个error，让Proposer尽早知道自己的提案不会被接受。</p><p>因此，一个Acceptor<strong>只需记住</strong>：1. 已接受的编号最大的提案 2. 已响应的请求的最大编号。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-09a81e90de7f722b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小优化"></p><h3 id="Paxos算法描述"><a href="#Paxos算法描述" class="headerlink" title="Paxos算法描述"></a>Paxos算法描述</h3><p>经过上面的推导，我们总结下Paxos算法的流程。</p><p>Paxos算法分为<strong>两个阶段</strong>。具体如下：</p><ul><li><p><strong>阶段一：</strong></p><p>(a) Proposer选择一个<strong>提案编号N</strong>，然后向<strong>半数以上</strong>的Acceptor发送编号为N的<strong>Prepare请求</strong>。</p><p>(b) 如果一个Acceptor收到一个编号为N的Prepare请求，且N<strong>大于</strong>该Acceptor已经<strong>响应过的</strong>所有<strong>Prepare请求</strong>的编号，那么它就会将它已经<strong>接受过的编号最大的提案（如果有的话）</strong>作为响应反馈给Proposer，同时该Acceptor承诺<strong>不再接受</strong>任何<strong>编号小于N的提案</strong>。</p></li><li><p><strong>阶段二：</strong></p><p>(a) 如果Proposer收到<strong>半数以上</strong>Acceptor对其发出的编号为N的Prepare请求的<strong>响应</strong>，那么它就会发送一个针对<strong>[N,V]提案</strong>的<strong>Accept请求</strong>给<strong>半数以上</strong>的Acceptor。注意：V就是收到的<strong>响应</strong>中<strong>编号最大的提案的value</strong>，如果响应中<strong>不包含任何提案</strong>，那么V就由Proposer<strong>自己决定</strong>。</p><p>(b) 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor<strong>没有</strong>对编号<strong>大于N</strong>的<strong>Prepare请求</strong>做出过<strong>响应</strong>，它就<strong>接受该提案</strong>。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-44c5a422f917bfc5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paxos算法流程"></p><h2 id="Learner学习被选定的value"><a href="#Learner学习被选定的value" class="headerlink" title="Learner学习被选定的value"></a>Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-0fab48ed2bdf358a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片17.png"></p><h2 id="如何保证Paxos算法的活性"><a href="#如何保证Paxos算法的活性" class="headerlink" title="如何保证Paxos算法的活性"></a>如何保证Paxos算法的活性</h2><p><img src="http://upload-images.jianshu.io/upload_images/1752522-28b18dd606777074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="幻灯片18.png"></p><p>通过选取<strong>主Proposer</strong>，就可以保证Paxos算法的活性。至此，我们得到一个<strong>既能保证安全性，又能保证活性</strong>的<strong>分布式一致性算法</strong>——<strong>Paxos算法</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>论文《Paxos Made Simple》</li><li>论文《The Part-Time Parliament》</li><li>英文版维基百科的Paxos</li><li>中文版维基百科的Paxos</li><li>书籍《从Paxos到ZooKeeper》</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Paxos算法在分布式领域具有非常重要的地位。但是Paxos算法有两个比较明显的缺点：1.难以理解 2.工程实现更难。&lt;/p&gt;
&lt;p&gt;网上有很多讲解Paxos算法的文章，但是质量参差不齐。看了很多关于Paxos的资料后发现，学习Paxos最好的资料是论文《Paxos Made Simple》，其次是中、英文版维基百科对Paxos的介绍。本文试图带大家一步步揭开Paxos神秘的面纱。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
      <category term="Paxos" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/Paxos/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Paxos" scheme="http://linbingdong.com/tags/Paxos/"/>
    
      <category term="分布式一致性算法" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入理解HashMap</title>
    <link href="http://linbingdong.com/2017/04/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
    <id>http://linbingdong.com/2017/04/16/深入理解HashMap/</id>
    <published>2017-04-16T12:47:53.000Z</published>
    <updated>2017-04-16T12:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.7和JDK1.8中HashMap的实现不尽相同，JDK1.8中做了一些优化，比如当链表多长时转化成红黑树，提高插入和查找的效率；扩容时不再重新哈希。</p><a id="more"></a><p>HashMap的源码比较长，加上注释有2000行左右，会在文末贴出。这里主要以提问题的形式来加深对HashMap的理解，读者可以先独立思考这些问题，再参照我的回答和文末的源码进行学习。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>数组+链表+红黑树  </p><p>数组是一个Node数组，Node是一个Key-Value对，Node实现了Map.Entry&lt;K,V&gt;。链表/红黑树是用来解决hash冲突的。当链表的长度大于8时会转化成红黑树（Node-&gt;TreeNode），提高插入和查询的效率。</p><h3 id="HashMap继承了哪些类，实现了哪些接口"><a href="#HashMap继承了哪些类，实现了哪些接口" class="headerlink" title="HashMap继承了哪些类，实现了哪些接口"></a>HashMap继承了哪些类，实现了哪些接口</h3><p>继承了AbstractMap类，实现了Serializable/Cloneable/Map接口</p><h3 id="如何put和get"><a href="#如何put和get" class="headerlink" title="如何put和get"></a>如何put和get</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ol><li>确定key对应的Node的索引： h = key.hashCode(); hash = h ^ (h &gt;&gt;&gt; 16); index = hash &amp; (length - 1)</li><li>如果第一个Node的key跟该key相等（hash值相同且equals），则返回第一个Node的value。</li><li>如果第一个是TreeNode，则用红黑树的方法进行搜索，找到key相同的返回该Node的value；如果第一个是Node，则按链表逐个搜索，找到key相同的返回该Node的value。</li><li>返回null</li></ol><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><ol><li>如果数组长度为0，先扩容。如果已经是最大容量，则不再扩。</li><li>计算放置的位置（数组下标）。h = key.hashCode(); hash = h ^ h &gt;&gt;&gt; 16; index = hash &amp; (length - 1)</li><li>若该位置为null，则直接将新节点放入该位置</li><li>若该位置不为null，如果第一个节点的key跟要put的key相同（hashCode和equals），直接覆盖value</li><li>否则，判断是否为TreeNode，若是，则直接在红黑树中插入键值对。</li><li>若是链表，判断链表的长度是否大于8，如果大于8则转为红黑树，并在红黑树中插入。否则执行链表中的插入操作。遍历链表时若发现key已经存在则直接覆盖value。</li><li>如果超过阈值，就扩容。</li></ol><h3 id="初始容量和最大容量分别是多少"><a href="#初始容量和最大容量分别是多少" class="headerlink" title="初始容量和最大容量分别是多少"></a>初始容量和最大容量分别是多少</h3><p>默认初始容量为16（1&lt;&lt;4），可以在初始化时自己指定。最大容量为2的30次方（1&lt;&lt;30）,容量一定是2的整数幂</p><h3 id="加载因子（loadFactor）是多少，为什么"><a href="#加载因子（loadFactor）是多少，为什么" class="headerlink" title="加载因子（loadFactor）是多少，为什么"></a>加载因子（loadFactor）是多少，为什么</h3><p>0.75 </p><p>加载因子默认为0.75是对时间和空间的折中。加载因子越大，空间利用率越高，但是产生冲突的概率就越大，会导致put和get效率降低。</p><h3 id="如何确定Node在数组中的位置（如何构造哈希函数）"><a href="#如何确定Node在数组中的位置（如何构造哈希函数）" class="headerlink" title="如何确定Node在数组中的位置（如何构造哈希函数）"></a>如何确定Node在数组中的位置（如何构造哈希函数）</h3><ol><li>通过key.hashCode()获得 h = key.hashCode()，</li><li>将h的高16位和低16位异或。 hash = h ^ (h &gt;&gt;&gt; 16)</li><li>index = hash &amp; (length - 1)  等价于hash % length。前提是length必须为2的整数幂</li></ol><h3 id="如何减少冲突"><a href="#如何减少冲突" class="headerlink" title="如何减少冲突"></a>如何减少冲突</h3><ol><li>合理的加载因子，如果加载因子设置得过大会增加冲突的概率</li><li>合理的hash函数。比如将hashCode的高16位和低16位异或。</li></ol><h3 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h3><p>采用拉链法解决冲突（链表的插入采用头插法）。</p><h3 id="什么时候扩容，如何扩容"><a href="#什么时候扩容，如何扩容" class="headerlink" title="什么时候扩容，如何扩容"></a>什么时候扩容，如何扩容</h3><p>当Node数（size）超过阈值（threshold = 容量*加载因子）时会扩容。扩容为原来的两倍。</p><ol><li>新建一个两倍大的数组</li><li>把旧数组中的Node全部放入新数组。JDK1.7中所有的Node都会重新hash来确定在新数组中的位置，效率很低；但其实扩容为两倍后，新的Node下标要么跟原来相等，要么比原来大length。JDK1.8中就采取后面的方法，效率更高.</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li><p>包含 初始容量和加载因子 两个参数的构造函数<br>如果指定的初始容量大于最大容量，会以最大容量作为初始容量；<br>如果指定的初始容量不是2的整数幂，会找到大于该值的最小的2的整数幂作为初始容量。</p></li><li><p>默认构造函数<br>初始容量为16；加载因子为0.75</p></li><li><p>包含子map的构造函数</p></li></ul><h3 id="为什么数组容量要是2的整数幂"><a href="#为什么数组容量要是2的整数幂" class="headerlink" title="为什么数组容量要是2的整数幂"></a>为什么数组容量要是2的整数幂</h3><ol><li>这样hash % length 可以转化为 hash &amp; (length -1) 位运算效率更高</li><li>保证length - 1二进制表示的最低位为1。 如果最低位为 0 ，则按位与之后一定得到偶数（下标都是偶数），这样浪费了一大半的空间。</li></ol><h3 id="什么情况下HashMap会线程不安全"><a href="#什么情况下HashMap会线程不安全" class="headerlink" title="什么情况下HashMap会线程不安全"></a>什么情况下HashMap会线程不安全</h3><ol><li><p>如线程A和线程B同时put并写入相同的位置。两个线程都会得到该位置当前的头节点。如果A先写入新的头节点，然后B也写入新的头节点，那么B的操作就会覆盖A的操作造成A的写入操作丢失。</p></li><li><p>如多个线程同时put并刚好都达到门限值，然后都进行了resize（扩容）。此时每个线程都会生成一个新的数组并将table指针指向新的数组，结果最终只有最后一个线程的生成的新数组被赋给table变量，其他线程的均会丢失。</p></li></ol><p>HashMap源码（JDK1.8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InvalidObjectException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Static utilities -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">     * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">     * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">     * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">     * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">     * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">     * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">     * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">     * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">     * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">     * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">     * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">     * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">     * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns x's Class if it is of the form "class C implements</span></span><br><span class="line"><span class="comment">     * Comparable&lt;C&gt;", else null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns k.compareTo(x) if x matches kc (k's screened comparable</span></span><br><span class="line"><span class="comment">     * class), else 0.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Public operations -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment">     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment">     * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment">     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment">     * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = m.size();</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">     * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">     * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">     * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">     * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">     * distinguish these two cases.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span></span><br><span class="line"><span class="comment">     * specified key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   key   The key whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span></span><br><span class="line"><span class="comment">     * key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment">     * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment">     * value is replaced.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">     * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment">     * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the mapping for the specified key from this map if present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key key whose mapping is to be removed from the map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes all of the mappings from this map.</span></span><br><span class="line"><span class="comment">     * The map will be empty after this call returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     * specified value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">     *         specified value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                        (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span></span><br><span class="line"><span class="comment">     * the iteration are undefined.  The set supports element removal,</span></span><br><span class="line"><span class="comment">     * which removes the corresponding mapping from the map, via the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the keys contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks;</span><br><span class="line">        <span class="keyword">return</span> (ks = keySet) == <span class="keyword">null</span> ? (keySet = <span class="keyword">new</span> KeySet()) : ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Collection&#125; view of the values contained in this map.</span></span><br><span class="line"><span class="comment">     * The collection is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the collection, and vice-versa.  If the map is</span></span><br><span class="line"><span class="comment">     * modified while an iteration over the collection is in progress</span></span><br><span class="line"><span class="comment">     * (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),</span></span><br><span class="line"><span class="comment">     * the results of the iteration are undefined.  The collection</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span></span><br><span class="line"><span class="comment">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a view of the values contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs;</span><br><span class="line">        <span class="keyword">return</span> (vs = values) == <span class="keyword">null</span> ? (values = <span class="keyword">new</span> Values()) : vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the mappings contained in this map.</span></span><br><span class="line"><span class="comment">     * The set is backed by the map, so changes to the map are</span></span><br><span class="line"><span class="comment">     * reflected in the set, and vice-versa.  If the map is modified</span></span><br><span class="line"><span class="comment">     * while an iteration over the set is in progress (except through</span></span><br><span class="line"><span class="comment">     * the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span></span><br><span class="line"><span class="comment">     * iterator) the results of the iteration are undefined.  The set</span></span><br><span class="line"><span class="comment">     * supports element removal, which removes the corresponding</span></span><br><span class="line"><span class="comment">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a set view of the mappings contained in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overrides of JDK8 Map extension methods</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = mappingFunction.apply(key);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">                   BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">            (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v = value;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Cloning and serialization</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span></span><br><span class="line"><span class="comment">     * values themselves are not cloned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a shallow copy of this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">            (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * serialize it).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serialData</span> The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span></span><br><span class="line"><span class="comment">     *             bucket array) is emitted (int), followed by the</span></span><br><span class="line"><span class="comment">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span></span><br><span class="line"><span class="comment">     *             mappings), followed by the key (Object) and value (Object)</span></span><br><span class="line"><span class="comment">     *             for each key-value mapping.  The key-value mappings are</span></span><br><span class="line"><span class="comment">     *             emitted in no particular order.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitute the &#123;<span class="doctag">@code</span> HashMap&#125; instance from a stream (i.e.,</span></span><br><span class="line"><span class="comment">     * deserialize it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = <span class="keyword">null</span>;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// spliterators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">        <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">        <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">        <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                           <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                           <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">this</span>.map = m;</span><br><span class="line">            <span class="keyword">this</span>.index = origin;</span><br><span class="line">            <span class="keyword">this</span>.fence = fence;</span><br><span class="line">            <span class="keyword">this</span>.est = est;</span><br><span class="line">            <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            getFence(); <span class="comment">// force init</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        K k = current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        V v = current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                         <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">            <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">                <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">                <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hi;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// LinkedHashMap support</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The following package-protected methods are designed to be</span></span><br><span class="line"><span class="comment">     * overridden by LinkedHashMap, but not by any other subclass.</span></span><br><span class="line"><span class="comment">     * Nearly all other internal methods are also package-protected</span></span><br><span class="line"><span class="comment">     * but are declared final, so can be used by LinkedHashMap, view</span></span><br><span class="line"><span class="comment">     * classes, and HashSet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a tree bin node</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        table = <span class="keyword">null</span>;</span><br><span class="line">        entrySet = <span class="keyword">null</span>;</span><br><span class="line">        keySet = <span class="keyword">null</span>;</span><br><span class="line">        values = <span class="keyword">null</span>;</span><br><span class="line">        modCount = <span class="number">0</span>;</span><br><span class="line">        threshold = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">    <span class="comment">// Tree bins</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">     * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">     * linked node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Ensures that the given root is the first node of its bin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                    <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">         * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">         * comparing keys.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls find for root node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tie-breaking utility for ordering insertions when equal</span></span><br><span class="line"><span class="comment">         * hashCodes and non-comparable. We don't require a total</span></span><br><span class="line"><span class="comment">         * order, just a consistent insertion rule to maintain</span></span><br><span class="line"><span class="comment">         * equivalence across rebalancings. Tie-breaking further than</span></span><br><span class="line"><span class="comment">         * necessary simplifies testing a bit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> d;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Forms tree of the nodes linked from this node.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> root of tree</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a list of non-TreeNodes replacing those linked from</span></span><br><span class="line"><span class="comment">         * this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Tree version of putVal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes the given node, that must be present before this call.</span></span><br><span class="line"><span class="comment">         * This is messier than typical red-black deletion code because we</span></span><br><span class="line"><span class="comment">         * cannot swap the contents of an interior node with a leaf</span></span><br><span class="line"><span class="comment">         * successor that is pinned by "next" pointers that are accessible</span></span><br><span class="line"><span class="comment">         * independently during traversal. So instead we swap the tree</span></span><br><span class="line"><span class="comment">         * linkages. If the current tree appears to have too few nodes,</span></span><br><span class="line"><span class="comment">         * the bin is converted back to a plain bin. (The test triggers</span></span><br><span class="line"><span class="comment">         * somewhere between 2 and 6 nodes, depending on tree structure).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = succ;</span><br><span class="line">            <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">                root = root.root();</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ||</span><br><span class="line">                (rl = root.left) == <span class="keyword">null</span> || rl.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">            <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">                    s = sl;</span><br><span class="line">                <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">                    root = s;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = s;</span><br><span class="line">                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                replacement = p;</span><br><span class="line">            <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                        pp.left = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                        pp.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Splits nodes in a tree bin into lower and upper tree bins,</span></span><br><span class="line"><span class="comment">         * or untreeifies if now too small. Called only from resize;</span></span><br><span class="line"><span class="comment">         * see above discussion about split bits and indices.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> map the map</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> tab the table for recording bin heads</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> index the index of the table being split</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bit the bit of hash to split on</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line">        <span class="comment">// Red-black tree methods, all adapted from CLR</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                                    sr.red = <span class="keyword">false</span>;</span><br><span class="line">                                xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                                    <span class="keyword">null</span> : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                                <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                                    sl.red = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Recursive invariant check</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK1.7和JDK1.8中HashMap的实现不尽相同，JDK1.8中做了一些优化，比如当链表多长时转化成红黑树，提高插入和查找的效率；扩容时不再重新哈希。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者模式</title>
    <link href="http://linbingdong.com/2017/04/14/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://linbingdong.com/2017/04/14/生产者消费者模式/</id>
    <published>2017-04-14T08:16:06.000Z</published>
    <updated>2017-04-14T08:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p><a id="more"></a><h2 id="什么是生产者消费者模式"><a href="#什么是生产者消费者模式" class="headerlink" title="什么是生产者消费者模式"></a>什么是生产者消费者模式</h2><p>生产者消费者模式通过一个容器（比如阻塞队列 BlockingQueue ）来解决生产者和消费者的紧耦合问题。生产者和消费者之间不直接通信，而是通过阻塞队列来通信。生产者生产完数据后不用等待消费者处理，而是直接将生产的数据放入阻塞队列；消费者不从生产者那里要数据，而是直接从阻塞队列里取。阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p><p>阻塞队列提供了可阻塞的 put 和 take 方法，以及支持定时的 offer 和 poll 方法。如果队列已经满了，那么 put 方法将阻塞直到有空间可用；如果队列为空，那么 take 方法将会阻塞直到阻塞队列里有元素可用。</p><h2 id="为什么要用生产者消费者模式"><a href="#为什么要用生产者消费者模式" class="headerlink" title="为什么要用生产者消费者模式"></a>为什么要用生产者消费者模式</h2><ol><li>生产者消费者模式可以使生产者类和消费者类解耦，这样能大大简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性。</li><li>生产者消费者模式可以解决生产消费能力不均衡的问题，从而提高整体处理数据的速度。假设不使用生产者消费者模式，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据；有了生产者消费者模式，生产者就可以不用等待消费者了，这样提高了生产者生产数据的效率。</li></ol><h2 id="使用阻塞队列实现生产者消费者模式"><a href="#使用阻塞队列实现生产者消费者模式" class="headerlink" title="使用阻塞队列实现生产者消费者模式"></a>使用阻塞队列实现生产者消费者模式</h2><p>代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(blockingQueue), <span class="string">"Producer"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(blockingQueue), <span class="string">"Consumer"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String product = <span class="string">"Produced by "</span> + Thread.currentThread().getName();</span><br><span class="line">            blockingQueue.put(product);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" produced a product"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = blockingQueue.take();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" cunsumed product "</span>+ product);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Producer0 produced a product</span><br><span class="line">Producer2 produced a product</span><br><span class="line">Producer3 produced a product</span><br><span class="line">Producer1 produced a product</span><br><span class="line">Producer4 produced a product</span><br><span class="line">Producer5 produced a product</span><br><span class="line">Producer6 produced a product</span><br><span class="line">Producer7 produced a product</span><br><span class="line">Producer8 produced a product</span><br><span class="line">Producer9 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer0</span><br><span class="line">Producer11 produced a product</span><br><span class="line">Producer12 produced a product</span><br><span class="line">Producer10 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer1</span><br><span class="line">Consumer0 cunsumed product Produced by Producer2</span><br><span class="line">Producer13 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer3</span><br><span class="line">Consumer1 cunsumed product Produced by Producer5</span><br><span class="line">Producer15 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer4</span><br><span class="line">Producer16 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer6</span><br><span class="line">Producer14 produced a product</span><br><span class="line">Producer18 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer8</span><br><span class="line">Producer17 produced a product</span><br><span class="line">Consumer0 cunsumed product Produced by Producer7</span><br><span class="line">Producer19 produced a product</span><br><span class="line">Consumer1 cunsumed product Produced by Producer9</span><br><span class="line">Consumer0 cunsumed product Produced by Producer10</span><br><span class="line">Consumer1 cunsumed product Produced by Producer11</span><br><span class="line">Consumer0 cunsumed product Produced by Producer12</span><br><span class="line">Consumer1 cunsumed product Produced by Producer13</span><br><span class="line">Consumer0 cunsumed product Produced by Producer14</span><br><span class="line">Consumer1 cunsumed product Produced by Producer15</span><br><span class="line">Consumer0 cunsumed product Produced by Producer16</span><br><span class="line">Consumer1 cunsumed product Produced by Producer17</span><br><span class="line">Consumer0 cunsumed product Produced by Producer18</span><br><span class="line">Consumer1 cunsumed product Produced by Producer19</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>程序员必读书单</title>
    <link href="http://linbingdong.com/2017/04/14/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    <id>http://linbingdong.com/2017/04/14/程序员必读书单/</id>
    <published>2017-04-14T08:15:36.000Z</published>
    <updated>2018-04-27T02:46:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://zh.lucida.me/" target="_blank" rel="noopener">Lucida</a>大神这篇文章写得非常详细，<a href="http://zh.lucida.me/blog/developer-reading-list/#cracking_the_coding_interview" target="_blank" rel="noopener">点此查看</a>。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://zh.lucida.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lucida&lt;/a&gt;大神这篇文章写得非常详细，&lt;a href=&quot;http://zh.lucida.me/blog/developer-reading-list/#cracking_the_coding_interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此查看&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资料" scheme="http://linbingdong.com/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
      <category term="好文转载" scheme="http://linbingdong.com/tags/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="必读书单" scheme="http://linbingdong.com/tags/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    
      <category term="学习资料" scheme="http://linbingdong.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>tmpfs</title>
    <link href="http://linbingdong.com/2017/04/11/tmpfs/"/>
    <id>http://linbingdong.com/2017/04/11/tmpfs/</id>
    <published>2017-04-11T06:03:33.000Z</published>
    <updated>2017-04-11T06:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同。和ramdisk一样，tmpfs可以使用内存，但它也可以使用swap分区来存储。而且传统的ramdisk是个块设备，要用mkfs格式化才能使用；而tmpfs是一个文件系统，并不是块设备，不需要格式化。tmpfs是最好的基于内存的文件系统。</p><a id="more"></a><p>用一个简单的mount命令就可以创建tmpfs文件系统：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount tmpfs -t tmpfs /data/test -o size=10g</span><br></pre></td></tr></table></figure><p>将tmpfs挂载到/data/mfs目录后，往/data/mfs写入的内容都会写到内存里。如果需要重新设置分配的内存大小，可以先umount，再重新挂载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /data/mfs</span><br><span class="line">mount tmpfs -t tmpfs /data/test -o size=20g</span><br></pre></td></tr></table></figure><p>也可以在/etc/fstab里设置。</p><p>MooseFS是分布式文件系统，正常情况下文件是写到chunkserver节点的磁盘里。如果想让文件写入内存，可以将tmpfs挂到MooseFS的chunkserver节点的数据目录下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount tmpfs -t tmpfs /data/mfs -o size=50g</span><br></pre></td></tr></table></figure><p>这样以后往MooseFS里写数据就都写到内存里了。</p><p>注意：</p><ol><li>挂载前应该先关闭MooseFS，挂载后再启动MooseFS。没有启动MooseFS的话执行<code>df -h</code>命令会无响应。</li><li>该方法只是用来尝鲜，如果想使用基于内存的分布式文件系统，应该使用类似Alluxio这样的组件。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tmpfs是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同。和ramdisk一样，tmpfs可以使用内存，但它也可以使用swap分区来存储。而且传统的ramdisk是个块设备，要用mkfs格式化才能使用；而tmpfs是一个文件系统，并不是块设备，不需要格式化。tmpfs是最好的基于内存的文件系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://linbingdong.com/categories/Linux/"/>
    
    
      <category term="tmpfs" scheme="http://linbingdong.com/tags/tmpfs/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统(Distributed System)资料大全</title>
    <link href="http://linbingdong.com/2017/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(Distributed%20System)%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8/"/>
    <id>http://linbingdong.com/2017/04/09/分布式系统(Distributed System)资料大全/</id>
    <published>2017-04-09T15:17:43.000Z</published>
    <updated>2017-04-09T15:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统资料大全，enjoy！</p><a id="more"></a><ul><li><a href="http://sydney.edu.au/engineering/it/~gramoli/doc/pubs/OPODIS05.pdf" target="_blank" rel="noopener">《Reconfigurable Distributed Storage for Dynamic Networks》</a></li></ul><p>介绍:这是一篇介绍在动态网络里面实现分布式系统重构的paper.论文的作者(导师)是MIT读博的时候是做分布式系统的研究的,现在在NUS带学生,不仅仅是<a href="http://www.comp.nus.edu.sg/~gilbert/biblio-projects.html#rambo" target="_blank" rel="noopener">分布式系统</a>,还有无线网络.如果感兴趣可以去他的主页了解.</p><ul><li><a href="http://lpd.epfl.ch/site" target="_blank" rel="noopener">《Distributed porgramming liboratory》</a></li></ul><p>介绍:分布式编程实验室,他们发表的很多的<a href="http://lpd.epfl.ch/site/Publications" target="_blank" rel="noopener">paper</a>,其中不仅仅是学术研究,还有一些工业界应用的论文.</p><ul><li><a href="http://groups.csail.mit.edu/tds/" target="_blank" rel="noopener">《MIT Theory of Distributed Systems》</a></li></ul><p>介绍:麻省理工的分布式系统理论主页,作者南希·林奇在2002年证明了<a href="http://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">CAP理论</a>,并且著《分布式算法》一书.</p><ul><li><a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/" target="_blank" rel="noopener">《Notes on Distributed Systems for Young Bloods》</a></li></ul><p>介绍:分布式系统搭建初期的一些建议</p><ul><li><a href="http://dcg.ethz.ch/lectures/podc_allstars/" target="_blank" rel="noopener">《Principles of Distributed Computing》</a></li></ul><p>介绍:分布式计算原理课程</p><ul><li><a href="http://research.google.com/archive/spanner.html" target="_blank" rel="noopener">《Google’s Globally-Distributed Database》</a></li></ul><p>介绍:Google全球分布式数据介绍,<a href="http://dblab.xmu.edu.cn/wp-content/uploads/2012/09/20120925_094508_876.pdf" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://highscalability.com/blog/2015/3/9/the-architecture-of-algolias-distributed-search-network.html" target="_blank" rel="noopener">《The Architecture Of Algolia’s Distributed Search Network》</a></li></ul><p>介绍:Algolia的分布式搜索网络的体系架构介绍</p><ul><li><a href="https://medium.com/@siddontang/build-up-a-high-availability-distributed-key-value-store-b4e02bc46e9e" target="_blank" rel="noopener">《Build up a High Availability Distributed Key-Value Store》</a></li></ul><p>介绍:构建高可用分布式Key-Value存储系统</p><ul><li><a href="https://daniel-j-h.github.io/post/distributed-search-nanomsg-bond/" target="_blank" rel="noopener">《Distributed Search Engine with Nanomsg and Bond》</a></li></ul><p>介绍:Nanomsg和Bond的分布式搜索引擎</p><ul><li><a href="http://tech.gc.com/distributed-processing-with-mongodb-and-mongothon/" target="_blank" rel="noopener">《Distributed Processing With MongoDB And Mongothon》</a></li></ul><p>介绍:使用MongoDB和Mongothon进行分布式处理</p><ul><li><a href="http://muratbuffalo.blogspot.jp/2015/02/salt-combining-acid-and-base-in.html" target="_blank" rel="noopener">《Salt: Combining ACID and BASE in a Distributed Database》</a></li></ul><p>介绍:分布式数据库中把<a href="http://www.sigma.me/2011/06/17/database-ACID-and-BASE.html" target="_blank" rel="noopener">ACID与BASE</a>结合使用.</p><ul><li><a href="http://paxos.systems/" target="_blank" rel="noopener">《Makes it easy to understand Paxos for Distributed Systems》</a></li></ul><p>介绍:理解的Paxos的分布式系统,<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://queue.acm.org/detail.cfm?id=2745385" target="_blank" rel="noopener">《There is No Now Problems with simultaneity in distributed systems》</a></li></ul><p>介绍:There is No Now Problems with simultaneity in distributed systems</p><ul><li><a href="http://www0.cs.ucl.ac.uk/staff/ucacwxe/lectures/ds98-99/" target="_blank" rel="noopener">《Distributed Systems》</a></li></ul><p>介绍:伦敦大学学院分布式系统课程课件.</p><ul><li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="noopener">《Distributed systems for fun and profit》</a></li></ul><p>介绍:分布式系统电子书籍.</p><ul><li><a href="http://www.andrew.cmu.edu/course/95-702/" target="_blank" rel="noopener">《Distributed Systems Spring 2015》</a></li></ul><p>介绍:卡内基梅隆大学春季分布式课程主页</p><ul><li><a href="https://azmuri.files.wordpress.com/2013/09/george-coulouris-distributed-systems-concepts-and-design-5th-edition.pdf" target="_blank" rel="noopener">《Distributed Systems: Concepts and Design (5th Edition)》</a></li></ul><p>介绍: 电子书,分布式系统概念与设计(第五版)</p><ul><li><a href="http://ithelp.ithome.com.tw/profile/share?id=20060041" target="_blank" rel="noopener">《走向分布式》</a></li></ul><p>介绍:这是一位台湾网友 ccshih 的文字，短短的篇幅介绍了分布式系统的若干要点。<a href="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf" target="_blank" rel="noopener">pdf</a></p><ul><li><a href="http://thu-cmu.cs.tsinghua.edu.cn/curriculum/dscourse/index.htm" target="_blank" rel="noopener">《Introduction to Distributed Systems Spring 2013》</a></li></ul><p>介绍:清华大学分布式系统课程主页,里面的schedule栏目有很多宝贵的资源</p><ul><li><a href="http://book.mixu.net/distsys/index.html" target="_blank" rel="noopener">《Distributed systems》</a></li></ul><p>介绍:免费的在线分布式系统书籍</p><ul><li><a href="http://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《Some good resources for learning about distributed computing》</a></li></ul><p>介绍:Quora上面的一篇关于学习分布式计算的资源.</p><ul><li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/es//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">《Spanner: Google’s Globally-Distributed Database》</a></li></ul><p>介绍:这个是第一个全球意义上的分布式数据库，也是Google的作品。其中介绍了很多一致性方面的设计考虑，为了简单的逻辑设计，还采用了原子钟，同样在分布式系统方面具有很强的借鉴意义.</p><ul><li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/zh-CN//archive/chubby-osdi06.pdf" target="_blank" rel="noopener">《The Chubby lock service for loosely-coupled distributed systems》</a></li></ul><p>介绍:Google的统面向松散耦合的分布式系统的锁服务,这篇论文详细介绍了Google的分布式锁实现机制Chubby。Chubby是一个基于文件实现的分布式锁，Google的Bigtable、Mapreduce和Spanner服务都是在这个基础上构建的，所以Chubby实际上是Google分布式事务的基础，具有非常高的参考价值。另外，著名的zookeeper就是基于Chubby的开源实现.推荐<a href="http://malteschwarzkopf.de/research/assets/google-stack.pdf" target="_blank" rel="noopener">The google stack</a>,<a href="https://www.youtube.com/watch?v=PqItueBaiRg" target="_blank" rel="noopener">Youtube:The Chubby lock service for loosely-coupled distributed systems</a></p><ul><li><a href="http://www.sosp2007.org/papers/sosp064-aguilera.pdf" target="_blank" rel="noopener">《Sinfonia: a new paradigm for building scalable distributed systems》</a></li></ul><p>介绍:这篇论文是SOSP2007的Best Paper，阐述了一种构建分布式文件系统的范式方法，个人感觉非常有用。淘宝在构建TFS、OceanBase和Tair这些系统时都充分参考了这篇论文.</p><ul><li><a href="http://lintool.github.io/MapReduceAlgorithms/MapReduce-book-final.pdf" target="_blank" rel="noopener">《Data-Intensive Text Processing with MapReduce》</a></li></ul><p>介绍:Ebook:Data-Intensive Text Processing with MapReduce.</p><ul><li><a href="http://www.utdallas.edu/~bxt043000/Publications/Journal-Papers/DAS/J16_Design_and_Implementation_of_a_Distributed_Query_Processor.pdf" target="_blank" rel="noopener">《Design and Implementation of a Query Processor for a Trusted Distributed Data Base Management System》</a></li></ul><p>介绍:Design and Implementation of a Query Processor for a Trusted Distributed Data Base Management System.</p><ul><li><a href="http://ogsa-dai.sourceforge.net/documentation/ogsadai4.0/ogsadai4.0-gt/DQPPart.html" target="_blank" rel="noopener">《Distributed Query Processing》</a></li></ul><p>介绍:分布式查询入门.</p><ul><li><a href="http://writings.quilt.org/2014/05/12/distributed-systems-and-the-end-of-the-api/" target="_blank" rel="noopener">《Distributed Systems and the End of the API》</a></li></ul><p>介绍:分布式系统和api总结.</p><ul><li><a href="http://www.andrew.cmu.edu/course/15-749/READINGS/required/" target="_blank" rel="noopener">《Distributed Query Reading》</a></li></ul><p>介绍:分布式系统阅读论文，此外还推荐github上面的一个论文列表<a href="http://reiddraper.github.io/distreader/" target="_blank" rel="noopener">The Distributed Reader</a>。</p><ul><li><a href="http://afeinberg.github.io/2011/06/17/replication-atomicity-and-order-in-distributed-systems.html" target="_blank" rel="noopener">《Replication, atomicity and order in distributed systems》</a></li></ul><p>介绍:Replication, atomicity and order in distributed systems</p><ul><li><a href="http://nil.csail.mit.edu/6.824/2015/" target="_blank" rel="noopener">《MIT course:Distributed Systems》</a></li></ul><p>介绍:2015年MIT分布式系统课程主页，这次用Golang作为授课语言。<a href="https://pdos.csail.mit.edu/6.824/" target="_blank" rel="noopener">6.824 Distributed Systems</a>课程主页</p><ul><li><a href="http://book.mixu.net/distsys/" target="_blank" rel="noopener">《Distributed systems for fun and profit》</a></li></ul><p>介绍:免费分布式系统电子书。</p><ul><li><a href="http://ori.scs.stanford.edu/" target="_blank" rel="noopener">《Ori：A Secure Distributed File System》</a></li></ul><p>介绍:斯坦福开源的分布式文件系统。</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36737.pdf" target="_blank" rel="noopener">《Availability in Globally Distributed Storage Systems》</a></li></ul><p>介绍:Google论文：设计一个高可用的全球分布式存储系统。</p><ul><li><a href="http://highscalability.com/blog/2013/5/23/paper-calvin-fast-distributed-transactions-for-partitioned-d.html" target="_blank" rel="noopener">《Calvin: Fast Distributed Transactions For Partitioned Database Systems》</a></li></ul><p>介绍:对于分区数据库的分布式事务处理。</p><ul><li><a href="http://yellerapp.com/posts/2015-02-09-flake-ids.html" target="_blank" rel="noopener">《Distributed Systems Building Block: Flake Ids》</a></li></ul><p>介绍:Distributed Systems Building Block: Flake Ids.</p><ul><li><a href="http://www.hpcs.cs.tsukuba.ac.jp/~tatebe/lecture/h23/dsys/dsd-tutorial.html" target="_blank" rel="noopener">《Introduction to Distributed System Design》</a></li></ul><p>介绍:Google Code University课程，如何设计一个分布式系统。</p><ul><li><a href="http://sheepdog.github.io/sheepdog/" target="_blank" rel="noopener">《Sheepdog: Distributed Storage System for KVM》</a></li></ul><p>介绍:KVM的分布式存储系统.</p><ul><li><a href="http://henryr.github.io/distributed-systems-readings/" target="_blank" rel="noopener">《Readings in Distributed Systems Systems》</a></li></ul><p>介绍:分布式系统课程列表,包括数据库、算法等.</p><ul><li><a href="https://github.com/BaiduPS/tera" target="_blank" rel="noopener">《Tera》</a></li></ul><p>介绍:来自百度的分布式表格系统.</p><ul><li><a href="https://github.com/mixu/distsysbook" target="_blank" rel="noopener">《Distributed systems: for fun and profit》</a></li></ul><p>介绍:分布式系统的在线电子书.</p><ul><li><a href="https://github.com/notgary/distributed-systems-reading-list" target="_blank" rel="noopener">《Distributed Systems Reading List》</a></li></ul><p>介绍:分布式系统资料,此外还推荐<a href="https://github.com/hiremaga/readings" target="_blank" rel="noopener">Various articles about distributed systems</a>.</p><ul><li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener">《Designs, Lessons and Advice from Building Large Distributed Systems》</a></li></ul><p>介绍:Designs, Lessons and Advice from Building Large Distributed Systems.</p><ul><li><a href="http://queue.acm.org/detail.cfm?ref=rss&id=2800697" target="_blank" rel="noopener">《Testing a Distributed System》</a></li></ul><p>介绍:Testing a distributed system can be trying even under the best of circumstances.</p><ul><li><a href="https://research.google.com/archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">《The Google File System》</a></li></ul><p>介绍: 基于普通服务器构建超大规模文件系统的典型案例，主要面向大文件和批处理系统， 设计简单而实用。 GFS是google的重要基础设施， 大数据的基石， 也是Hadoop HDFS的参考对象。 主要技术特点包括： 假设硬件故障是常态（容错能力强）， 64MB大块， 单Master设计，Lease/链式复制， 支持追加写不支持随机写.</p><ul><li><a href="https://research.google.com/archive/bigtable-osdi06.pdf" target="_blank" rel="noopener">《Bigtable: A Distributed Storage System for Structured Data》</a></li></ul><p>介绍:支持PB数据量级的多维非关系型大表， 在google内部应用广泛，大数据的奠基作品之一 ， Hbase就是参考BigTable设计。 Bigtable的主要技术特点包括： 基于GFS实现数据高可靠， 使用非原地更新技术（LSM树）实现数据修改， 通过range分区并实现自动伸缩等.<a href="http://dblab.xmu.edu.cn/wp-content/uploads/2012/05/20120508_172346_207.pdf" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://research.microsoft.com:8082/pubs/66814/tr-2008-25.pdf" target="_blank" rel="noopener">《PacificA: Replication in Log-Based Distributed Storage Systems》</a></li></ul><p>介绍:面向log-based存储的强一致的主从复制协议， 具有较强实用性。 这篇文章系统地讲述了主从复制系统应该考虑的问题， 能加深对主从强一致复制的理解程度。 技术特点： 支持强一致主从复制协议， 允许多种存储实现， 分布式的故障检测/Lease/集群成员管理方法.</p><ul><li><a href="http://sns.cs.princeton.edu/docs/craq-usenix09.pdf" target="_blank" rel="noopener">《Object Storage on CRAQ, High-throughput chain replication for read-mostly workloads》</a></li></ul><p>介绍:分布式存储论文:支持强一直的链式复制方法， 支持从多个副本读取数据,实现<a href="https://github.com/jterrace/craq" target="_blank" rel="noopener">code</a>.</p><ul><li><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener">《Finding a needle in Haystack: Facebook’s photo storage》</a></li></ul><p>介绍:Facebook分布式Blob存储,主要用于存储图片. 主要技术特色:小文件合并成大文件,小文件元数据放在内存因此读写只需一次IO.</p><ul><li><a href="http://www-bcf.usc.edu/~minlanyu/teach/csci599-fall12/papers/11-calder.pdf" target="_blank" rel="noopener">《Windows Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency》</a></li></ul><p>介绍: 微软的分布式存储平台, 除了支持类S3对象存储，还支持表格、队列等数据模型. 主要技术特点：采用Stream/Partition两层设计（类似BigTable）;写错（写满）就封存Extent,使得副本字节一致, 简化了选主和恢复操作; 将S3对象存储、表格、队列、块设备等融入到统一的底层存储架构中.</p><ul><li><a href="http://www.eecs.harvard.edu/cs262/Readings/paxosmadelive.pdf" target="_blank" rel="noopener">《Paxos Made Live – An Engineering Perspective》</a></li></ul><p>介绍:从工程实现角度说明了Paxo在chubby系统的应用， 是理解Paxo协议及其应用场景的必备论文。 主要技术特点： paxo协议， replicated log， multi-paxo.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">《Dynamo: Amazon’s Highly Available Key-Value Store》</a></li></ul><p>介绍:Amazon设计的高可用的kv系统,主要技术特点：综和运用一致性哈希,vector clock,最终一致性构建一个高可用的kv系统， 可应用于amazon购物车场景.新内容来自<a href="http://50vip.com/423.html" target="_blank" rel="noopener">分布式存储必读论文</a></p><ul><li><a href="http://oceanstore.cs.berkeley.edu/publications/papers/pdf/carbonite06.pdf" target="_blank" rel="noopener">《Efficient Replica Maintenance for Distributed Storage Systems》</a></li></ul><p>介绍:分布式存储系统中的副本存储问题.</p><ul><li><a href="https://www.cs.nyu.edu/rgrimm/papers/nsdi09.pdf" target="_blank" rel="noopener">《PADS: A Policy Architecture for Distributed Storage Systems》</a></li></ul><p>介绍:分布式存储系统架构.</p><ul><li><a href="http://ccl.cse.nd.edu/software/chirp/" target="_blank" rel="noopener">《The Chirp Distributed Filesystem》</a></li></ul><p>介绍:开源分布式文件系统Chirp,对于想深入研究的开发者可以阅读文章的相关Papers.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf" target="_blank" rel="noopener">《Time, Clocks, and the Ordering of Events in a Distributed System》</a></li></ul><p>介绍:经典论文分布式时钟顺序的实现原理.</p><ul><li><a href="http://www.erlang.org/download/armstrong_thesis_2003.pdf" target="_blank" rel="noopener">《Making reliable distributed systems in the presence of sodware errors》</a></li></ul><p>介绍:面向软件错误构建可靠的分布式系统,<a href="http://www.cnblogs.com/me-sa/archive/2012/05/20/2510564.html" target="_blank" rel="noopener">中文笔记</a>.</p><ul><li><a href="https://research.google.com/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">《MapReduce: Simplified Data Processing on Large Clusters》</a></li></ul><p>介绍:MapReduce:超大集群的简单数据处理.</p><ul><li><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-824-distributed-computer-systems-engineering-spring-2006/index.htm" target="_blank" rel="noopener">《Distributed Computer Systems Engineering》</a></li></ul><p>介绍:麻省理工的分布式计算课程主页,里面的ppt和阅读列表很多干货.</p><ul><li><a href="http://www.vitanuova.com/inferno/papers/styx.html" target="_blank" rel="noopener">《The Styx Architecture for Distributed Systems》</a></li></ul><p>介绍:分布式系统Styx的架构剖析.</p><ul><li><a href="https://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《What are some good resources for learning about distributed computing? Why?》</a></li></ul><p>介绍:Quora上面的一个问答:有哪些关于分布式计算学习的好资源.</p><ul><li><a href="http://highscalability.com/blog/2015/7/8/reborndb-the-next-generation-distributed-key-value-store.html" target="_blank" rel="noopener">《RebornDB: The Next Generation Distributed Key-Value Store》</a></li></ul><p>介绍:下一代分布式k-v存储数据库.</p><ul><li><a href="http://codex.cs.yale.edu/avi/os-book/OS9/" target="_blank" rel="noopener">《Operating System Concepts Ninth Edition》</a></li></ul><p>介绍:分布式系统归根结底还是需要操作系统的知识,这是耶鲁大学的操作系统概念书籍首页,里面有提供了第8版的在线电子版和最新的学习操作系统指南,学习分布式最好先学习操作系统.</p><ul><li><a href="http://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="noopener">《The Log: What every software engineer should know about real-time data’s unifying abstraction》</a></li></ul><p>介绍:分布式系统Log剖析,非常的详细与精彩. <a href="https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md" target="_blank" rel="noopener">中文翻译</a> |  <a href="http://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html" target="_blank" rel="noopener">中文版笔记</a>.</p><ul><li><a href="http://faculty.salina.k-state.edu/tim/ossg/index.html" target="_blank" rel="noopener">《Operating Systems Study Guide》</a></li></ul><p>介绍:分布式系统基础之操作系统学习指南.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/709717672011330101333271/" target="_blank" rel="noopener">《分布式系统领域经典论文翻译集》</a></li></ul><p>介绍:分布式系统领域经典论文翻译集.</p><ul><li><a href="https://speakerdeck.com/elasticsearch/maintaining-performance-in-distributed-systems" target="_blank" rel="noopener">《Maintaining performance in distributed systems》</a></li></ul><p>介绍:分布式系统性能维护.</p><ul><li><a href="http://www.bottomupcs.com/" target="_blank" rel="noopener">《Computer Science from the Bottom Up》</a></li></ul><p>介绍:计算机科学，自底向上,小到机器码,大到操作系统内部体系架构,学习操作系统的另一个在线好材料.</p><ul><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">《Operating Systems: Three Easy Pieces》</a></li></ul><p>介绍:&lt;操作系统:三部曲&gt;在线电子书,虚拟、并发、持续.</p><ul><li><a href="http://www.cs286.net/home/reading-list" target="_blank" rel="noopener">《Database Systems: reading list》</a></li></ul><p>介绍:数据库系统经典论文阅读列,此外推送github上面的<a href="https://github.com/rxin/db-readings" target="_blank" rel="noopener">db reading</a>.</p><ul><li><a href="http://www.washington.edu/R870/" target="_blank" rel="noopener">《Unix System Administration》</a></li></ul><p>介绍:Unix System Administration ebook.</p><ul><li><a href="https://www.cs.vu.nl/~ast/publications/compcom-1991.pdf" target="_blank" rel="noopener">《The Amoeba Distributed Operating System》</a></li></ul><p>介绍:分布式系统经典论文.</p><ul><li><a href="http://web.mit.edu/6.826/archive/S04/" target="_blank" rel="noopener">《Principles of Computer Systems》</a></li></ul><p>介绍:计算机系统概念，以分布式为主.此外推荐<a href="http://www2.cs.uregina.ca/~hamilton/courses/330/notes/index.html" target="_blank" rel="noopener">Introduction to Operating Systems</a>笔记</p><ul><li><a href="http://www.cs.cornell.edu/People/egs/" target="_blank" rel="noopener">《Person page of EMİN GÜN SİRER》</a></li></ul><p>介绍:推荐康奈尔大学的教授EMİN GÜN SİRER的主页,他的研究项目有分布式,数据存储。例如<a href="http://hyperdex.org/papers/" target="_blank" rel="noopener">HyperDex</a>数据库就是他的其中一个项目之一.</p><ul><li><a href="http://www.cs.cmu.edu/afs/cs/project/coda-www/ResearchWebPages/docdir/scalable90.pdf" target="_blank" rel="noopener">《Scalable, Secure, and Highly Available Distributed File Access》</a></li></ul><p>介绍:来自卡内基梅隆如何构建可扩展的、安全、高可用性的分布式文件系统,<a href="http://www.cs.cmu.edu/afs/cs/project/coda-www/ResearchWebPages/docdir/" target="_blank" rel="noopener">其他papers</a>.</p><ul><li><a href="http://dmlc.github.io/" target="_blank" rel="noopener">《Distributed (Deep) Machine Learning Common》</a></li></ul><p>介绍:分布式机器学习常用库.</p><ul><li><a href="http://www.cs.berkeley.edu/~rxin/db-papers/WarehouseScaleComputing.pdf" target="_blank" rel="noopener">《The Datacenter as a Computer》</a></li></ul><p>介绍:介绍了如何构建仓储式数据中心,尤其是对于现在的云计算,分布式学习来说很有帮助.本书是<a href="http://www.morganclaypool.com/toc/cac/1/1" target="_blank" rel="noopener">Synthesis Lectures on Computer Architecture</a>系列的书籍之一,这套丛书还有 《The Memory System》,《Automatic Parallelization》,《Computer Architecture Techniques for Power Efficiency》,《Performance Analysis and Tuning for General Purpose Graphics Processing Units》,《Introduction to Reconfigurable Supercomputing》,<a href="http://www.e-reading.club/bookreader.php/138837/Jacob,_Ng,_Wang_-_Memory_systems._Cache,_DRAM,_Disk.pdf" target="_blank" rel="noopener">Memory Systems Cache, DRAM, Disk</a> 等</p><ul><li><a href="http://www.cs.helsinki.fi/u/jakangas/Teaching/" target="_blank" rel="noopener">《helsinki:Distributed Systems Course slider》</a></li></ul><p>介绍:来自芬兰赫尔辛基的分布式系统课程课件:什么是分布式,复制,一致性,容错,同步,通信.</p><ul><li><a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">《TiDB is a distributed SQL database》</a></li></ul><p>介绍:分布式数据库TiDB,Golang开发.</p><ul><li><a href="http://people.csail.mit.edu/matei/courses/2015/6.S897/" target="_blank" rel="noopener">《S897: Large-Scale Systems》</a></li></ul><p>介绍:课程资料:大规模系统.</p><ul><li><a href="http://papers.nips.cc/paper/5333-consistency-of-weighted-majority-votes" target="_blank" rel="noopener">《Large-scale L-BFGS using MapReduce》</a></li></ul><p>介绍:使用MapReduce进行大规模分布式集群环境下并行L-BFGS.</p><ul><li><a href="http://www.infoq.com/cn/news/2015/09/BookKeeper-Twitter" target="_blank" rel="noopener">《Twitter是如何构建高性能分布式日志的》</a></li></ul><p>介绍:Twitter是如何构建高性能分布式日志的.</p><ul><li><a href="http://danluu.com/limplock/" target="_blank" rel="noopener">《Distributed Systems: When Limping Hardware Is Worse Than Dead Hardware》</a></li></ul><p>介绍:在分布式系统中某个组件彻底死了影响很小，但半死不活（网络/磁盘），对整个系统却是毁灭性的.</p><ul><li><a href="https://github.com/baidu/tera" target="_blank" rel="noopener">《Tera - 高性能、可伸缩的结构化数据库》</a></li></ul><p>介绍:来自百度的分布式数据库.</p><ul><li><a href="https://github.com/SequoiaDB/SequoiaDB" target="_blank" rel="noopener">《SequoiaDB is a distributed document-oriented NoSQL Database》</a></li></ul><p>介绍:SequoiaDB分布式文档数据库开源.</p><ul><li><a href="http://henryr.github.io/distributed-systems-readings/" target="_blank" rel="noopener">《Readings in distributed systems》</a></li></ul><p>介绍:这个网址里收集了一堆各TOP大学分布式相关的课程.</p><ul><li><a href="https://ramcloud.stanford.edu/~ongaro/userstudy/" target="_blank" rel="noopener">《Paxos vs Raft》</a></li></ul><p>介绍:这个网站是<a href="https://raft.github.io/" target="_blank" rel="noopener">Raft算法</a>的作者为教授Paxos和<a href="https://raft.github.io/" target="_blank" rel="noopener">Raft算法</a>做的，其中有两个视频链接，分别讲上述两个算法.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://www.eecs.harvard.edu/~mema/courses/cs264/papers/p13-ratnasamy.pdf" target="_blank" rel="noopener">《A Scalable Content-Addressable Network》</a></li></ul><p>介绍:A Scalable Content-Addressable Network.</p><ul><li><a href="https://github.com/aosabook/500lines" target="_blank" rel="noopener">《500 Lines or Less》</a></li></ul><p>介绍:这个项目其实是一本书（ <a href="http://aosabook.org/en/index.html" target="_blank" rel="noopener">The Architecture of Open Source Applications</a>）的源代码附录，是一堆大牛合写的.</p><ul><li><a href="http://nil.csail.mit.edu/6.824/2015/schedule.html" target="_blank" rel="noopener">《MIT 6.824 Distributed System》</a></li></ul><p>介绍:这只是一个课程主页，没有上课的视频，但是并不影响你跟着它上课：每一周读两篇课程指定的论文，读完之后看lecture-notes里对该论文内容的讨论，回答里面的问题来加深理解，最后在课程lab里把所看的论文实现。当你把这门课的作业刷完后，你会发现自己实现了一个分布式数据库.</p><ul><li><a href="https://github.com/michaelmaltese/golang-distributed-filesystem" target="_blank" rel="noopener">《HDFS-alike in Go》</a></li></ul><p>介绍:使用go开发的分布式文件系统.</p><ul><li><a href="https://www.quora.com/What-are-some-good-resources-for-learning-about-distributed-computing-Why" target="_blank" rel="noopener">《What are some good resources for learning about distributed computing? Why?》</a></li></ul><p>介绍:Quora上关于学习分布式的资源问答.</p><ul><li><a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">《SeaweedFS is a simple and highly scalable distributed file system》</a></li></ul><p>介绍:SeaweedFS是使用go开发的分布式文件系统项目,代码简单，逻辑清晰.</p><ul><li><a href="https://github.com/wandoulabs/codis" target="_blank" rel="noopener">《Codis - yet another fast distributed solution for Redis》</a></li></ul><p>介绍:Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 </p><ul><li><a href="http://www.bailis.org/papers/bailis-thesis.pdf" target="_blank" rel="noopener">《Paper: Coordination Avoidance In Distributed Databases By Peter Bailis》</a></li></ul><p>介绍:Coordination Avoidance In Distributed Databases.</p><ul><li><a href="https://github.com/ngaut/builddatabase" target="_blank" rel="noopener">《从零开始写分布式数据库》</a></li></ul><p>介绍:本文以<a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">TiDB</a> 源码为例.</p><ul><li><a href="http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html" target="_blank" rel="noopener">《what we talk about when we talk about distributed systems》</a></li></ul><p>介绍:分布式系统概念梳理,为分布式系统涉及的主要概念进行了梳理.</p><ul><li><a href="http://redis.io/topics/distlock" target="_blank" rel="noopener">《Distributed locks with Redis》</a></li></ul><p>介绍:使用Redis实现分布式锁.</p><ul><li><a href="http://www.scs.stanford.edu/14au-cs244b/" target="_blank" rel="noopener">《CS244b: Distributed Systems》</a></li></ul><p>介绍: 斯坦福2014年秋季分布式课程.</p><ul><li><a href="http://rustyrazorblade.com/2015/11/ramp-made-easy/" target="_blank" rel="noopener">《RAMP Made Easy》</a></li></ul><p>介绍: 分布式的“读原子性”.</p><ul><li><a href="http://arxiv.org/abs/1512.09295" target="_blank" rel="noopener">《Strategies and Principles of Distributed Machine Learning on Big Data》</a></li></ul><p>介绍: 大数据分布式机器学习的策略与原理.</p><ul><li><a href="https://www.quora.com/Distributed-Systems/What-is-the-CAP-theorem" target="_blank" rel="noopener">《Distributed Systems: What is the CAP theorem?》</a></li></ul><p>介绍: 分布式CAP法则.</p><ul><li><a href="https://www.quora.com/How-should-I-start-to-learn-distributed-storage-system-as-a-beginner" target="_blank" rel="noopener">《How should I start to learn distributed storage system as a beginner?》</a></li></ul><p>介绍: 新手如何步入分布式存储系统.</p><ul><li><a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf" target="_blank" rel="noopener">《Cassandra - A Decentralized Structured Storage System》</a></li></ul><p>介绍: 分布式存储系统Cassandra剖析,推荐白皮书<a href="http://www.datastax.com/wp-content/uploads/2012/08/WP-IntrotoCassandra.pdf" target="_blank" rel="noopener">Introduction to Apache Cassandra</a>.</p><ul><li><a href="https://www.quora.com/What-is-the-best-resource-to-learn-about-distributed-systems" target="_blank" rel="noopener">《What is the best resource to learn about distributed systems?》</a></li></ul><p>介绍: 分布式系统学习资源.</p><ul><li><a href="https://www.quora.com/What-are-some-high-performance-TCP-hacks" target="_blank" rel="noopener">《What are some high performance TCP hacks?》</a></li></ul><p>介绍: 一些高性能TCP黑客技巧.</p><ul><li><a href="https://speakerdeck.com/elasticsearch/maintaining-performance-in-distributed-systems" target="_blank" rel="noopener">《Maintaining performance in distributed systems》</a></li></ul><p>介绍:分布式系统性能提升.</p><ul><li><a href="http://diyhpl.us/~bryan/papers2/distributed/distributed-systems/zab.totally-ordered-broadcast-protocol.2008.pdf" target="_blank" rel="noopener">《A simple totally ordered broadcast protocol》</a></li></ul><p>介绍:Benjamin Reed 和 Flavio P.Junqueira 所著论文,对Zab算法进行了介绍,zab算法是Zookeeper保持数据一致性的核心,在国内有很多公司都使用zookeeper做为分布式的解决方案.推荐与此相关的一篇文章<a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf" target="_blank" rel="noopener">ZooKeeper’s atomic broadcast protocol: Theory and practice</a>.</p><ul><li><a href="http://storageconference.us/2003/papers/29-Rodeh-zFS.pdf" target="_blank" rel="noopener">《zFS - A Scalable Distributed File System Using Object Disk》</a></li></ul><p>介绍:可扩展的分布式文件系统ZFS,<a href="https://users.soe.ucsc.edu/~scott/courses/Fall04/221/zfs_overview.pdf" target="_blank" rel="noopener">The Zettabyte File System</a>,<a href="http://research.cs.wisc.edu/adsl/Publications/zfs-corruption-fast10.pdf" target="_blank" rel="noopener">End-to-end Data Integrity for File Systems: A ZFS Case Study</a>.</p><ul><li><a href="http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html" target="_blank" rel="noopener">《A Distributed Haskell for the Modern Web》</a></li></ul><p>介绍:分布式Haskell在当前web中的应用.</p><ul><li><a href="https://pages.lip6.fr/Marc.Shapiro/papers/CISE-POPL-2016.pdf" target="_blank" rel="noopener">《Reasoning about Consistency Choices in Distributed Systems》</a></li></ul><p>介绍:POPL2016的论文,关于分布式系统一致性选择的论述,<a href="http://conf.researchr.org/track/POPL-2016/POPL-2016-papers#event-overview" target="_blank" rel="noopener">POPL所接受的论文</a>,github上已经有人<a href="https://github.com/gasche/popl2016-papers" target="_blank" rel="noopener">整理</a>.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a></li></ul><p>介绍:Paxos让分布式更简单.<a href="http://dsdoc.net/paxosmadesimple/index.html" target="_blank" rel="noopener">译文</a>.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a>,<a href="https://distributedthoughts.wordpress.com/2013/09/22/understanding-paxos-part-1/" target="_blank" rel="noopener">understanding Paxos part1</a>,<a href="https://distributedthoughts.wordpress.com/2013/09/30/understanding-paxos-part-2/" target="_blank" rel="noopener">Understanding Paxos – Part 2</a>.<a href="https://www.quora.com/Distributed-Systems-What-is-a-simple-explanation-of-the-Paxos-algorithm" target="_blank" rel="noopener">Quora: What is a simple explanation of the Paxos algorithm?</a>,<a href="http://www.ux.uis.no/~meling/papers/2013-paxostutorial-opodis.pdf" target="_blank" rel="noopener">Tutorial Summary: Paxos Explained from Scratch</a>,<a href="http://bogdan.pistol.gg/2014/04/30/paxos-algorithm-explained-part-1-the-essentials/" target="_blank" rel="noopener">Paxos algorithm explained, part 1: The essentials</a>,<a href="http://bogdan.pistol.gg/2014/10/20/paxos-algorithm-explained-part-2-insights/" target="_blank" rel="noopener">Paxos algorithm explained, part 2: Insights</a></p><ul><li><a href="http://the-paper-trail.org/blog/consensus-protocols-paxos/" target="_blank" rel="noopener">《Consensus Protocols: Paxos》</a></li></ul><p>介绍:分布式系统一致性协议:Paxos.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="http://research.microsoft.com/pubs/64636/tr-2003-96.pdf" target="_blank" rel="noopener">《Consensus on Transaction Commit》</a></li></ul><p>介绍：事务提交的一致性探讨.</p><ul><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="noopener">《The Part-Time Parliaments》</a></li></ul><p>介绍:在《The Part-Time Parliament》中描述了基本协议的交互过程。在基本协议的基础上完善各种问题得到了最终的议会协议。 为了让人更容易理解《The Part-Time Parliament》中描述的Paxos算法，Lamport在2001发表了<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a>，以更平直的口头语言描述了Paxos，而没有包含正式的证明和数学术语。<a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">《Paxos Made Simple》</a>中，将算法的参与者更细致的划分成了几个角色：Proposer、Acceptor、Learner。另外还有Leader和Client.<a href="http://duanple.blog.163.com/blog/static/709717672012112203543166/" target="_blank" rel="noopener">参考阅读:关于Paxos的历史</a></p><ul><li><a href="https://pdos.csail.mit.edu/archive/6.824-2007/papers/mazieres-paxos.pdf" target="_blank" rel="noopener">《Paxos Made Practical》</a></li></ul><p>介绍:看这篇论文时可以先看看<a href="http://blog.csdn.net/bluecloudmatrix/article/details/41138363" target="_blank" rel="noopener">理解Paxos Made Practical</a>.</p><ul><li><a href="http://arxiv.org/pdf/1209.4187.pdf" target="_blank" rel="noopener">《PaxosLease: Diskless Paxos for Leases》</a></li></ul><p>介绍：PaxosLease：实现租约的无盘Paxos算法,<a href="http://dsdoc.net/paxoslease/index.html" target="_blank" rel="noopener">译文</a>.</p><ul><li><a href="https://people.csail.mit.edu/matei/courses/2015/6.S897/readings/paxos-moderately-complex.pdf" target="_blank" rel="noopener">《Paxos Made Moderately Complex》</a></li></ul><p>介绍：<a href="http://paxos.systems/" target="_blank" rel="noopener">Paxos算法</a>实现,<a href="http://dsdoc.net/paxosmademoderatelycomplex/index.html" target="_blank" rel="noopener">译文</a>,同时推荐<a href="http://www.cs.cornell.edu/courses/cs7412/2011sp/paxos.pdf" target="_blank" rel="noopener">42 Paxos Made Moderately Complex</a>.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/7097176720119791920962/" target="_blank" rel="noopener">《Hadoop Reading List》</a></li></ul><p>介绍：Hadoop学习清单.</p><ul><li><a href="http://duanple.blog.163.com/blog/static/7097176720119791920962/" target="_blank" rel="noopener">《Hadoop Reading List》</a></li></ul><p>介绍：Hadoop学习清单.</p><ul><li><a href="http://www.empiricalreality.com/2010/09/22/2010-nosql-summer-reading-list/" target="_blank" rel="noopener">《2010 NoSQL Summer Reading List》</a></li></ul><p>介绍：NoSQL知识清单,里面不仅仅包含了数据库阅读清单还包含了分布式系统资料.</p><ul><li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">《Raft: Understandable Distributed Consensus》</a></li></ul><p>介绍：Raft可视化图帮助理解分布式一致性</p><ul><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">《Etcd:Distributed reliable key-value store for the most critical data of a distributed system》</a></li></ul><p>介绍：Etcd分布式Key-Value存储引擎</p><ul><li><a href="http://sysnet.ucsd.edu/recall/papers/iptps.pdf" target="_blank" rel="noopener">《Understanding Availability》</a></li></ul><p>介绍：理解peer-to-peer系统中的可用性究竟是指什么.同时推荐<a href="http://www.jos.org.cn/1000-9825/15/268.pdf" target="_blank" rel="noopener">基于 Peer-to-Peer 的分布式存储系统的设计</a></p><ul><li><a href="http://courses.cs.vt.edu/~cs5204/fall07-kafura/Papers/TransactionalMemory/Lomet.pdf" target="_blank" rel="noopener">《Process structuring, synchronization, and recovery using atomic actions》</a></li></ul><p>介绍：经典论文</p><ul><li><a href="http://www.eng.auburn.edu/files/file1358.pdf" target="_blank" rel="noopener">《Programming Languages for Parallel Processing》</a></li></ul><p>介绍：并行处理的编程语音</p><ul><li><a href="https://hal.inria.fr/hal-00789086/file/a_survey_of_dfs.pdf" target="_blank" rel="noopener">《Analysis of Six Distributed File Systems》</a></li></ul><p>介绍：此篇论文对HDFS,MooseFS,iRODS,Ceph,GlusterFS,Lustre六个存储系统做了详细分析.如果是自己研发对应的存储系统推荐先阅读此篇论文</p><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=A106388C6F04609BCA27DE6DF9C917A6?doi=10.1.1.35.4793&rep=rep1&type=pdf" target="_blank" rel="noopener">《A Survey of Distributed File Systems》</a></li></ul><p>介绍：分布式文件系统综述</p><ul><li><a href="ftp://ftp.sei.cmu.edu/pub/education/cm24.pdf" target="_blank" rel="noopener">《Concepts of Concurrent Programming》</a></li></ul><p>介绍：并行编程的概念,同时推荐<a href="ftp://ftp.sei.cmu.edu/pub/education/" target="_blank" rel="noopener">卡内基梅隆FTP</a></p><ul><li><a href="https://www.cs.berkeley.edu/~brewer/cs262/ConcControl.pdf" target="_blank" rel="noopener">《Concurrency Control Performance Modeling:Alternatives and Implications》</a></li></ul><p>介绍：并发控制性能建模：选择与意义</p><ul><li><a href="https://azmuri.files.wordpress.com/2013/09/george-coulouris-distributed-systems-concepts-and-design-5th-edition.pdf" target="_blank" rel="noopener">《Distributed Systems - Concepts and Design 5th Edition》</a></li></ul><p>介绍：ebook分布式系统概念与设计</p><ul><li><a href="http://read.pudn.com/downloads51/ebook/174460/03.pdf" target="_blank" rel="noopener">《分布式系统设计的形式方法》</a></li></ul><p>介绍：分布式系统设计的形式方法</p><ul><li><a href="http://read.pudn.com/downloads51/ebook/174460/04.pdf" target="_blank" rel="noopener">《互斥和选举算法》</a></li></ul><p>介绍：互斥和选举算法</p><ul><li><a href="https://www.cypherpunks.to/erights/history/actors/AITR-844.pdf" target="_blank" rel="noopener">《Actors：A model Of Concurrent Cornputation In Distributed Systems》</a></li></ul><p>介绍：经典论文</p><ul><li><a href="https://www.cl.cam.ac.uk/~rja14/Papers/" target="_blank" rel="noopener">《Security Engineering: A Guide to Building Dependable Distributed Systems》</a></li></ul><p>介绍：如何构建一个安全可靠的分布式系统,<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-acks.pdf" target="_blank" rel="noopener">About the Author</a>,<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-biblio.pdf" target="_blank" rel="noopener">Bibliography:文献资料</a>,章节访问把<a href="https://www.cl.cam.ac.uk/~rja14/Papers/SEv2-c01.pdf" target="_blank" rel="noopener">链接</a>最后的01换成01-27即可</p><ul><li><a href="https://www.cs.cmu.edu/~15712/index.html" target="_blank" rel="noopener">《15-712 Advanced and Distributed Operating Systems》</a></li></ul><p>介绍：卡内基梅隆大学的分布式系统博士生课程主页,有很丰富的<a href="https://www.cs.cmu.edu/~15712/syllabus.html" target="_blank" rel="noopener">资料</a></p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//archive/papers/dapper-2010-1.pdf" target="_blank" rel="noopener">《Dapper, Google’s Large-Scale Distributed Systems Tracing Infrastructure》</a></li></ul><p>介绍：Dapper，大规模分布式系统的跟踪系统,<a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">译文</a>,<a href="http://dirlt.com/dapper.html" target="_blank" rel="noopener">译文对照</a></p><ul><li><a href="http://www.cs.berkeley.edu/~brewer/cs262/" target="_blank" rel="noopener">《CS262a: Advanced Topics in Computer Systems》</a></li></ul><p>介绍：伯克利大学计算机系统进阶课程,内容有深度,涵盖分布式,数据库等内容</p><ul><li><a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="noopener">《Egnyte Architecture: Lessons Learned In Building And Scaling A Multi Petabyte Distributed System》</a></li></ul><p>介绍：PB级分布式系统构建/扩展经验</p><ul><li><a href="https://cs162.eecs.berkeley.edu/" target="_blank" rel="noopener">《CS162: Operating Systems and Systems Programming》</a></li></ul><p>介绍：伯克利大学计算机系统课程:操作系统与系统编程</p><ul><li><a href="http://mdcc.cs.berkeley.edu/" target="_blank" rel="noopener">《MDCC: Multi-Data Center Consistency》</a></li></ul><p>介绍：MDCC主要解决跨数据中心的一致性问题中间件,一种新的协议</p><ul><li><a href="http://research.google.com/pubs/DistributedSystemsandParallelComputing.html" target="_blank" rel="noopener">《Research at Google:Distributed Systems and Parallel Computing》</a></li></ul><p>介绍：google公开对外发表的分布式系统与并行计算论文</p><ul><li><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html" target="_blank" rel="noopener">《HDFS Architecture Guide》</a></li></ul><p>介绍：分布式文件系统HDFS架构</p><ul><li><a href="http://www.actordb.com/index.html" target="_blank" rel="noopener">《ActorDB distributed SQL database》</a></li></ul><p>介绍：分布式 Key/Value数据库</p><ul><li><a href="http://csc.lsu.edu/~gb/csc7700/Reading/SC03_tang.pdf" target="_blank" rel="noopener">《An efficient data location protocol for self-organizing storage clusters》</a></li></ul><p>介绍：是著名的<a href="https://github.com/ceph/ceph" target="_blank" rel="noopener">Ceph</a>的负载平衡策略，文中提出的几种策略都值得尝试，比较赞的一点是可以对照代码体会和实践,如果你还需要了解可以看看<a href="https://www.ibm.com/developerworks/cn/linux/l-ceph/" target="_blank" rel="noopener">Ceph:一个 Linux PB 级分布式文件系统</a>,除此以外,论文的引用部分也挺值得阅读的,同时推荐<a href="http://ceph.com/papers/weil-ceph-osdi06.pdf" target="_blank" rel="noopener">Ceph: A Scalable, High-Performance Distributed File System</a></p><ul><li><a href="http://www.supercomputing.org/sc2004/schedule/pdfs/pap283.pdf" target="_blank" rel="noopener">《A Self-Organizing Storage Cluster for Parallel Data-Intensive Applications》</a></li></ul><p>介绍：Surrento的冷热平衡策略就采用了延迟写技术</p><ul><li><a href="http://www.sersc.org/journals/IJAST/vol36/4.pdf" target="_blank" rel="noopener">《HBA: Distributed Metadata Management for Large Cluster-Based Storage Systems》</a></li></ul><p>介绍：对于分布式存储系统的元数据管理.</p><ul><li><a href="http://www.mcs.anl.gov/~thakur/papers/sc11-io.pdf" target="_blank" rel="noopener">《Server-Side I/O Coordination for Parallel File Systems》</a></li></ul><p>介绍：服务器端的I/O协调并行文件系统处理,网络,文件存储等都会涉及到IO操作.不过里面涉及到很多技巧性的思路在实践时需要斟酌</p><ul><li><a href="http://www.cs.virginia.edu/~zaher/classes/CS656/levy.pdf" target="_blank" rel="noopener">《Distributed File Systems: Concepts and Examples》</a></li></ul><p>介绍：分布式文件系统概念与应用</p><ul><li><a href="http://cseweb.ucsd.edu/classes/wi08/cse221/" target="_blank" rel="noopener">《CSE 221: Graduate Operating Systems》</a></li></ul><p>介绍：加利福尼亚大学的研究生操作系统课程主页，论文很值得阅读</p><ul><li><a href="http://cs.brown.edu/~debrabant/cis570-website/papers/s4.pdf" target="_blank" rel="noopener">《S4: Distributed Stream Computing Platform》</a></li></ul><p>介绍：Yahoo出品的流式计算系统，目前最流行的两大流式计算系统之一（另一个是storm），Yahoo的主要广告计算平台</p><ul><li><a href="https://kowshik.github.io/JPregel/pregel_paper.pdf" target="_blank" rel="noopener">《Pregel: a system for large-scale graph processing》</a></li></ul><p>介绍：Google的大规模图计算系统，相当长一段时间是Google PageRank的主要计算系统，对开源的影响也很大（包括GraphLab和GraphChi）</p><ul><li><a href="http://www.select.cs.cmu.edu/publications/paperdir/uai2010-low-gonzalez-kyrola-bickson-guestrin-hellerstein.pdf" target="_blank" rel="noopener">《GraphLab: A New Framework for Parallel Machine Learning》</a></li></ul><p>介绍：CMU基于图计算的分布式机器学习框架，目前已经成立了专门的商业公司，在分布式机器学习上很有两把刷子，其单机版的GraphChi在百万维度的矩阵分解都只需要2~3分钟；</p><ul><li><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/41344.pdf" target="_blank" rel="noopener">《F1: A Distributed SQL Database That Scales》</a></li></ul><p>介绍：这篇论文是Google 2013年发表的，介绍了F1的架构思路，13年时就开始支撑Google的AdWords业务，另外两篇介绍文章<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/38125.pdf" target="_blank" rel="noopener">F1 - The Fault-Tolerant Distributed RDBMS Supporting Google’s Ad Business </a>.<a href="http://www.leafonsword.org/google-f1/" target="_blank" rel="noopener">Google NewSQL之F1</a></p><ul><li><a href="https://github.com/cockroachdb/cockroach" target="_blank" rel="noopener">《Cockroach DB:A Scalable, Survivable, Strongly-Consistent SQL Database》</a></li></ul><p>介绍：CockroachDB ：一个可伸缩的、跨地域复制的，且支持事务的数据存储,<a href="http://www.infoq.com/cn/news/2014/08/CockroachDB" target="_blank" rel="noopener">InfoQ介绍</a>,<a href="https://www.gitbook.com/book/smazumder05/design-and-architecture-of-cockroachdb/details" target="_blank" rel="noopener">Design and Architecture of CockroachDb</a></p><ul><li><a href="ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF" target="_blank" rel="noopener">《Multi-Paxos: An Implementation and Evaluation》</a></li></ul><p>介绍：Multi-Paxos实现与总结，此外推荐<a href="https://github.com/cocagne/multi-paxos-example" target="_blank" rel="noopener">Paxos/Multi-paxos Algorithm</a>,<a href="https://github.com/cocagne/multi-paxos-example" target="_blank" rel="noopener">Multi-Paxos Example</a>，地址:<a href="ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF" target="_blank" rel="noopener">ftp://ftp.cs.washington.edu/tr/2009/09/UW-CSE-09-09-02.PDF</a></p><ul><li><a href="http://web.stanford.edu/class/cs347/reading/zab.pdf" target="_blank" rel="noopener">《Zab: High-performance broadcast for primary-backup systems》</a></li></ul><p>介绍：一致性协议zab分析</p><ul><li><a href="https://pdos.csail.mit.edu/papers/fdabek-phd-thesis.pdf" target="_blank" rel="noopener">《A Distributed Hash Table》</a></li></ul><p>介绍：分布式哈希算法论文,扩展阅读<a href="https://www.ietf.org/proceedings/65/slides/plenaryt-2.pdf" target="_blank" rel="noopener">Introduction to Distributed Hash Tables</a>,<a href="https://www.cs.cmu.edu/~dga/15-744/S07/lectures/16-dht.pdf" target="_blank" rel="noopener">Distributed Hash Tables</a></p><ul><li><a href="http://www.news.cs.nyu.edu/~jinyang/pub/iptps04.pdf" target="_blank" rel="noopener">《Comparing the performance of distributed hash tables under churn》</a></li></ul><p>介绍：分布式hash表性能的Churn问题</p><ul><li><a href="https://www.comp.nus.edu.sg/~gilbert/pubs/BrewersConjecture-SigAct.pdf" target="_blank" rel="noopener">《Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web》</a></li></ul><p>介绍：分布式系统的CAP问题,推荐<a href="https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf" target="_blank" rel="noopener">Perspectives on the CAP Theorem</a>.对CAP理论的解析文章,<a href="http://www.cs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf" target="_blank" rel="noopener">PODC ppt</a>,<a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">A plain english introduction to CAP Theorem</a>,<a href="http://dbmsmusings.blogspot.kr/2012/10/ieee-computer-issue-on-cap-theorem.html" target="_blank" rel="noopener">IEEE Computer issue on the CAP Theorem</a></p><ul><li><a href="https://www.usenix.org/system/files/conference/fast15/fast15-paper-lee.pdf" target="_blank" rel="noopener">《F2FS: A New File System for Flash Storage》</a></li></ul><p>介绍：闪存存储文件系统F2FS</p><ul><li><a href="http://research.microsoft.com/pubs/81175/BPFS.pdf" target="_blank" rel="noopener">《Better I/O Through Byte-Addressable, Persistent Memory》</a></li></ul><p>介绍：微软发表的关于i/o访问优化论文</p><ul><li><a href="http://www.solarisinternals.com/si/reading/tmpfs.pdf" target="_blank" rel="noopener">《tmpfs: A Virtual Memory File System》</a></li></ul><p>介绍：虚拟内存文件系统tmpfs</p><ul><li><a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/6E1C5B6A1B6EDD9885257A38006B6130/$File/rj10501.pdf" target="_blank" rel="noopener">《BTRFS: The Linux B-tree Filesystem》</a></li></ul><p>介绍：Linux B-tree文件系统.</p><ul><li><a href="https://www.akamai.com/us/en/our-thinking/technical-publications.jsp" target="_blank" rel="noopener">《Akamai technical publication》</a></li></ul><p>介绍：Akamai是全球最大的云计算机平台之一，承载了全球15-30%网络流量,如果你是做CDN或者是云服务,这个里面的论文会给你很有帮助.例如这几天看facebook开源的<a href="https://osquery.io/" target="_blank" rel="noopener">osquery</a>。找到通过db的方式运维,找到<a href="https://www.akamai.com/es/es/multimedia/documents/technical-publication/keeping-track-of-70000-servers-the-akamai-query-system-technical-publication.pdf" target="_blank" rel="noopener">Keeping Track of 70,000+ Servers: The Akamai Query System</a>这篇论文，先看论文领会思想，然后再使用工具osquery实践</p><ul><li><a href="http://dl.acm.org/citation.cfm?id=1394128" target="_blank" rel="noopener">《BASE: An Acid Alternative》</a></li></ul><p>介绍：来自eBay 的解决方案,译文<a href="http://article.yeeyan.org/view/167444/125572" target="_blank" rel="noopener">Base: 一种Acid的替代方案</a>,应用案例参考<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653546976&idx=1&sn=c3fb2338389a41e7ab998c0c21bd3e5d" target="_blank" rel="noopener">保证分布式系统数据一致性的6种方案</a></p><ul><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=CF3CA7E7B62091EB266A1543A6F2D26A?doi=10.1.1.41.7628&rep=rep1&type=pdf" target="_blank" rel="noopener">《A Note on Distributed Computing》</a></li></ul><p>介绍：Jim Waldo和Sam Kendall等人共同撰写了一篇非常有名的论文“分布式计算备忘录”，这篇论文在Reddit上被人推荐为“每个程序员都应当至少读上两篇”的论文。在这篇论文中，作者表示“忽略本地计算与分布式计算之间的区别是一种危险的思想”，特别指出了Emerald、Argus、DCOM以及CORBA的设计问题。作者将这些设计问题归纳为“三个错误的原则”： “对于某个应用来说，无论它的部署环境如何，总有一种单一的、自然的面向对象设计可以符合其需求。” “故障与性能问题与某个应用的组件实现直接相关，在最初的设计中无需考虑这些问题。” “对象的接口与使用对象的上下文无关”.</p><ul><li><a href="https://github.com/papers-we-love/papers-we-love/tree/master/distributed_systems" target="_blank" rel="noopener">《Distributed Systems Papers》</a></li></ul><p>介绍：分布式系统领域经典论文列表.</p><ul><li><a href="https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf" target="_blank" rel="noopener">《Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web》</a></li></ul><p>介绍：Consistent Hashing算法描述.</p><ul><li><a href="http://sigmod2016.org/pods_list.shtml" target="_blank" rel="noopener">《SIGMOD 2016: Accepted Research Papers》</a></li></ul><p>介绍：SIGMOD是世界上最有名的数据库会议之一,最具有权威性,收录论文审核非常严格.2016年的SIGMOD 会议照常进行,上面收录了今年SIGMOD收录的论文,把题目输入google中加上pdf就能找到,很多论文值得阅读,<a href="http://sigmod2015.org/pods_list.shtml" target="_blank" rel="noopener">SIGMOD 2015</a></p><ul><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf" target="_blank" rel="noopener">《Notes on CPSC 465/565: Theory of Distributed Systems》</a></li></ul><p>介绍:耶鲁大学的分布式系统理论课程笔记</p><ul><li><a href="http://listpdf.com/di/distributed-operating-system-doc-pdf.html" target="_blank" rel="noopener">《Distributed Operating System Doc PDF》</a></li></ul><p>介绍:分布式系统文档资源（可下载）</p><ul><li><a href="https://mitpress.mit.edu/sites/default/files/titles/content/9780262693141_sch_0002.pdf" target="_blank" rel="noopener">《Anatomy of a database system》</a></li></ul><p>介绍:数据库系统剖析，这本书是由伯克利大学的<a href="http://db.cs.berkeley.edu/jmh/" target="_blank" rel="noopener">Joseph M. Hellerstein</a>和M. Stonebraker合著的一篇论文.对数据库剖析很有深度.除此以外还有一篇文章<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf" target="_blank" rel="noopener">Architecture of a Database System</a>。数据库系统架构,厦门大学的数据库实验室教授林子雨组织过<a href="http://dblab.xmu.edu.cn/sites/default/files/files/linziyu-Architecture%20of%20a%20Database%20System(Chinese%20Version)-ALL.pdf" target="_blank" rel="noopener">翻译</a></p><ul><li><a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" target="_blank" rel="noopener">《A Relational Model of Data for Large Shared Data Banks》</a></li></ul><p>介绍:数据库关系模型论文</p><ul><li><a href="http://idke.ruc.edu.cn/reading/index.htm" target="_blank" rel="noopener">《RUC Innovative data systems reaserch lab recommand papers》</a></li></ul><p>介绍:中国人民大学数据研究实验室推荐的数据库领域论文</p><ul><li><a href="http://www.cs.utexas.edu/~dahlin/projects/sdims/papers/sdims-sigcomm.pdf" target="_blank" rel="noopener">《A Scalable Distributed Information Management System》</a></li></ul><p>介绍:构建可扩展的分布式信息管理系统</p><ul><li><a href="http://yager.io/Distributed/Distributed.html" target="_blank" rel="noopener">《Distributed Systems in Haskell》</a></li></ul><p>介绍:Haskell中的分布式系统开发</p><ul><li><a href="research.google.com/pubs/archive/43438.pdf">《Large-scale cluster management at Google with Borg》</a></li></ul><p>介绍:Google使用Borg进行大规模集群的管理,<a href="http://people.eecs.berkeley.edu/~istoica/classes/cs294/15/notes/09-borg.pdf" target="_blank" rel="noopener">伯克利大学ppt介绍</a>,<a href="http://my.oschina.net/HardySimpson/blog?search=Borg" target="_blank" rel="noopener">中文版</a></p><ul><li><a href="http://www.yebangyu.org/LockFreeProgrammingPractice.pdf" target="_blank" rel="noopener">《Lock Free Programming Practice》</a></li></ul><p>介绍:并发编程（Concurrency Programming）资料,主要涵盖lock free数据结构实现、内存回收方法、memory model等<a href="http://pan.baidu.com/s/1sleTpgT" target="_blank" rel="noopener">备份链接</a> 密码: xc5j</p><ul><li><a href="http://read.pudn.com/downloads95/ebook/386159/Distributed.Algorithms.pdf" target="_blank" rel="noopener">《Distributed Algorithms Lecture Notes for 6.852》</a></li></ul><p>介绍:Nancy Lynch’s的分布式算法研究生课程讲义</p><ul><li><a href="http://www.jmlr.org/papers/volume10/newman09a/newman09a.pdf" target="_blank" rel="noopener">《Distributed Algorithms for Topic Models》</a></li></ul><p>介绍:分布式算法主题模型.</p><ul><li><a href="https://recsys.acm.org/" target="_blank" rel="noopener">《RecSys - ACM Recommender Systems》</a></li></ul><p>介绍:世界上非常有名的推荐系统会议，我比较推荐接收的<a href="https://recsys.acm.org/recsys16/accepted-contributions" target="_blank" rel="noopener">PAPER</a></p><ul><li><a href="http://www.allthingsdistributed.com/" target="_blank" rel="noopener">《All Things Distributed》</a></li></ul><p>介绍:推荐一个博客,博主是Amazon CTO Werner Vogels,这是一个关注分布式领域的博客.大部分博文是关于在工业界应用.</p><ul><li><a href="https://github.com/hedengcheng/tech" target="_blank" rel="noopener">《programming, database, distributed system resource list》</a></li></ul><p>介绍:这个Git是由阿里(alibaba)的技术专家何登成维护,主要是分布式数据库.</p><ul><li><a href="http://erlang.org/download/armstrong_thesis_2003.pdf" target="_blank" rel="noopener">《Making reliable distributed systems in the presence of sodware errors》</a></li></ul><p>介绍:Erlang的作者<a href="http://joearms.github.io/" target="_blank" rel="noopener">Joe Armstrong</a>撰写的论文，面对软件错误构建可靠的分布式系统.<a href="http://open.qiniudn.com/[Joe-Armstrong][CN]Making-reliable-distributed-systems-in-the-presence-of-software-errors.pdf" target="_blank" rel="noopener">中文译版</a></p><ul><li><a href="https://courses.engr.illinois.edu/cs525/sched.htm" target="_blank" rel="noopener">《CS 525: Advanced Distributed Systems[Spring 2016]》</a></li></ul><p>介绍:伊利诺伊大学的Advanced Distributed Systems 里把各个方向重要papers（updated Spring 2015）列举出来，可以参考一下</p><ul><li><a href="https://users.ics.aalto.fi/suomela/da/da-screen.pdf" target="_blank" rel="noopener">《Distributed Algorithms》</a></li></ul><p>介绍:这是一本分布式算法电子书,作者是<a href="https://users.ics.aalto.fi/suomela/da/" target="_blank" rel="noopener">Jukka Suomela</a>.讲述了多个计算模型,一致性,唯一标示,并发等.</p><ul><li><a href="https://arxiv.org/pdf/1512.00727v2.pdf" target="_blank" rel="noopener">《TinyLFU: A Highly Efficient Cache Admission Policy》</a></li></ul><p>介绍:当时是在阅读<a href="http://blog.gainlo.co/index.php/2016/05/17/design-a-cache-system/" target="_blank" rel="noopener">如何设计一个缓存系统</a>时看到的，然后通过Google找到了这一篇关于缓存策略的论文，它是LFU的改良版,中文<a href="http://chuansong.me/n/2254051" target="_blank" rel="noopener">介绍</a>.如果有兴趣可以看看<a href="https://github.com/dgryski/go-tinylfu" target="_blank" rel="noopener">Golang实现版</a>。结合起来可能会帮助你理解</p><ul><li><a href="https://cs.stanford.edu/~matei/courses/2015/6.S897/" target="_blank" rel="noopener">《6.S897: Large-Scale Systems》</a></li></ul><p>介绍:斯坦福大学给研究生开的分布式系统课程。教师是 spark 作者 matei. 能把这些内容真正理解透，分布式系统的功力就很强了。</p><ul><li><a href="https://www.zhihu.com/question/23645117/answer/124708083" target="_blank" rel="noopener">《学习分布式系统需要怎样的知识？》</a></li></ul><p>介绍:[怎么学系列]学习分布式系统需要怎样的知识？</p><ul><li><a href="http://the-paper-trail.org/blog/distributed-systems-theory-for-the-distributed-systems-engineer/" target="_blank" rel="noopener">《Distributed systems theory for the distributed systems engineer》</a></li></ul><p>介绍:分布式系统工程师的分布式系统理论</p><ul><li><a href="https://dancres.github.io/Pages/" target="_blank" rel="noopener">《A Distributed Systems Reading List》</a></li></ul><p>介绍:分布式系统论文阅读列表,此外推荐威斯康星大学麦迪逊分校计算机系分布式系统学习推荐<a href="http://pages.cs.wisc.edu/~swift/classes/cs739-fa14/wiki/pmwiki.php/Main/ReadingList" target="_blank" rel="noopener">阅读列表</a></p><ul><li><a href="http://dsrg.pdos.csail.mit.edu/papers/" target="_blank" rel="noopener">《Distributed Systems Reading Group》</a></li></ul><p>介绍:麻省理工大学分布式系统小组，他们会把平时阅读到的优秀论文分享出来。虽然有些论文本页已经收录，但是里面的安排表<a href="http://dsrg.pdos.csail.mit.edu/schedule/" target="_blank" rel="noopener">schedule</a>还是挺赞的</p><ul><li><a href="https://github.com/Developer-Y/Scalable-Software-Architecture" target="_blank" rel="noopener">《Scalable Software Architecture》</a></li></ul><p>介绍:分布式系统、可扩展性与系统设计相关报告、论文与网络资源汇总.</p><ul><li><a href="http://barbie.uta.edu/~jli/Resources/MapReduce&Hadoop/" target="_blank" rel="noopener">《MapReduce&amp;Hadoop resource》</a></li></ul><p>介绍:MapReduce&amp;Hadoop相关论文，涉及分布式系统设计，性能分析，实践，优化等多个方面</p><ul><li><a href="https://vowi.fsinf.at/images/b/bc/TU_Wien-Verteilte_Systeme_VO_(G%C3%B6schka)_-_Tannenbaum-distributed_systems_principles_and_paradigms_2nd_edition.pdf" target="_blank" rel="noopener">《Distributed Systems: Principles and Paradigms(second edtion)》</a></li></ul><p>介绍:分布式系统原理与范型第二版,<a href="http://barbie.uta.edu/~jli/Resources/MapReduce&Hadoop/distributed%20systems%20principles%20and%20paradigms%20solution.pdf" target="_blank" rel="noopener">课后解答</a></p><ul><li><a href="http://muratbuffalo.blogspot.jp/2016/11/my-distributed-systems-seminars-reading.html" target="_blank" rel="noopener">《Distributed Systems Seminar’s reading list for Spring 2017》</a></li></ul><p>介绍:分布式系统研讨会论文阅读列表</p><ul><li><a href="https://arxiv.org/abs/1509.05393" target="_blank" rel="noopener">《A Critique of the CAP Theorem》</a></li></ul><p>介绍:这是一篇评论CAP定理的论文，学习CAP很有帮助,推荐阅读评论文章<a href="https://jvns.ca/blog/2016/11/19/a-critique-of-the-cap-theorem/" target="_blank" rel="noopener">“A Critique of the CAP Theorem”</a></p><ul><li><a href="http://olivergierke.de/2016/10/evolving-distributed-systems/" target="_blank" rel="noopener">《Evolving Distributed Systems》</a></li></ul><p>介绍:推荐文章《不断演进的分布式系统》.</p><ul><li><a href="https://news.ycombinator.com/item?id=13311124" target="_blank" rel="noopener">《Ask HN: Recommendations for a book on Distributed Systems?》</a></li></ul><p>介绍:HN上面关于分布式系统相关领域学习的书籍推荐.</p><ul><li><a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="noopener">《SeaweedFS:A simple and highly scalable distributed file system》</a></li></ul><p>介绍:Golang开源项目,分布式文件存储系统SeaweedFS</p><ul><li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/lfs.pdf" target="_blank" rel="noopener">《The Design and Implementation of a Log-Structured File System》</a></li></ul><p>介绍:论文推荐:设计并实现一个日志结构的文件系统.</p><p><strong>原文链接：<a href="https://raw.githubusercontent.com/ty4z2008/Qix/master/ds.md" target="_blank" rel="noopener">https://raw.githubusercontent.com/ty4z2008/Qix/master/ds.md</a></strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式系统资料大全，enjoy！&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://linbingdong.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="资料大全" scheme="http://linbingdong.com/tags/%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch &amp;&amp; CyclicBarrier example</title>
    <link href="http://linbingdong.com/2017/04/05/CountDownLatch%20&amp;&amp;%20CyclicBarrier%20example/"/>
    <id>http://linbingdong.com/2017/04/05/CountDownLatch &amp;&amp; CyclicBarrier example/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2017-09-03T02:16:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>CountDownLatch &amp;&amp; CyclicBarrier example</p><a id="more"></a><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lbd.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        Worker w1 = <span class="keyword">new</span> Worker(<span class="string">"worker1"</span>, latch);</span><br><span class="line">        Worker w2 = <span class="keyword">new</span> Worker(<span class="string">"worker2"</span>, latch);</span><br><span class="line">        Worker w3 = <span class="keyword">new</span> Worker(<span class="string">"worker3"</span>, latch);</span><br><span class="line"></span><br><span class="line">        Boss boss = <span class="keyword">new</span> Boss(latch);</span><br><span class="line"></span><br><span class="line">        executor.execute(w1);</span><br><span class="line">        executor.execute(w2);</span><br><span class="line">        executor.execute(w3);</span><br><span class="line">        executor.execute(boss);</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch downLatch;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, CountDownLatch downLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" is working..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" is done!"</span>);</span><br><span class="line">        downLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch downLatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(CountDownLatch downLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downLatch = downLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"boss is waiting for all workers..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            downLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"all work is done! Boss gonna check"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">worker1 is working...</span><br><span class="line">worker2 is working...</span><br><span class="line">worker3 is working...</span><br><span class="line">boss is waiting <span class="keyword">for</span> all workers...</span><br><span class="line">worker2 is done!</span><br><span class="line">worker3 is done!</span><br><span class="line">worker1 is done!</span><br><span class="line">all work is done! Boss gonna check</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lbd.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lbd.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">        Worker1 w1 = <span class="keyword">new</span> Worker1(<span class="string">"worker1"</span>, barrier);</span><br><span class="line">        Worker1 w2 = <span class="keyword">new</span> Worker1(<span class="string">"worker2"</span>, barrier);</span><br><span class="line">        Worker1 w3 = <span class="keyword">new</span> Worker1(<span class="string">"worker3"</span>, barrier);</span><br><span class="line">        executor.execute(w1);</span><br><span class="line">        executor.execute(w2);</span><br><span class="line">        executor.execute(w3);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker1</span><span class="params">(String name, CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(barrier.getNumberWaiting() + <span class="string">" worker arrived"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" arrived"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"all arrived,star working!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> worker arrived</span><br><span class="line">worker2 arrived</span><br><span class="line"><span class="number">1</span> worker arrived</span><br><span class="line">worker1 arrived</span><br><span class="line"><span class="number">2</span> worker arrived</span><br><span class="line">worker3 arrived</span><br><span class="line">all arrived,star working!</span><br><span class="line">all arrived,star working!</span><br><span class="line">all arrived,star working!</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CountDownLatch &amp;amp;&amp;amp; CyclicBarrier example&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://linbingdong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MooseFS安装配置</title>
    <link href="http://linbingdong.com/2017/03/30/MooseFS%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://linbingdong.com/2017/03/30/MooseFS安装配置/</id>
    <published>2017-03-30T09:32:18.000Z</published>
    <updated>2017-03-30T09:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录 MooseFS 的部署过程。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MooseFS 是一个分布式文件系统，支持挂载的形式。</p><p><strong>主要角色</strong></p><ul><li>master 节点：元数据节点，复制调度和管理元数据。</li><li>metalogger 节点：用于备份 master 的元数据和日志。</li><li>chunkserver 节点：数据节点，数据实际存放的节点。</li><li>client ：客户端。通过 FUSE 将 mfs 文件系统挂载到客户端后，客户端可以像使用一个普通的磁盘分区一样来使用 mfs 。</li></ul><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><table><thead><tr><th align="center">mfsmaster</th><th align="center">mfsmetalogger</th><th align="center">mfschunkserver</th><th align="center">mfsclient</th></tr></thead><tbody><tr><td align="center">192.168.20.96</td><td align="center">192.168.20.97</td><td align="center">192.168.20.98 192.168.20.99</td><td align="center">192.168.20.96 192.168.20.97 192.168.20.98 192.168.20.99</td></tr></tbody></table><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装fuse模块"><a href="#安装fuse模块" class="headerlink" title="安装fuse模块"></a>安装fuse模块</h3><p>确保需要安装 mfsclient 的节点上已经安装了 Linux 内核模块 FUSE 。</p><p>若未安装，可通过 yum 或者编译安装的方式进行安装。</p><h3 id="创建用户和用户组"><a href="#创建用户和用户组" class="headerlink" title="创建用户和用户组"></a>创建用户和用户组</h3><p>每个节点都要创建 mfs 用户和用户组。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd  mfs</span><br><span class="line">useradd -g mfs mfs</span><br></pre></td></tr></table></figure><h3 id="修改-etc-hosts"><a href="#修改-etc-hosts" class="headerlink" title="修改/etc/hosts"></a>修改/etc/hosts</h3><p>在每个节点上为 mfsmaster 所在节点（192.168.20.96）增加一个别名 mfsmaster 。</p><p>修改 /etc/hosts ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.20.96 mfsmaster</span><br></pre></td></tr></table></figure><h3 id="解压rpm包"><a href="#解压rpm包" class="headerlink" title="解压rpm包"></a>解压rpm包</h3><p>将 mfs.tar.gz 解压到每个节点的 /opt 目录下，解压后会生成 /opt/mfs 目录。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="mfsmaster-cgi"><a href="#mfsmaster-cgi" class="headerlink" title="mfsmaster+cgi"></a>mfsmaster+cgi</h3><p>节点 192.168.20.96</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-master-2.0.77-1.x86_64.rpm moosefs-cgi-2.0.77-1.x86_64.rpm moosefs-cgiserv-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfsmetalogger"><a href="#mfsmetalogger" class="headerlink" title="mfsmetalogger"></a>mfsmetalogger</h3><p>节点 192.168.20.97 </p><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-metalogger-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfschunkserver"><a href="#mfschunkserver" class="headerlink" title="mfschunkserver"></a>mfschunkserver</h3><p>节点 192.168.20.98 、 192.168.20.99 </p><p>创建 /mnt/mfs 目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /mnt/mfs</span><br><span class="line">chown -R mfs:mfs /mnt/mfs</span><br></pre></td></tr></table></figure><p>修改 /etc/mfs/mfshdd.cfg ，在任意位置增加一行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/mnt/mfs</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /opt/mfs</span><br><span class="line">rpm -ivh moosefs-2.0.77-1.x86_64.rpm moosefs-chunkserver-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="mfsclient"><a href="#mfsclient" class="headerlink" title="mfsclient"></a>mfsclient</h3><p>节点 192.168.20.96 、192.168.20.97 、192.168.20.98 、192.168.20.99</p><p>创建 /mnt/mfs-cli 目录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/mfs-cli</span><br><span class="line">chown -R mfs:mfs /mnt/mfs-cli/</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh moosefs-client-2.0.77-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>挂载：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mfsmount /mnt/mfs-cli/ -H mfsmaster</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li>mfsmaster</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-master</span><br></pre></td></tr></table></figure><ul><li>mfscgiserv</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-cgiserv</span><br></pre></td></tr></table></figure><p>启动 mfsmaster 和 mfscgiserv 后，在浏览器中输入 <code>http://192.168.20.96:9425</code> 查看Web 页面 ：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-84150574f17280c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MooseFS WebUI"></p><ul><li>mfsmetalogger</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-metalogger</span><br></pre></td></tr></table></figure><ul><li>mfschunkserver</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start moosefs-chunkserver</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>所有客户端节点 /mnt/mfs-cli 目录下的内容都是相同的。<br>只需把文件放入任意客户端节点的 /mnt/mfs-cli 目录下即可，该目录对所有客户端节点可见。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 MooseFS 的部署过程。&lt;/p&gt;
    
    </summary>
    
      <category term="MooseFS" scheme="http://linbingdong.com/categories/MooseFS/"/>
    
    
      <category term="分布式系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="分布式文件系统" scheme="http://linbingdong.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MooseFS" scheme="http://linbingdong.com/tags/MooseFS/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL安装PostGIS插件并使用</title>
    <link href="http://linbingdong.com/2017/03/25/PostgreSQL%E5%AE%89%E8%A3%85PostGISC%E6%8F%92%E4%BB%B6%E5%B9%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://linbingdong.com/2017/03/25/PostgreSQL安装PostGISC插件并使用/</id>
    <published>2017-03-25T12:15:11.000Z</published>
    <updated>2017-03-25T12:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。</p><a id="more"></a><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。</p><p>PostGIS支持所有的空间数据类型，这些类型包括：点（POINT）、线（LINESTRING）、多边形（POLYGON）、多点 （MULTIPOINT）、多线（MULTILINESTRING）、多多边形（MULTIPOLYGON）和集合对象集 （GEOMETRYCOLLECTION）等。PostGIS支持所有的对象表达方法，比如WKT和WKB。</p><p>PostGIS支持所有的数据存取和构造方法，如GeomFromText()、AsBinary()，以及GeometryN()等。</p><p>PostGIS提供简单的空间分析函数（如Area和Length）同时也提供其他一些具有复杂分析功能的函数，比如Distance。</p><p>PostGIS提供了对于元数据的支持，如GEOMETRY_COLUMNS和SPATIAL_REF_SYS，同时，PostGIS也提供了相应的支持函数，如AddGeometryColumn和DropGeometryColumn。</p><p>PostGIS提供了一系列的二元谓词（如Contains、Within、Overlaps和Touches）用于检测空间对象之间的空间关系，同时返回布尔值来表征对象之间符合这个关系。</p><p>PostGIS提供了空间操作符（如Union和Difference）用于空间数据操作。比如，Union操作符融合多边形之间的边界。两个交迭的多边形通过Union运算就会形成一个新的多边形，这个新的多边形的边界为两个多边形中最大边界。</p><p>PostGIS还提供以下功能：</p><p><strong>数据库坐标变换</strong></p><p>数据库中的几何类型可以通过Transform函数从一种投影系变换到另一种投影系中。在OpenGIS中的几何类型都将SRID作为自身结构的一部分，但不知什么原因，在OpenGIS的SFSQL规范中，并没有引入Transform。</p><p><strong>球体长度运算</strong></p><p>存储在普通地理坐标系中的集合类型如果不进行坐标变换是无法进行程度运算的，OpenGIS所提供的坐标变换使得积累类型的程度计算变成可能。</p><p><strong>三维的几何类型</strong></p><p>SFSQL规范只是针对二维集合类型。OpenGIS提供了对三维集合类型的支持，具体是利用输入的集合类型维数来决定输出的表现方式。例如，即便 所有几何对象内部都以三维形式存储，纯粹的二维交叉点通常还是以二维的形式返回。此外，还提供几何对象在不同维度间转换的功能。</p><p><strong>空间聚集函数</strong></p><p>在数据库中，聚集函数是一个执行某一属性列所有数据操作的函数。比如Sum和Average，Sum是求某一关系属性列的数据总和，Average 则是求取某一关系属性列的数据平均值。与此对应，空间聚集函数也是执行相同的操作，不过操作的对象是空间数据。例如聚集函数Extent返回一系列要素中 的最大的包裹矩形框，如“SELECT EXTENT(GEOM) FROM ROADS”这条SQL语句的执行结果是返回ROADS这个数据表中所有的包裹矩形框。</p><p><strong>栅格数据类型</strong></p><p>PostGIS通过一种新的数据类型片，提供对于大的栅格数据对象的存储。片由以下几个部分组成：包裹矩形框、SRID、类型和一个字节序列。通过 将片的大小控制在数据库页值（32×32）以下，使得快速的随即访问变成可能。一般大的图片也是通过将其切成32×32像素的片然后再存储在数据库中的。</p><h2 id="2-部署"><a href="#2-部署" class="headerlink" title="2. 部署"></a>2. 部署</h2><h3 id="2-1-安装PostGIS"><a href="#2-1-安装PostGIS" class="headerlink" title="2.1 安装PostGIS"></a>2.1 安装PostGIS</h3>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install postgis2_94   # 因为安装的PostgreSQL版本为9.4，所以是postgis2_94</span><br></pre></td></tr></table></figure><p>  <strong>注：</strong><br>  需要PostgreSQL9.1以上版本才支持PostGIS.</p><h3 id="2-2-使PostGIS可用"><a href="#2-2-使PostGIS可用" class="headerlink" title="2.2 使PostGIS可用"></a>2.2 使PostGIS可用</h3><p>想要在PostgreSQL中使用PostGIS插件，安装只是第一步。每个数据库想要使用PostGIS必须先在该数据库中使PostGIS可用。假设我们想在gisdb这个数据库中使用PostGIS,先进入gisdb数据库，执行以下步骤：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# CREATE EXTENSION postgis;</span><br><span class="line">gisdb=# CREATE EXTENSION postgis_topology;</span><br></pre></td></tr></table></figure><h3 id="2-3-查看是否安装成功"><a href="#2-3-查看是否安装成功" class="headerlink" title="2.3 查看是否安装成功"></a>2.3 查看是否安装成功</h3><p>  在gisdb数据库中输入\du，查看已安装的插件</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# \dx</span><br><span class="line">                                               已安装扩展列表</span><br><span class="line">       名称       | 版本  |  架构模式  |                                描述</span><br><span class="line">------------------+-------+------------+---------------------------------------------------------------------</span><br><span class="line"> plpgsql          | 1.0   | pg_catalog | PL/pgSQL procedural language</span><br><span class="line"> postgis          | 2.1.8 | public     | PostGIS geometry, geography, and raster spatial types and functions</span><br><span class="line"> postgis_topology | 2.1.8 | topology   | PostGIS topology spatial types and functions</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>可以看到已经安装了postgis和postgis_topology。</p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><h3 id="3-1-创建空间数据表"><a href="#3-1-创建空间数据表" class="headerlink" title="3.1 创建空间数据表"></a>3.1 创建空间数据表</h3><p>首先建立一个常规的表格存储有关城市（cities）的信息。这个表格有两栏，一个是 ID 编号，一个是城市名：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# CREATE TABLE cities (id int4, name varchar(50));</span><br></pre></td></tr></table></figure><p>现在添加一个空间列用于存储城市的位置。习惯上这个列叫做 the_geom。它记录了数据为什么类型（点、线、面）、有几维（这里是二维）以及空间坐标系统。此处使用 EPSG:4326 坐标系统：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT AddGeometryColumn (&apos;cities&apos;, &apos;the_geom&apos;, 4326, &apos;POINT&apos;, 2);</span><br></pre></td></tr></table></figure><p>完成后，查询 cities 表单应当显示这个新栏目。同时页面将显示当前表达没有记录（0 rows）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# select * from cities;</span><br><span class="line"> id |      name       |                      the_geom</span><br><span class="line">----+-----------------+----------------------------------------------------</span><br><span class="line">（0行记录）</span><br></pre></td></tr></table></figure><p>为添加记录，需要使用 SQL 命令。对于空间列，使用 PostGIS 的 ST_GeomFromText可以将文本转化为坐标与参考系号的记录：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (1,ST_GeomFromText(&apos;POINT(-0.1257 51.508)&apos;,4326),&apos;London, England&apos;);</span><br><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (2,ST_GeomFromText(&apos;POINT(-81.233 42.983)&apos;,4326),&apos;London, Ontario&apos;);</span><br><span class="line">gisdb=# INSERT INTO cities (id, the_geom, name) VALUES (3,ST_GeomFromText(&apos;POINT(27.91162491 -33.01529)&apos;,4326),&apos;East London,SA&apos;);</span><br></pre></td></tr></table></figure><p>当然，这样的输入方式难以操作。其它方式可以更快的输入数据。就目前来说，表格内已经有了一些城市数据，可以先进行查询等操作。</p><h3 id="3-2-简单查询"><a href="#3-2-简单查询" class="headerlink" title="3.2 简单查询"></a>3.2 简单查询</h3><p>标准的 SQL 操作都可以用于 PostGIS 表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT * FROM cities;</span><br><span class="line"> id |      name       |                      the_geom</span><br><span class="line">----+-----------------+----------------------------------------------------</span><br><span class="line">  1 | London, England | 0101000020E6100000BBB88D06F016C0BF1B2FDD2406C14940</span><br><span class="line">  2 | London, Ontario | 0101000020E6100000F4FDD478E94E54C0E7FBA9F1D27D4540</span><br><span class="line">  3 | East London,SA  | 0101000020E610000040AB064060E93B4059FAD005F58140C0</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>这里的坐标是无法阅读的 16 进制格式。要以 WKT 文本显示，使用 ST_AsText(the_geom) 或ST_AsEwkt(the_geom) 函数。也可以使用 ST_X(the_geom) 和 ST_Y(the_geom) 显示一个维度的坐标：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=#  SELECT id, ST_AsText(the_geom), ST_AsEwkt(the_geom), ST_X(the_geom), ST_Y(the_geom) FROM cities;</span><br><span class="line"> id |          st_astext           |               st_asewkt                |    st_x     |   st_y</span><br><span class="line">----+------------------------------+----------------------------------------+-------------+-----------</span><br><span class="line">  1 | POINT(-0.1257 51.508)        | SRID=4326;POINT(-0.1257 51.508)        |     -0.1257 |    51.508</span><br><span class="line">  2 | POINT(-81.233 42.983)        | SRID=4326;POINT(-81.233 42.983)        |     -81.233 |    42.983</span><br><span class="line">  3 | POINT(27.91162491 -33.01529) | SRID=4326;POINT(27.91162491 -33.01529) | 27.91162491 | -33.01529</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><h3 id="3-3-空间查询"><a href="#3-3-空间查询" class="headerlink" title="3.3 空间查询"></a>3.3 空间查询</h3><p>PostGIS 为 PostgreSQL 扩展了许多空间操作功能。以上已经涉及了转换空间坐标格式的 ST_GeomFromText 。多数空间操作以 ST（spatial type）开头，在 PostGIS 文档相应章节有罗列。这里回答一个具体的问题：上面三个城市相互的距离是多少？查询语句怎么写？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gisdb=# SELECT p1.name,p2.name,ST_Distance_Sphere(p1.the_geom,p2.the_geom) FROM cities AS p1, cities AS p2 WHERE p1.id &gt; p2.id;</span><br><span class="line">      name       |      name       | st_distance_sphere</span><br><span class="line">-----------------+-----------------+--------------------</span><br><span class="line"> London, Ontario | London, England |   5875787.03777356</span><br><span class="line"> East London,SA  | London, England |   9789680.59961472</span><br><span class="line"> East London,SA  | London, Ontario |   13892208.6782928</span><br><span class="line">(3 行记录)</span><br></pre></td></tr></table></figure><p>输出显示了距离数据。注意 ‘WHERE’ 部分防止了输出城市到自身的距离（0）或者两个城市不同排列的距离数据（London, England 到 London, Ontario 和 London, Ontario 到 London, England 的距离是一样的）。<br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PostGIS是对象关系型数据库PostgreSQL的一个插件，PostGIS提供如下空间信息服务功能：空间对象、空间索引、空间操作函数和空间操作符。同时，PostGIS遵循OpenGIS的规范。&lt;/p&gt;
    
    </summary>
    
      <category term="PostgreSQL" scheme="http://linbingdong.com/categories/PostgreSQL/"/>
    
    
      <category term="关系数据库" scheme="http://linbingdong.com/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="PostgreSQL" scheme="http://linbingdong.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper原理及其在Hadoop和HBase中的应用</title>
    <link href="http://linbingdong.com/2017/03/23/ZooKeeper%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%9C%A8Hadoop%E5%92%8CHBase%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://linbingdong.com/2017/03/23/ZooKeeper原理及其在Hadoop和HBase中的应用/</id>
    <published>2017-03-23T00:47:28.000Z</published>
    <updated>2017-03-23T00:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，由雅虎创建，是Google <strong>Chubby的开源实现</strong>。分布式应用程序可以基于ZooKeeper实现诸如<strong>数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ZooKeeper是一个开源的<strong>分布式协调服务</strong>，由雅虎创建，是Google <strong>Chubby的开源实现</strong>。分布式应用程序可以基于ZooKeeper实现诸如<strong>数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列</strong>等功能。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>本节将介绍ZooKeeper的几个核心概念。这些概念贯穿于之后对ZooKeeper更深入的讲解，因此有必要预先了解这些概念。</p><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>在ZooKeeper中，有三种角色：</p><ul><li>Leader</li><li>Follower</li><li>Observer</li></ul><p>一个ZooKeeper集群同一时刻只会有一个Leader，其他都是Follower或Observer。</p><p>ZooKeeper配置很简单，每个节点的配置文件(zoo.cfg)都是一样的，只有myid文件不一样。myid的值必须是zoo.cfg中server.{数值}的{数值}部分。</p><p>zoo.cfg文件内容示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxClientCnxns=0</span><br><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/var/lib/zookeeper/data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the directory where the transaction logs are stored.</span><br><span class="line">dataLogDir=/var/lib/zookeeper/logs</span><br><span class="line">server.1=192.168.20.101:2888:3888</span><br><span class="line">server.2=192.168.20.102:2888:3888</span><br><span class="line">server.3=192.168.20.103:2888:3888</span><br><span class="line">server.4=192.168.20.104:2888:3888</span><br><span class="line">server.5=192.168.20.105:2888:3888</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=100000</span><br></pre></td></tr></table></figure><p>在装有ZooKeeper的机器的终端执行 <code>zookeeper-server status</code> 可以看当前节点的ZooKeeper是什么角色（Leader or Follower）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node-20-103 ~]# zookeeper-server status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /etc/zookeeper/conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@node-20-104 ~]# zookeeper-server status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /etc/zookeeper/conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure><p>如上，node-20-104是Leader，node-20-103是follower。</p><p>ZooKeeper默认只有Leader和Follower两种角色，没有Observer角色。</p><p>为了使用Observer模式，在任何想变成Observer的节点的配置文件中加入：<code>peerType=observer</code><br>并在所有server的配置文件中，配置成observer模式的server的那行配置追加:observer，例如：<br><code>server.1:localhost:2888:3888:observer</code></p><p>ZooKeeper集群的所有机器通过一个<strong>Leader选举过程</strong>来选定一台被称为<strong>『Leader』</strong>的机器，<strong>Leader服务器</strong>为客户端提供<strong>读</strong>和<strong>写</strong>服务。</p><p>Follower和Observer都<strong>能</strong>提供<strong>读</strong>服务，<strong>不能</strong>提供<strong>写</strong>服务。两者唯一的区别在于，<strong>Observer</strong>机器<strong>不参与Leader选举</strong>过程，也<strong>不参与写操作</strong>的『过半写成功』策略，因此Observer可以在<strong>不影响写性能</strong>的情况下<strong>提升</strong>集群的<strong>读性能</strong>。</p><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>Session是指<strong>客户端会话</strong>，在讲解客户端会话之前，我们先来了解下<strong>客户端连接</strong>。在ZooKeeper中，一个客户端连接是指客户端和ZooKeeper服务器之间的<strong>TCP长连接</strong>。ZooKeeper对外的服务端口默认是<strong>2181</strong>，客户端启动时，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过<strong>心跳检测</strong>和服务器保持有效的会话，也能够向ZooKeeper服务器<strong>发送请求</strong>并<strong>接受响应</strong>，同时还能通过该连接接收来自服务器的<strong>Watch事件通知</strong>。Session的<strong>SessionTimeout</strong>值用来设置一个客户端会话的<strong>超时时间</strong>。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在SessionTimeout规定的时间内能够<strong>重新连接上</strong>集群中<strong>任意一台</strong>服务器，那么之前创建的会话<strong>仍然有效</strong>。</p><h3 id="数据节点（ZNode）"><a href="#数据节点（ZNode）" class="headerlink" title="数据节点（ZNode）"></a>数据节点（ZNode）</h3><p>在谈到分布式的时候，<strong>一般</strong>『节点』指的是组成集群的每一台<strong>机器</strong>。而ZooKeeper中的数据节点是指<strong>数据模型</strong>中的<strong>数据单元</strong>，称为<strong>ZNode</strong>。ZooKeeper将所有数据存储在<strong>内存中</strong>，数据模型是一棵<strong>树（ZNode Tree）</strong>，由斜杠（/）进行分割的路径，就是一个ZNode，如/hbase/master,其中hbase和master<strong>都是</strong>ZNode。每个ZNode上都会保存<strong>自己的数据内容</strong>，同时会保存一系列<strong>属性信息</strong>。</p><p>注：<br>这里的ZNode可以理解成<strong>既是</strong>Unix里的<strong>文件</strong>，<strong>又是</strong>Unix里的<strong>目录</strong>。因为每个ZNode不仅本身可以<strong>写数据</strong>（相当于Unix里的文件），还可以有<strong>下一级文件或目录</strong>（相当于Unix里的目录）。</p><p>在ZooKeeper中，ZNode可以分为<strong>持久节点</strong>和<strong>临时节点</strong>两类。</p><p><strong>持久节点</strong></p><p> 所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</p><p><strong>临时节点</strong></p><p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p><p>另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper就会自动在其节点后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>ZooKeeper的每个ZNode上都会存储数据，对应于每个ZNode，ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）和aversion（当前ZNode的ACL版本）。</p><h3 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h3><p>每个ZNode除了存储数据内容之外，还存储了ZNode本身的一些状态信息。用 get 命令可以同时获得某个ZNode的内容和状态信息。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 23] get /yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</span><br><span class="line"></span><br><span class="line">appcluster-yarnrm1</span><br><span class="line">cZxid = 0x1b00133dc0    //Created ZXID,表示该ZNode被创建时的事务ID</span><br><span class="line">ctime = Tue Jan 03 15:44:42 CST 2017    //Created Time,表示该ZNode被创建的时间</span><br><span class="line">mZxid = 0x1d00000063    //Modified ZXID，表示该ZNode最后一次被更新时的事务ID</span><br><span class="line">mtime = Fri Jan 06 08:44:25 CST 2017    //Modified Time，表示该节点最后一次被更新的时间</span><br><span class="line">pZxid = 0x1b00133dc0    //表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更pZxid，子节点内容变更不会影响pZxid。</span><br><span class="line">cversion = 0    //子节点的版本号</span><br><span class="line">dataVersion = 11    //数据节点的版本号</span><br><span class="line">aclVersion = 0    //ACL版本号</span><br><span class="line">ephemeralOwner = 0x0    //创建该节点的会话的seddionID。如果该节点是持久节点，那么这个属性值为0。</span><br><span class="line">dataLength = 22    //数据内容的长度</span><br><span class="line">numChildren = 0    //子节点的个数</span><br></pre></td></tr></table></figure><p>在ZooKeeper中，version属性是用来实现乐观锁机制中的『写入校验』的（保证分布式数据原子性操作）。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher（事件监听器），是ZooKeeper中一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。该机制是ZooKeeper实现分布式协调服务的重要特性。</p><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>ZooKeeper采用ACL（Access Control Lists）策略来进行权限控制。ZooKeeper定义了如下5种权限。</p><ul><li>CREATE: 创建子节点的权限。</li><li>READ: 获取节点数据和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE: 删除子节点的权限。</li><li>ADMIN: 设置节点ACL的权限。</li></ul><p>注意：CREATE 和 DELETE 都是针对子节点的权限控制。</p><h2 id="ZooKeeper典型应用场景"><a href="#ZooKeeper典型应用场景" class="headerlink" title="ZooKeeper典型应用场景"></a>ZooKeeper典型应用场景</h2><p>ZooKeeper是一个<strong>高可用</strong>的分布式<strong>数据管理与协调框架</strong>。基于对ZAB算法的实现，该框架能够很好地保证分布式环境中数据的<strong>一致性</strong>。也是基于这样的特性，使得ZooKeeper成为了解决分布式一致性问题的利器。</p><h3 id="数据发布与订阅（配置中心）"><a href="#数据发布与订阅（配置中心）" class="headerlink" title="数据发布与订阅（配置中心）"></a>数据发布与订阅（配置中心）</h3><p>数据发布与订阅，即所谓的<strong>配置中心</strong>，顾名思义就是发布者将数据发布到ZooKeeper节点上，供订阅者进行数据订阅，进而达到<strong>动态获取数据</strong>的目的，实现配置信息的<strong>集中式管理</strong>和<strong>动态更新</strong>。</p><p>在我们平常的应用系统开发中，经常会碰到这样的需求：系统中需要使用一些通用的配置信息，例如<strong>机器列表信息</strong>、<strong>数据库配置信息</strong>等。这些全局配置信息通常具备以下3个特性。</p><ul><li>数据量通常比较<strong>小。</strong></li><li>数据内容在运行时<strong>动态变化</strong>。</li><li>集群中各机器共享，<strong>配置一致</strong>。</li></ul><p>对于这样的全局配置信息就可以发布到ZooKeeper上，让客户端（集群的机器）去订阅该消息。</p><p>发布/订阅系统一般有两种设计模式，分别是<strong>推（Push）</strong>和<strong>拉（Pull）</strong>模式。</p><ul><li>推：<strong>服务端主动</strong>将数据更新发送给所有订阅的客户端。</li><li>拉：<strong>客户端主动</strong>发起请求来获取最新数据，通常客户端都采用<strong>定时轮询</strong>拉取的方式。</li></ul><p>ZooKeeper采用的是<strong>推拉相结合</strong>的方式。如下：</p><p>客户端想服务端<strong>注册</strong>自己需要关注的节点，一旦该节点的数据发生<strong>变更</strong>，那么服务端就会向相应的客户端发送Watcher事件<strong>通知</strong>，客户端接收到这个消息通知后，需要<strong>主动</strong>到服务端<strong>获取</strong>最新的数据（<strong>推拉结合</strong>）。</p><h3 id="命名服务-Naming-Service"><a href="#命名服务-Naming-Service" class="headerlink" title="命名服务(Naming Service)"></a>命名服务(Naming Service)</h3><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定<strong>名字</strong>来获取<strong>资源或服务的地址，提供者等信息</strong>。被命名的实体通常可以是<strong>集群中的机器，提供的服务，远程对象等等</strong>——这些我们都可以统称他们为<strong>名字（Name）</strong>。其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在ZooKeepr里创建顺序节点，能够很容易创建一个<strong>全局唯一的路径</strong>，这个路径就可以作为一个<strong>名字</strong>。</p><p>ZooKeeper的命名服务即生成<strong>全局唯一的ID</strong>。</p><h3 id="分布式协调-通知"><a href="#分布式协调-通知" class="headerlink" title="分布式协调/通知"></a>分布式协调/通知</h3><p>ZooKeeper中特有<strong>Watcher注册</strong>与<strong>异步通知机制</strong>，能够很好的实现分布式环境下不同机器，甚至不同系统之间的<strong>通知与协调</strong>，从而实现<strong>对数据变更的实时处理</strong>。使用方法通常是不同的客户端都对ZK上同一个ZNode进行注册，监听ZNode的变化（包括ZNode本身内容及子节点的），如果ZNode发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。</p><p><strong>ZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式</strong>。</p><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以<strong>相互PING通</strong>来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过<strong>TCP连接</strong>固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。</p><p>下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。</p><p>基于ZK的<strong>临时节点</strong>的特性，可以让不同的进程都在ZK的一个<strong>指定节点</strong>下创建<strong>临时子节点</strong>，不同的进程直接可以根据这个临时子节点来判断对应的进程<strong>是否存活</strong>。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大<strong>减少了系统耦合</strong>。</p><h4 id="工作进度汇报"><a href="#工作进度汇报" class="headerlink" title="工作进度汇报"></a>工作进度汇报</h4><p>在一个常见的<strong>任务分发系统</strong>中，通常任务被分发到不同的机器上执行后，需要实时地将自己的任务执行进度<strong>汇报</strong>给分发系统。这个时候就可以通过ZK来实现。在ZK上选择一个节点，每个任务客户端都在这个节点下面创建<strong>临时子节点</strong>，这样便可以实现两个功能：</p><ul><li>通过判断临时节点是否存在来确定任务机器<strong>是否存活</strong>。</li><li>各个任务机器会实时地将自己的<strong>任务执行进度写到这个临时节点上去</strong>，以便中心系统能够实时地获取到任务的<strong>执行进度</strong>。</li></ul><h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p><strong>Master选举</strong>可以说是ZooKeeper<strong>最典型的应用场景</strong>了。比如HDFS中Active NameNode的选举、YARN中Active ResourceManager的选举和HBase中Active HMaster的选举等。</p><p>针对Master选举的需求，通常情况下，我们可以选择常见的<strong>关系型数据库</strong>中的<strong>主键特性</strong>来实现：希望成为Master的机器都向数据库中插入一条<strong>相同主键ID</strong>的记录，数据库会帮我们进行<strong>主键冲突检查</strong>，也就是说，<strong>只有一台</strong>机器能插入成功——那么，我们就认为向数据库中<strong>成功插入</strong>数据的客户端机器<strong>成为Master</strong>。</p><p>依靠关系型数据库的主键特性确实能够很好地保证在集群中选举出唯一的一个Master。但是，如果当前选举出的Master挂了，那么该如何处理？谁来告诉我Master挂了呢？显然，关系型数据库无法通知我们这个事件。但是，ZooKeeper可以做到！</p><p>利用ZooKeepr的强一致性，能够很好地保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即ZooKeeper将会保证客户端<strong>无法创建一个已经存在的ZNode</strong>。也就是说，如果同时有多个客户端请求创建<strong>同一个</strong>临时节点，那么最终一定<strong>只有一个</strong>客户端请求能够创建成功。利用这个特性，就能很容易地在分布式环境中进行Master选举了。</p><p>成功创建该节点的客户端所在的机器就成为了Master。同时，其他没有成功创建该节点的客户端，都会在该节点上<strong>注册</strong>一个子节点变更的<strong>Watcher</strong>，用于监控当前Master机器是否存活，一旦发现当前的Master挂了，那么其他客户端将会<strong>重新进行Master选举</strong>。</p><p>这样就实现了Master的<strong>动态选举</strong>。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁是控制<strong>分布式系统</strong>之间<strong>同步访问共享资源</strong>的一种方式。</p><p>分布式锁又分为<strong>排他锁</strong>和<strong>共享锁</strong>两种。</p><h4 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h4><p>排他锁（Exclusive Locks，简称X锁），又称为<strong>写锁</strong>或<strong>独占锁</strong>。</p><blockquote><p>如果事务T1对数据对象O1加上了排他锁，那么在整个加锁期间，只允许事务T1对O1进行<strong>读取和更新</strong>操作，其他任何事务都不能在对这个数据对象进行任何类型的操作（不能再对该对象加锁），直到T1释放了排他锁。</p></blockquote><p>可以看出，排他锁的核心是如何保证当前<strong>只有一个事务获得锁</strong>，并且锁<strong>被释放</strong>后，所有正在等待获取锁的事务都能够<strong>被通知到</strong>。</p><p>如何利用ZooKeeper实现排他锁？</p><p><strong>定义锁</strong></p><p>ZooKeeper上的<strong>一个ZNode可以表示一个锁</strong>。例如/exclusive_lock/lock节点就可以被定义为一个锁。</p><p><strong>获得锁</strong></p><p>如上所说，把ZooKeeper上的一个ZNode看作是一个锁，<strong>获得锁</strong>就通过<strong>创建ZNode</strong>的方式来实现。所有客户端都去/exclusive_lock节点下创建临时子节点/exclusive_lock/lock。ZooKeeper会保证在所有客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获得了锁。同时，所有没有获取到锁的客户端就需要到/exclusive_lock节点上注册一个子节点变更的Watcher监听，以便实时监听到lock节点的变更情况。</p><p><strong>释放锁</strong></p><p>因为/exclusive_lock/lock是一个<strong>临时节点</strong>，因此在以下两种情况下，都有可能释放锁。</p><ul><li>当前获得锁的客户端机器发生<strong>宕机</strong>或<strong>重启</strong>，那么该临时节点就会<strong>被删除，释放锁</strong>。</li><li>正常执行完业务逻辑后，客户端就会<strong>主动</strong>将自己创建的临时节点<strong>删除，释放锁</strong>。</li></ul><p>无论在什么情况下移除了lock节点，ZooKeeper都会<strong>通知</strong>所有在/exclusive_lock节点上注册了节点变更Watcher监听的客户端。这些客户端在接收到通知后，再次<strong>重新发起</strong>分布式锁获取，即重复『获取锁』过程。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><blockquote><p>共享锁（Shared Locks，简称S锁），又称为读锁。如果事务T1对数据对象O1加上了共享锁，那么T1只能对O1进行<strong>读操作</strong>，其他事务也能<strong>同时对O1加共享锁</strong>（不能是排他锁），直到O1上的所有共享锁都释放后O1才能被加排他锁。</p></blockquote><p>总结：可以<strong>多个事务同时获得</strong>一个对象的<strong>共享锁</strong>（同时读），有共享锁就不能再加排他锁（因为排他锁是写锁）</p><h2 id="ZooKeeper在大型分布式系统中的应用"><a href="#ZooKeeper在大型分布式系统中的应用" class="headerlink" title="ZooKeeper在大型分布式系统中的应用"></a>ZooKeeper在大型分布式系统中的应用</h2><p>前面已经介绍了ZooKeeper的典型应用场景。本节将以常见的大数据产品Hadoop和HBase为例来介绍ZooKeeper在其中的应用，帮助大家更好地理解ZooKeeper的分布式应用场景。</p><h3 id="ZooKeeper在Hadoop中的应用"><a href="#ZooKeeper在Hadoop中的应用" class="headerlink" title="ZooKeeper在Hadoop中的应用"></a>ZooKeeper在Hadoop中的应用</h3><p>在Hadoop中，ZooKeeper主要用于<strong>实现HA(High Availability）</strong>，包括<strong>HDFS的NamaNode和YARN的ResourceManager的HA</strong>。同时，在YARN中，ZooKeepr还用来<strong>存储应用的运行状态</strong>。HDFS的NamaNode和YARN的ResourceManager利用ZooKeepr实现HA的原理是一样的，所以本节以YARN为例来介绍。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-6326ec291ba11b95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YARN架构体系"></p><p>从上图可以看出，YARN主要由ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）和Container四部分组成。其中<strong>最核心</strong>的就是<strong>ResourceManager</strong>。</p><p>ResourceManager负责集群中<strong>所有资源的统一管理和分配</strong>，同时<strong>接收</strong>来自各个节点（NodeManager）的<strong>资源汇报信息</strong>，并把这些信息按照一定的策略分配给各个应用程序（Application Manager），其内部维护了各个应用程序的ApplicationMaster信息、NodeManager信息以及资源使用信息等。</p><p>为了实现HA，必须有<strong>多个ResourceManager并存</strong>（一般就两个），并且<strong>只有一个ResourceManager处于Active状态</strong>，其他的则处于Standby状态，当Active节点无法正常工作（如机器宕机或重启）时，处于Standby的就会通过<strong>竞争选举</strong>产生<strong>新的Active节点</strong>。</p><h4 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h4><p>下面我们就来看看YARN是如何实现多个ResourceManager之间的主备切换的。</p><ol><li><p>创建锁节点<br>在ZooKeeper上会有一个<code>/yarn-leader-election/appcluster-yarn</code>的锁节点，所有的ResourceManager在启动的时候，都会去竞争写一个Lock子节点：<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>，该节点是临时节点。ZooKeepr能够为我们保证最终<strong>只有一个</strong>ResourceManager能够<strong>创建成功</strong>。<strong>创建成功</strong>的那个ResourceManager就切换为<strong>Active状态</strong>，<strong>没有成功</strong>的那些ResourceManager则切换为<strong>Standby状态</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 16] get /yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</span><br><span class="line"></span><br><span class="line">appcluster-yarnrm2</span><br><span class="line">cZxid = 0x1b00133dc0</span><br><span class="line">ctime = Tue Jan 03 15:44:42 CST 2017</span><br><span class="line">mZxid = 0x1f00000540</span><br><span class="line">mtime = Sat Jan 07 00:50:20 CST 2017</span><br><span class="line">pZxid = 0x1b00133dc0</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 28</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 22</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li></ol><p>可以看到此时集群中ResourceManager2为Active。</p><ol start="2"><li><p>注册Watcher监听<br>所有Standby状态的ResourceManager都会向<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>节点注册一个节点变更的<strong>Watcher监听</strong>，利用<strong>临时节点的特性</strong>，能够快速感知到Active状态的ResourceManager的运行情况。</p></li><li><p>主备切换<br>当Active状态的ResourceManager出现诸如<strong>宕机或重启</strong>的异常情况时，其在ZooKeeper上连接的客户端<strong>会话就会失效</strong>，因此<code>/yarn-leader-election/appcluster-yarn/ActiveBreadCrumb</code>节点就会<strong>被删除</strong>。此时其余各个Standby状态的ResourceManager就都会<strong>接收到</strong>来自ZooKeeper服务端的<strong>Watcher事件通知</strong>，然后会<strong>重复进行步骤1的操作</strong>。</p></li></ol><p>以上就是利用ZooKeeper来实现ResourceManager的主备切换的过程，实现了ResourceManager的HA。</p><p>HDFS中NameNode的HA的实现原理跟YARN中ResourceManager的HA的实现原理相同。其锁节点为<code>/hadoop-ha/mycluster/ActiveBreadCrumb</code>。</p><h4 id="ResourceManager状态存储"><a href="#ResourceManager状态存储" class="headerlink" title="ResourceManager状态存储"></a>ResourceManager状态存储</h4><p>在 ResourceManager 中，<strong>RMStateStore</strong> 能够存储一些 RM 的<strong>内部状态信息</strong>，包括 Application 以及它们的 Attempts 信息、Delegation Token 及 Version Information 等。需要注意的是，RMStateStore 中的绝大多数状态信息都是<strong>不需要持久化存储</strong>的，因为<strong>很容易从上下文信息中将其重构出来</strong>，如资源的使用情况。在存储的设计方案中，提供了三种可能的实现，分别如下。</p><ul><li>基于内存实现，一般是用于日常开发测试。</li><li>基于文件系统的实现，如HDFS。</li><li>基于ZooKeeper实现。</li></ul><p>由于这些状态信息的<strong>数据量都不是很大</strong>，因此Hadoop<strong>官方建议基于ZooKeeper来实现状态信息的存储</strong>。在ZooKeepr上，ResourceManager 的状态信息都被存储在<code>/rmstore</code>这个根节点下面。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">28</span>] ls /rmstore/ZKRMStateRoot</span><br><span class="line">[RMAppRoot, AMRMTokenSecretManagerRoot, EpochNode, RMDTSecretManagerRoot, RMVersionNode]</span><br></pre></td></tr></table></figure><p>RMAppRoot 节点下存储的是与各个 Application 相关的信息，RMDTSecretManagerRoot 存储的是与安全相关的 Token 等信息。每个 Active 状态的 ResourceManager 在<strong>初始化阶段</strong>都会从 ZooKeeper 上<strong>读取到这些状态信息</strong>，并根据这些状态信息继续进行相应的处理。</p><p>小结：</p><p>ZooKeepr在Hadoop中的应用主要有：</p><ol><li>HDFS中NameNode的HA和YARN中ResourceManager的HA。</li><li>存储RMStateStore状态信息</li></ol><h3 id="ZooKeeper在HBase中的应用"><a href="#ZooKeeper在HBase中的应用" class="headerlink" title="ZooKeeper在HBase中的应用"></a>ZooKeeper在HBase中的应用</h3><p>HBase主要用ZooKeeper来实现<strong>HMaster选举与主备切换、系统容错、RootRegion管理、Region状态管理和分布式SplitWAL任务管理</strong>等。</p><h4 id="HMaster选举与主备切换"><a href="#HMaster选举与主备切换" class="headerlink" title="HMaster选举与主备切换"></a>HMaster选举与主备切换</h4><p>HMaster选举与主备切换的原理和HDFS中NameNode及YARN中ResourceManager的HA原理相同。</p><h4 id="系统容错"><a href="#系统容错" class="headerlink" title="系统容错"></a>系统容错</h4><p>当HBase启动时，每个<strong>RegionServer</strong>都会到ZooKeeper的<code>/hbase/rs</code>节点下创建一个信息节点（下文中，我们称该节点为”rs状态节点”），例如<code>/hbase/rs/[Hostname]</code>，同时，<strong>HMaster</strong>会对这个节点<strong>注册监听</strong>。当某个 RegionServer 挂掉的时候，ZooKeeper会因为在一段时间内无法接受其心跳（即 Session 失效），而删除掉该 RegionServer 服务器对应的 rs 状态节点。与此同时，HMaster 则会接收到 ZooKeeper 的 NodeDelete 通知，从而感知到某个节点断开，并立即开始容错工作。</p><p>HBase为什么不直接让HMaster来负责RegionServer的监控呢？如果HMaster直接通过<strong>心跳机制</strong>等来管理RegionServer的状态，随着<strong>集群越来越大</strong>，HMaster的<strong>管理负担会越来越重</strong>，另外它自身也有挂掉的可能，因此数据还<strong>需要持久化</strong>。在这种情况下，ZooKeeper就成了理想的选择。</p><h4 id="RootRegion管理"><a href="#RootRegion管理" class="headerlink" title="RootRegion管理"></a>RootRegion管理</h4><p>对应HBase集群来说，数据存储的<strong>位置信息</strong>是记录在<strong>元数据region</strong>，也就是<strong>RootRegion</strong>上的。每次客户端发起新的请求，需要知道数据的位置，就会去查询RootRegion，而<strong>RootRegion自身位置则是记录在ZooKeeper上</strong>的（默认情况下，是记录在ZooKeeper的<code>/hbase/meta-region-server</code>节点中）。当RootRegion发生变化，比如Region的手工移动、重新负载均衡或RootRegion所在服务器发生了故障等是，就能够通过ZooKeeper来感知到这一变化并做出一系列相应的容灾措施，从而保证客户端总是能够拿到正确的RootRegion信息。</p><h4 id="Region管理"><a href="#Region管理" class="headerlink" title="Region管理"></a>Region管理</h4><p>HBase里的Region会经常发生变更，这些变更的原因来自于系统故障、负载均衡、配置修改、Region分裂与合并等。一旦Region发生移动，它就会经历<strong>下线（offline）和重新上线（online）</strong>的过程。</p><p>在<strong>下线期间</strong>数据是<strong>不能被访问</strong>的，并且Region的这个状态变化必须<strong>让全局知晓</strong>，否则可能会出现<strong>事务性的异常</strong>。对于大的HBase集群来说，Region的数量可能会多达十万级别，甚至更多，这样规模的Region状态管理交给ZooKeeper来做也是一个很好的选择。</p><h4 id="分布式SplitWAL任务管理"><a href="#分布式SplitWAL任务管理" class="headerlink" title="分布式SplitWAL任务管理"></a>分布式SplitWAL任务管理</h4><p>当某台<strong>RegionServer服务器挂掉</strong>时，由于总有一部分<strong>新写入的数据还没有持久化到HFile中</strong>，因此在迁移该RegionServer的服务时，一个重要的工作就是<strong>从WAL中恢复</strong>这部分还在内存中的数据，而这部分工作<strong>最关键的一步</strong>就是<strong>SplitWAL</strong>，即HMaster需要遍历该RegionServer服务器的WAL，并按Region切分成小块移动到新的地址下，并进行<strong>日志的回放（replay）</strong>。</p><p>由于单个RegionServer的日志量相对庞大（可能有上千个Region，上GB的日志），而用户又往往希望系统能够快速完成日志的恢复工作。因此一个可行的方案是将这个处理WAL的任务<strong>分给多台RegionServer服务器</strong>来共同处理，而这就又需要一个<strong>持久化组件来辅助HMaster完成任务的分配</strong>。当前的做法是，HMaster会在ZooKeeper上创建一个<strong>SplitWAL节点</strong>（默认情况下，是<code>/hbase/SplitWAL</code>节点），将<strong>“哪个RegionServer处理哪个Region”</strong>这样的信息以<strong>列表的形式</strong>存放到该节点上，然后由各个RegionServer服务器自行到该节点上去<strong>领取任务</strong>并在任务执行成功或失败后再<strong>更新该节点的信息</strong>，以通知HMaster继续进行后面的步骤。ZooKeeper在这里担负起了分布式集群中<strong>相互通知和信息持久化</strong>的角色。</p><p>小结：</p><p>以上就是一些HBase中依赖ZooKeeper完成分布式协调功能的典型场景。但事实上，HBase对ZooKeepr的依赖还不止这些，比如HMaster还依赖ZooKeeper来完成Table的enable/disable状态记录，以及HBase中<strong>几乎所有的元数据存储</strong>都是放在ZooKeeper上的。</p><p>由于ZooKeeper出色的分布式协调能力及良好的通知机制，HBase在各版本的演进过程中越来越多地增加了ZooKeeper的应用场景，从趋势上来看两者的交集越来越多。HBase中所有对ZooKeeper的操作都封装在了org.apache.hadoop.hbase.zookeeper这个包中，感兴趣的同学可以自行研究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《从Paxos到Zookeeper》</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper是一个开源的&lt;strong&gt;分布式协调服务&lt;/strong&gt;，由雅虎创建，是Google &lt;strong&gt;Chubby的开源实现&lt;/strong&gt;。分布式应用程序可以基于ZooKeeper实现诸如&lt;strong&gt;数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列&lt;/strong&gt;等功能。&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="http://linbingdong.com/categories/ZooKeeper/"/>
    
    
      <category term="大数据" scheme="http://linbingdong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ZooKeeper" scheme="http://linbingdong.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Python函数式编程</title>
    <link href="http://linbingdong.com/2017/03/15/Python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://linbingdong.com/2017/03/15/Python函数式编程/</id>
    <published>2017-03-15T08:24:20.000Z</published>
    <updated>2017-03-15T08:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 Python 不是函数式编程语言（是命令式编程语言），但是支持许多有价值的函数式编程工具。Python 提供 3 种内建函数和 lambda 表达式等来支持函数式编程。</p><a id="more"></a><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Python 允许用 lambda 关键字创造匿名函数。匿名顾名思义就是没有名字，即不需要以标准的方式来声明，比如说，使用 def 加函数名来声明。一个完整的 lambda “语句”代表了一个表达式，这个表达式的定义体必须和声明放在同一行。语法如下：</p><p><code>lambda [arg1[, arg2, ... argN]]: expression</code></p><p>参数是可选的，如果使用参数的话，参数通常也会出现在表达式中。</p><p>注意：lambda 表达式返回可调用的函数对象。其实 lambda 表达式本身就是一个函数，这个函数定义了输入（冒号左边）和输出（冒号右边），只不过这个函数没有名字，但是我们可以把它赋给一个变量。</p><p>比如简单的加法函数。一般我们是这么写的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x+y</span><br></pre></td></tr></table></figure><p>lambda 表达式这么写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y : x + y</span><br></pre></td></tr></table></figure><p>我们可以把 <code>lambda x, y : x + y</code> 赋值给 f ，然后给 f 传参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y : x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x10377f320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">12</span>, <span class="number">100</span>)</span><br><span class="line"><span class="number">112</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-33</span>, <span class="number">-22</span>)</span><br><span class="line"><span class="number">-55</span></span><br></pre></td></tr></table></figure><p>可以看到，f 确实是个函数，可以接收两个参数，并返回这两个参数的和，等价于上面的 add 函数。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数英文叫 Higher-order function 。一般函数的输入参数和返回值都只能是变量或常量，如果某个函数可以接收函数作为其输入参数，或者其返回值中包含函数，那么该函数就是高阶函数。</p><p>Python 中有三个内建的用来支持函数式编程的高阶函数，分别是  <a href="https://docs.python.org/2.7/library/functions.html#filter" target="_blank" rel="noopener">filter()</a>，<a href="https://docs.python.org/2.7/library/functions.html#map" target="_blank" rel="noopener">map()</a> 和 <a href="https://docs.python.org/2.7/library/functions.html#reduce" target="_blank" rel="noopener">reduce()</a>。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>filter(function, sequence) 返回一个 sequence (序列)，返回的序列中包括了输入序列中所有调用 function(item) 后返回值为 true 的元素。</p><p>filter() 工作流程如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-274646d0478cb876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="how the filter() built-in function works"></p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(f, range(<span class="number">2</span>, <span class="number">25</span>))</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><p>因为 filter() 的输入参数中包含函数 f() ，所以 filter() 是高阶函数。上面的例子中返回 2~24 中能被 3 或 5 整除的数组成的列表。</p><p>当然，也可以使用匿名函数 lambda 表达式实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x : x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span>, range(<span class="number">2</span>, <span class="number">25</span>))</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><p>或者使用列表生成式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">25</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">5</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map() 与 filter() 相似，因为它也能通过函数来处理序列。map()<br>将函数调用“映射”到序列的每个元素上，并返回一个含有所有返回值的列表。</p><p>map() 工作流程如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-117f98c795acfd5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the map() built-in function works"></p><p>举个栗子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">cube</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x**<span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(cube, range(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p>上面的例子中，将 1~10 里的每个数分别调用 cube() ，并将返回值（x 的 3 次方）放入列表中。</p><p>lambda 表达式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x : x**<span class="number">3</span>, range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p>列表生成式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：map() 也可以处理多个序列。</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x, y: (x+y, x-y), [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[(<span class="number">3</span>, <span class="number">-1</span>), (<span class="number">7</span>, <span class="number">-1</span>), (<span class="number">11</span>, <span class="number">-1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><p>工作流程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-881a52aa250e3bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the map() built-in function works with &gt; 1 sequence"></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce(function, sequence) 返回一个单值，它是这样构造的：首先以序列的前两个元素调用函数 function，再以返回值和第三个参数调用，依次执行下去。</p><p>reduce() 工作流程如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-b6f3bb3a8024a63c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="How the reduce() built-in function works"></p><p>例如，以下程序计算 0 到 5 的整数之和:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span> <span class="keyword">return</span> x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>实际上 reduce() 执行了如下的运算：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">((((0+1)+2)+3)+4)   ==&gt;  10</span><br></pre></td></tr></table></figure><p>lambda 表达式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(<span class="keyword">lambda</span> x, y : x + y, range(<span class="number">0</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>偏函数解决这样的问题：如果我们有函数是多个参数的，我们希望能固定其中某几个参数的值（类似于默认值）。</p><p>举个栗子：</p><p>int() 函数可以把字符串转换为整数，当仅传入字符串时，int() 函数默认按十进制转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>)</span><br><span class="line"><span class="number">11111</span></span><br></pre></td></tr></table></figure><p>但 int() 函数还提供额外的 base 参数（默认值为10） 。如果传入 base 参数，就可以做 N 进制的转换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>,<span class="number">8</span>)</span><br><span class="line"><span class="number">4681</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'11111'</span>,base=<span class="number">16</span>)</span><br><span class="line"><span class="number">69905</span></span><br></pre></td></tr></table></figure><p>假设要转换大量的二进制字符串，每次都传入 int(x, base=2) 非常麻烦，于是，我们想到，可以定义一个 int2() 的函数，默认把 base=2 传进去：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br></pre></td></tr></table></figure><p>这样，我们就可以方便地转换二进制了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code> 就是帮助我们创建一个偏函数的，不需要我们自己定义 int2() ，可以直接使用下面的代码创建一个新的函数 int2 ：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>)</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'10000'</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>总结一下，<code>functools.partial</code> 的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>需要注意的是，上面的新的 int2 函数，仅仅是把 base 参数重新设定默认值为 2 ，但也可以在函数调用时传入其他值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>,base=<span class="number">10</span>)</span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'11111'</span>,base=<span class="number">8</span>)</span><br><span class="line"><span class="number">4681</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Python核心编程》</li><li>Python官方文档</li><li>廖雪峰的Python教程</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 Python 不是函数式编程语言（是命令式编程语言），但是支持许多有价值的函数式编程工具。Python 提供 3 种内建函数和 lambda 表达式等来支持函数式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://linbingdong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://linbingdong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>纠删码（Erasure Code）浅析</title>
    <link href="http://linbingdong.com/2017/03/11/%E7%BA%A0%E5%88%A0%E7%A0%81%EF%BC%88Erasure%20Code%EF%BC%89%E6%B5%85%E6%9E%90/"/>
    <id>http://linbingdong.com/2017/03/11/纠删码（Erasure Code）浅析/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>【摘要】：副本策略和纠删码是存储领域常见的两种数据冗余技术。相比于副本策略，纠删码具有更高的磁盘利用率。 Reed-Solomon码是一种常见的纠删码。</p><a id="more"></a><p>多副本策略即将数据存储多个副本（一般是三副本，比如HDFS），当某个副本丢失时，可以通过其他副本复制回来。三副本的磁盘利用率为1/3。</p><p>纠删码技术主要是通过纠删码算法将原始的数据进行编码得到冗余，并将数据和冗余一并存储起来，以达到容错的目的。其基本思想是将n块原始的数据元素通过一定的计算，得到m块冗余元素（校验块）。对于这n+m块的元素，当其中任意的m块元素出错（包括原始数据和冗余数据）时，均可以通过对应的重构算法恢复出原来的n块数据。生成校验的过程被成为编码（encoding），恢复丢失数据块的过程被称为解码（decoding）。磁盘利用率为n/(n+m)。基于纠删码的方法与多副本方法相比具有冗余度低、磁盘利用率高等优点。</p><p>两种冗余技术对比如下表：</p><table><thead><tr><th align="center">两种技术</th><th align="center">磁盘利用率</th><th align="center">计算开销</th><th align="center">网络消耗</th><th align="center">恢复效率</th></tr></thead><tbody><tr><td align="center">多副本(3副本)</td><td align="center">1/3</td><td align="center">几乎没有</td><td align="center">较低</td><td align="center">较高</td></tr><tr><td align="center">纠删码(n+m)</td><td align="center">n/(n+m)</td><td align="center">高</td><td align="center">较高</td><td align="center">较低</td></tr></tbody></table><h2 id="Reed-Solomon-RS-码"><a href="#Reed-Solomon-RS-码" class="headerlink" title="Reed-Solomon(RS)码"></a>Reed-Solomon(RS)码</h2><p>Reed-Solomon（RS）码是存储系统较为常用的一种纠删码，它有两个参数n和m，记为RS(n,m)。n代表原始数据块个数。m代表校验块个数。接下来介绍RS码的原理。</p><h2 id="RS码原理"><a href="#RS码原理" class="headerlink" title="RS码原理"></a>RS码原理</h2><p>以n=5，m=3为例。即5个原始数据块，乘上一个(n+m)*n的矩阵，然后得出一个(n+m)*1的矩阵。根据矩阵特点可以得知结果矩阵中前面5个值与原来的5个数据块的值相等，而最后3个则是计算出来的校验块。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-cc930e9d848ee224.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>以上过程为编码过程。D是原始数据块，得到的C为校验块。</p><p>假设丢失了m块数据。如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-feb8c76af3c7bab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="丢失m块"></p><p>那我们如何从剩余的n个数据块（注意，这里剩余的n块可能包含几个原始数据块+几个校验块）恢复出来原始的n个数据块呢，就需要通过下面的decoding（解码）过程来实现。</p><p>第一步：从编码矩阵中删去丢失数据块和丢失编码块对应行。 将删掉m个块的(n+m)*1个矩阵变形为n*1矩阵，同时B矩阵也需要删掉对应的m个行得出一个B’的变形矩阵，这个B’就是n*n矩阵。如下：假设D1、D4、C2丢失，我们得到如下B’矩阵及等式。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-7ddc3f3071489be9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vandermode矩阵"></p><p>第二步：求出B’的逆矩阵。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-b5d966cd6cb3866c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="B’逆矩阵"></p><p>第三步：等式两边分别乘上B’的逆矩阵。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-03509dcf17c0a358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两边乘上B’逆矩阵"></p><p>B’和它的逆矩阵相乘得到单位矩阵I，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-565e7d41f929107c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单位矩阵"></p><p>左边只剩下原始数据矩阵D：</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-225afb1b2353ae9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>至此完成解码过程。</p><p>注：图中黄色部分为范德蒙矩阵。至于如何生成B矩阵，以及如何求B’的逆矩阵，请查看其他相关文献，这里不再赘述。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>RS的特点：</p><ul><li>低冗余度，高磁盘利用率。</li><li>数据恢复代价高。 丢失数据块或者编码块时， RS需要读取n个数据块和校验块才能恢复数据， 数据恢复效率也在一定程度上制约了RS的可靠性。</li><li>数据更新代价高。 数据更新相当于重新编码， 代价很高， 因此常常针对只读数据，或者冷数据。</li></ul><p>工程实践中，一般对于热数据还是会使用多副本策略来冗余，冷数据使用纠删码。</p><p>值得期待的是，纠删码技术也即将在Hadoop 3.0中发布。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>论文《Erasure Codes for Storage Applications》</li><li>论文《存储系统中纠删码研究综述》<br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【摘要】：副本策略和纠删码是存储领域常见的两种数据冗余技术。相比于副本策略，纠删码具有更高的磁盘利用率。 Reed-Solomon码是一种常见的纠删码。&lt;/p&gt;
    
    </summary>
    
      <category term="纠删码" scheme="http://linbingdong.com/categories/%E7%BA%A0%E5%88%A0%E7%A0%81/"/>
    
    
      <category term="存储" scheme="http://linbingdong.com/tags/%E5%AD%98%E5%82%A8/"/>
    
      <category term="数据冗余" scheme="http://linbingdong.com/tags/%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99/"/>
    
      <category term="纠删码" scheme="http://linbingdong.com/tags/%E7%BA%A0%E5%88%A0%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://linbingdong.com/2017/03/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://linbingdong.com/2017/03/11/设计模式-观察者模式/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式又叫发布/订阅模式。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>观察者模式</strong>定义了对象之间的一对多依赖，使得当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。观察者模式又叫<strong>发布/订阅模式</strong>。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li><p><strong>抽象主题（Subject）</strong>：它把所有观察者对象的引用保存到一个列表里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p></li><li><p><strong>具体主题（ConcreteSubject）</strong>：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p></li><li><p><strong>抽象观察者（Observer）</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p></li><li><p><strong>具体观察者（ConcreteObserver）</strong>：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p></li></ul><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1752522-8946e89856251d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="观察者模式"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以<strong>猎头-求职者</strong>为例。猎头是主题，求职者是观察者。</p><p>Subject 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeadHunter 类实现 Subject 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadHunter</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Observer&gt; userList;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;String&gt; jobs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeadHunter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userList = <span class="keyword">new</span> LinkedList&lt;Observer&gt;();</span><br><span class="line">        jobs = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        userList.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        userList.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o: userList) &#123;</span><br><span class="line">            o.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(String job)</span> </span>&#123;</span><br><span class="line">        jobs.add(job);</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LinkedList&lt;String&gt; <span class="title">getJobs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JobSeeker 类实现 Observer 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSeeker</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">JobSeeker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Subject s)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name + <span class="string">" got notified!"</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeadHunter hh = <span class="keyword">new</span> HeadHunter();</span><br><span class="line"></span><br><span class="line">        JobSeeker lbd = <span class="keyword">new</span> JobSeeker(<span class="string">"lbd"</span>);</span><br><span class="line">        JobSeeker lbx = <span class="keyword">new</span> JobSeeker(<span class="string">"lbx"</span>);</span><br><span class="line">        JobSeeker lbn = <span class="keyword">new</span> JobSeeker(<span class="string">"lbn"</span>);</span><br><span class="line">        JobSeeker lbb = <span class="keyword">new</span> JobSeeker(<span class="string">"lbb"</span>);</span><br><span class="line"></span><br><span class="line">        hh.registerObserver(lbd);</span><br><span class="line">        hh.registerObserver(lbx);</span><br><span class="line">        hh.registerObserver(lbn);</span><br><span class="line">        hh.registerObserver(lbb);</span><br><span class="line">        hh.removeObserver(lbb);</span><br><span class="line"></span><br><span class="line">        hh.addJob(<span class="string">"looking for Java engineers"</span>);</span><br><span class="line">        hh.addJob(<span class="string">"looking for Python engineers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lbd got notified!</span><br><span class="line">[looking for Java engineers]</span><br><span class="line">lbx got notified!</span><br><span class="line">[looking for Java engineers]</span><br><span class="line">lbn got notified!</span><br><span class="line">[looking for Java engineers]</span><br><span class="line">lbd got notified!</span><br><span class="line">[looking for Java engineers, looking for Python engineers]</span><br><span class="line">lbx got notified!</span><br><span class="line">[looking for Java engineers, looking for Python engineers]</span><br><span class="line">lbn got notified!</span><br><span class="line">[looking for Java engineers, looking for Python engineers]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者模式使主题和观察者之间松耦合，松耦合的设计能够让我们建立有弹性的OO系统，能够应对变化，因为对象之间的相互依赖降到了最低。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>上面的例子是观察者模式的“推”模式，还有一种“拉”模式。</li><li>Java 的 java.util 库里面，提供了一个 Observable 类以及一个 Observer 接口，构成 Java 语言对观察者模式的支持。<br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者模式又叫发布/订阅模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://linbingdong.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://linbingdong.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://linbingdong.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python日志模块示例</title>
    <link href="http://linbingdong.com/2017/03/11/Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E7%A4%BA%E4%BE%8B/"/>
    <id>http://linbingdong.com/2017/03/11/Python日志模块示例/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>给出Python日志模块显示配置和文件配置两种方式的示例</p><a id="more"></a><h2 id="显示配置"><a href="#显示配置" class="headerlink" title="显示配置"></a>显示配置</h2><p>在程序中直接调用函数来设置参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'example'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个输出到控制台的handler</span></span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line">sh.setLevel(logging.ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个输出到文件的handler</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'loggingtest.log'</span>)</span><br><span class="line">fh.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出格式</span></span><br><span class="line">fmt = logging.Formatter(<span class="string">'%(asctime)s - %(threadName)s - [%(levelname)s] : %(message)s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># handler设置formatter</span></span><br><span class="line">sh.setFormatter(fmt)</span><br><span class="line">fh.setFormatter(fmt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># logger添加handler</span></span><br><span class="line">logger.addHandler(sh)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写日志</span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>通过配置文件进行配置，使用fileConfig()函数读取配置文件</p><ul><li>配置文件 logging.conf :</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[loggers]</span><br><span class="line">keys=root,example01</span><br><span class="line"></span><br><span class="line">[logger_root]</span><br><span class="line">level=DEBUG</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line"></span><br><span class="line">[logger_example01]</span><br><span class="line">handlers=hand01,hand02</span><br><span class="line">qualname=example01</span><br><span class="line">propagate=0</span><br><span class="line"></span><br><span class="line">[handlers]</span><br><span class="line">keys=hand01,hand02</span><br><span class="line"></span><br><span class="line">[handler_hand01]</span><br><span class="line">class=StreamHandler</span><br><span class="line">level=INFO</span><br><span class="line">formatter=form02</span><br><span class="line">args=(sys.stderr,)</span><br><span class="line"></span><br><span class="line">[handler_hand02]</span><br><span class="line">class=FileHandler</span><br><span class="line">level=DEBUG</span><br><span class="line">formatter=form01</span><br><span class="line">args=(&apos;log.log&apos;,&apos;a&apos;)</span><br><span class="line"></span><br><span class="line">[formatters]</span><br><span class="line">keys=form01,form02</span><br><span class="line"></span><br><span class="line">[formatter_form01]</span><br><span class="line">format=%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s</span><br><span class="line"></span><br><span class="line">[formatter_form02]</span><br><span class="line">format=%(asctime)s - %(threadName)s - [%(levelname)s] : %(message)s</span><br></pre></td></tr></table></figure><ul><li>程序 LogByFile.py :</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">logging.config.fileConfig(<span class="string">'logging.conf'</span>)</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(<span class="string">'example01'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写日志</span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出Python日志模块显示配置和文件配置两种方式的示例&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://linbingdong.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://linbingdong.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop YARN介绍</title>
    <link href="http://linbingdong.com/2017/03/11/Hadoop%20YARN%E4%BB%8B%E7%BB%8D/"/>
    <id>http://linbingdong.com/2017/03/11/Hadoop YARN介绍/</id>
    <published>2017-03-11T12:33:42.000Z</published>
    <updated>2017-03-11T12:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>YARN是Hadoop集群的资源管理系统。Hadoop2.0对MapReduce框架做了彻底的设计重构。YARN的基本设计思想是将MRv1中的JobTracker拆分成了两个独立的服务：一个<strong>全局的资源管理器ResourceManager</strong>和<strong>每个应用程序特有的ApplicationMaster</strong>。其中ResourceManager负责整个系统的<strong>资源管理和分配</strong>，而ApplicationMaster负责<strong>单个应用程序的管理</strong>。</p><a id="more"></a><h2 id="YARN产生背景"><a href="#YARN产生背景" class="headerlink" title="YARN产生背景"></a>YARN产生背景</h2><h3 id="MRv1的局限"><a href="#MRv1的局限" class="headerlink" title="MRv1的局限"></a>MRv1的局限</h3><p>YARN是在MRv1基础上演化而来的，它克服了MRv1中的各种局限性。在正式介绍YARN之前，先了解下MRv1的一些局限性，主要有以下几个方面：</p><ul><li><strong>扩展性差</strong>。在MRv1中，<strong>JobTracker</strong>同时兼备了<strong>资源管理</strong>和<strong>作业控制</strong>两个功能，这成为系统的一个最大瓶颈，严重制约了Hadoop集群扩展性。</li><li><strong>可靠性差</strong>。MRv1采用了<strong>master/slave</strong>结构，其中，master存在<strong>单点故障</strong>问题，一旦它出现故障将导致整个集群不可用。</li><li><strong>资源利用率低</strong>。MRv1采用了<strong>基于槽位</strong>的资源分配模型，槽位是一种<strong>粗粒度</strong>的资源划分单位，通常一个任务不会用完槽位对应的资源，且其他任务也无法使用这些空闲资源。此外，Hadoop将槽位分为Map Slot和Reduce Slot两种，且不允许它们之间共享，常常会导致一种槽位资源紧张而另外一种闲置（比如一个作业刚刚提交时，只会运行Map Task，此时Reduce Slot闲置）。</li><li><strong>无法支持多种计算框架</strong>。随着互联网高速发展，MapReduce这种基于磁盘的离线计算框架已经不能满足应用要求，从而出现了一些新的计算框架，包括<strong>内存计算框架、流式计算框架和迭代式计算框架等</strong>，而MRv1不能支持多种计算框架并存。</li></ul><p>为了克服以上几个缺点，Apache开始尝试对Hadoop进行升级改造，进而诞生了更加先进的下一代MapReduce计算框架MRv2。正是由于MRv2将<strong>资源管理功能</strong>抽象成了一个独立的通用系统YARN，直接导致下一代MapReduce的核心从单一的计算框架MapReduce转移为通用的资源管理系统YARN。</p><h3 id="集群资源统一管理"><a href="#集群资源统一管理" class="headerlink" title="集群资源统一管理"></a>集群资源统一管理</h3><p>随着互联网的高速发展，新的计算框架不断出现，从支持离线处理的MapReduce，到支持在线处理的Storm，从迭代式计算框架Spark到流式处理框架S4，各种框架各有所长，各自解决了某一类应用问题。这时候就需要一个组件对同一个集群上的不同计算框架进行资源的统一管理。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-a895d67381e80a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YARN"></p><p>相比于“一种计算框架一个集群”的模式，共享集群的模式存在多种好处：</p><ul><li><strong>资源利用率高</strong>。如果每个框架一个集群，可能在某段时间内，有些计算框架的集群资源紧张，而另外一些集群资源空闲。共享集群模式则通过多种框架共享资源，使得集群中的资源得到更加充分的利用。</li><li><strong>运维成本低</strong>。如果采用“一个框架一个集群”的模式，则可能需要多个管理员管理这些集群，进而增加运维成本，而共享模式通常需要少数管理员即可完成多个框架的统一管理。</li><li><strong>数据共享</strong>。随着数据量的暴增，跨集群间的数据移动不仅需花费更长的时间，且硬件成本也会大大增加，而共享集群模式可让多种框架共享数据和硬件资源，将大大减小数据移动带来的成本。</li></ul><h2 id="YARN基本设计思想"><a href="#YARN基本设计思想" class="headerlink" title="YARN基本设计思想"></a>YARN基本设计思想</h2><p>MRv1主要由<strong>编程模型、数据处理引擎（由Map Task和Reduce Task组成）和运行时环境</strong>三部分组成。为了保证编程模型的向后兼容性，MRv2重用了MRv1中的编程模型和数据处理引擎，但运行时环境被完全重写。</p><p>MRv1的运行时环境主要由两类服务组成，分别是JobTracker和TaskTracker。其中，JobTracker负责<strong>资源管理</strong>和<strong>作业控制</strong>。TaskTracker负责<strong>单个节点</strong>的<strong>资源管理和任务执行</strong>。</p><p>MRv1将资源管理和应用程序管理两部分混杂在一起，使得它在扩展性、容错性和多框架支持等方面存在明显缺陷。</p><p>而MRv2则通过将资源管理和应用程序管理两部分剥离开，分别由ResourceManager和ApplicationMaster负责，其中ResourceManager专管资源管理和调度，而ApplicationMaster则负责与具体应用程序相关的任务切分、任务调度和容错等，具体如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-3bb6aa683a1c3f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h2 id="YARN基本架构"><a href="#YARN基本架构" class="headerlink" title="YARN基本架构"></a>YARN基本架构</h2><p>YARN是Hadoop 2.0中的资源管理系统，它的基本设计思想是将MRv1中的JobTracker拆分成了两个独立的服务：一个<strong>全局的资源管理器ResourceManager</strong>和<strong>每个应用程序特有的ApplicationMaster</strong>。其中ResourceManager负责整个系统的<strong>资源管理和分配</strong>，而ApplicationMaster负责<strong>单个应用程序的管理</strong>。</p><p>YARN总体上仍然是Master/Slave结构，在整个资源管理框架中，ResourceManager为Master，NodeManager为Slave，ResourceManager负责对各个NodeManager上的资源进行统一管理和调度。当用户提交一个应用程序时，需要提供一个用以跟踪和管理这个程序的ApplicationMaster，它负责向ResourceManager申请资源，并要求NodeManger启动可以占用一定资源的任务。由于不同的ApplicationMaster被分布到不同的节点上，因此它们之间不会相互影响。</p><p>下图描述了YARN的基本组成结构，YARN主要由ResourceManager、NodeManager、ApplicationMaster（图中给出了MapReduce和MPI两种计算框架的ApplicationMaster，分别为MR AppMstr和MPI AppMstr）和Container等几个组件构成。</p><p><img src="http://upload-images.jianshu.io/upload_images/1752522-e8cca9823e3db77c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YARN基本架构"></p><p>接下来对YARN里几个重要的组件一一介绍。</p><h3 id="1-ResourceManager-RM"><a href="#1-ResourceManager-RM" class="headerlink" title="1. ResourceManager(RM)"></a>1. ResourceManager(RM)</h3><p>RM是一个全局的资源管理器,负责整个系统的资源管理和分配。它主要由两个组件构成：<strong>调度器</strong>（Scheduler）和<strong>应用程序管理器</strong>（Applications Manager，ASM）。</p><p>（1）调度器（分配Container）</p><p>调度器根据容量、队列等限制条件（如每个队列分配一定的资源，最多执行一定数量的作业等），将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务，这些均交由应用程序相关的ApplicationMaster完成。调度器仅根据各个应用程序的资源需求进行资源分配，而资源分配单位用一个抽象概念“资源容器”（Resource Container，简称Container）表示，Container是一个动态资源分配单位，它将内存、CPU、磁盘、网络等资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件，用户可根据自己的需要设计新的调度器，YARN提供了多种直接可用的调度器，比如Fair Scheduler和Capacity Scheduler等。</p><p>（2）应用程序管理器</p><p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动ApplicationMaster、监控ApplicationMaster运行状态并在失败时重新启动它等。</p><h3 id="2-ApplicationMaster（AM）"><a href="#2-ApplicationMaster（AM）" class="headerlink" title="2. ApplicationMaster（AM）"></a>2. ApplicationMaster（AM）</h3><p>用户提交的每个应用程序均包含一个AM，主要功能包括：</p><ul><li>与RM调度器协商以获取资源（以Container表示）</li><li>将得到的任务进一步分配给内部的任务</li><li>与NM通信以启动/停止任务</li><li>监控所有任务运行状态，并在任务失败时重新为任务申请资源以重启任务</li></ul><h3 id="3-NodeManager（NM）"><a href="#3-NodeManager（NM）" class="headerlink" title="3. NodeManager（NM）"></a>3. NodeManager（NM）</h3><p>NM是每个节点上的资源和任务管理器。一方面，它定时地向RM汇报本节点的资源使用情况和Container运行状态；另一方面，它接受并处理来自AM的Container启动/停止等各种请求。</p><h3 id="4-Container"><a href="#4-Container" class="headerlink" title="4. Container"></a>4. Container</h3><p>Container是YARN中的资源抽象，它封装了某个节点上的多维资源，如CPU、内存、磁盘、网络等。当AM向RM申请资源时，RM向AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。Container是一个动态资源划分单位，是根据应用程序的需求自动生成的。目前，YARN仅支持CPU和内存两种资源。</p><h2 id="YARN工作流程"><a href="#YARN工作流程" class="headerlink" title="YARN工作流程"></a>YARN工作流程</h2><p>运行在YARN上的应用程序主要分为两类：短应用程序和长应用程序。其中，短应用程序是指一定时间内可运行完成并正常退出的应用程序，如MapReduce作业、Spark DAG作业等。长应用程序是指不出意外，永不终止运行的应用程序，通常是一些服务，比如Storm Service（包括Nimbus和Supervisor两类服务），HBase Service（包括HMaster和RegionServer两类服务）等，而它们本身作为一种框架提供编程接口供用户使用。尽管这两类应用程序作业不同，一类直接运行数据处理程序，一类用于部署服务（服务之上再运行数据处理程序），但运行在YARN上的流程是相同的。</p><p>当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序：第一阶段是启动ApplicationMaster。第二阶段是由ApplicationMaster创建应用程序，为它申请资源，并监控它的整个运行过程，直到运行完成。具体如下：</p><ol><li>用户向YARN中提交应用程序，其中包括ApplicationMaster程序、启动ApplicationMaster的命令、用户程序等。</li><li>ResourceManager为该应用程序分配第一个Container，并与对应的NodeManager通信，要求它在这个Container中启动应用程序的ApplicationMaster。</li><li>ApplicationMaster首先向ResourceManager注册，这样用户就可以直接通过ResourceManager查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束，即重复步骤4~7。</li><li>ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</li><li>一旦ApplicationMaster申请到资源后，便与对应的NodeManager通信，要求它启动任务。</li><li>NodeManager为任务设置好运行环境（包括环境变量、JAR包、二进制程序等）后，将任务启动命令写到一个脚本中，并通过运行该脚本启动任务。</li><li>各个任务通过某个RPC协议向ApplicationMaster汇报自己的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务。</li><li>应用程序运行完成后，ApplicationMaster向ResourceManager注销并关闭自己。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1752522-fdc8b62896158e92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YARN工作流程"><br><img src="http://upload-images.jianshu.io/upload_images/1752522-2e4b0e5141927479.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="欢迎关注公众号: FullStackPlan 获取更多干货"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;YARN是Hadoop集群的资源管理系统。Hadoop2.0对MapReduce框架做了彻底的设计重构。YARN的基本设计思想是将MRv1中的JobTracker拆分成了两个独立的服务：一个&lt;strong&gt;全局的资源管理器ResourceManager&lt;/strong&gt;和&lt;strong&gt;每个应用程序特有的ApplicationMaster&lt;/strong&gt;。其中ResourceManager负责整个系统的&lt;strong&gt;资源管理和分配&lt;/strong&gt;，而ApplicationMaster负责&lt;strong&gt;单个应用程序的管理&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="YARN" scheme="http://linbingdong.com/categories/YARN/"/>
    
    
      <category term="大数据" scheme="http://linbingdong.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="YARN" scheme="http://linbingdong.com/tags/YARN/"/>
    
      <category term="Hadoop" scheme="http://linbingdong.com/tags/Hadoop/"/>
    
      <category term="资源管理" scheme="http://linbingdong.com/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
